import * as a from "three";
import { Mesh as ii, OrthographicCamera as ni, BufferGeometry as Ci, Float32BufferAttribute as sg, Loader as Ei, FileLoader as ai, Quaternion as Qg, Vector3 as JA, Color as Bg, Matrix4 as fe } from "three";
const oi = new ni(-1, 1, 1, -1, 0, 1);
class ri extends Ci {
  constructor() {
    super(), this.setAttribute("position", new sg([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new sg([0, 2, 0, 0, 2, 0], 2));
  }
}
const ci = new ri();
class lg {
  constructor(A) {
    this._mesh = new ii(ci, A);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(A) {
    A.render(this._mesh, oi);
  }
  get material() {
    return this._mesh.material;
  }
  set material(A) {
    this._mesh.material = A;
  }
}
var aA = Uint8Array, Dt = Uint16Array, hi = Int32Array, ug = new aA([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), wg = new aA([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), li = new aA([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), yg = function(t, A) {
  for (var e = new Dt(31), g = 0; g < 31; ++g)
    e[g] = A += 1 << t[g - 1];
  for (var I = new hi(e[30]), g = 1; g < 30; ++g)
    for (var s = e[g]; s < e[g + 1]; ++s)
      I[s] = s - e[g] << 5 | g;
  return { b: e, r: I };
}, Dg = yg(ug, 2), dg = Dg.b, ui = Dg.r;
dg[28] = 258, ui[258] = 28;
var wi = yg(wg, 0), yi = wi.b, ke = new Dt(32768);
for (var gA = 0; gA < 32768; ++gA) {
  var $A = (gA & 43690) >> 1 | (gA & 21845) << 1;
  $A = ($A & 52428) >> 2 | ($A & 13107) << 2, $A = ($A & 61680) >> 4 | ($A & 3855) << 4, ke[gA] = (($A & 65280) >> 8 | ($A & 255) << 8) >> 1;
}
var bt = function(t, A, e) {
  for (var g = t.length, I = 0, s = new Dt(A); I < g; ++I)
    t[I] && ++s[t[I] - 1];
  var Q = new Dt(A);
  for (I = 1; I < A; ++I)
    Q[I] = Q[I - 1] + s[I - 1] << 1;
  var B;
  if (e) {
    B = new Dt(1 << A);
    var i = 15 - A;
    for (I = 0; I < g; ++I)
      if (t[I])
        for (var C = I << 4 | t[I], E = A - t[I], n = Q[t[I] - 1]++ << E, o = n | (1 << E) - 1; n <= o; ++n)
          B[ke[n] >> i] = C;
  } else
    for (B = new Dt(g), I = 0; I < g; ++I)
      t[I] && (B[I] = ke[Q[t[I] - 1]++] >> 15 - t[I]);
  return B;
}, zt = new aA(288);
for (var gA = 0; gA < 144; ++gA)
  zt[gA] = 8;
for (var gA = 144; gA < 256; ++gA)
  zt[gA] = 9;
for (var gA = 256; gA < 280; ++gA)
  zt[gA] = 7;
for (var gA = 280; gA < 288; ++gA)
  zt[gA] = 8;
var pg = new aA(32);
for (var gA = 0; gA < 32; ++gA)
  pg[gA] = 5;
var Di = /* @__PURE__ */ bt(zt, 9, 1), di = /* @__PURE__ */ bt(pg, 5, 1), Ne = function(t) {
  for (var A = t[0], e = 1; e < t.length; ++e)
    t[e] > A && (A = t[e]);
  return A;
}, YA = function(t, A, e) {
  var g = A / 8 | 0;
  return (t[g] | t[g + 1] << 8) >> (A & 7) & e;
}, Me = function(t, A) {
  var e = A / 8 | 0;
  return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) >> (A & 7);
}, fg = function(t) {
  return (t + 7) / 8 | 0;
}, ft = function(t, A, e) {
  return (A == null || A < 0) && (A = 0), (e == null || e > t.length) && (e = t.length), new aA(t.subarray(A, e));
}, pi = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], DA = function(t, A, e) {
  var g = new Error(A || pi[t]);
  if (g.code = t, Error.captureStackTrace && Error.captureStackTrace(g, DA), !e)
    throw g;
  return g;
}, Ng = function(t, A, e, g) {
  var I = t.length, s = g ? g.length : 0;
  if (!I || A.f && !A.l)
    return e || new aA(0);
  var Q = !e, B = Q || A.i != 2, i = A.i;
  Q && (e = new aA(I * 3));
  var C = function(yA) {
    var NA = e.length;
    if (yA > NA) {
      var rA = new aA(Math.max(NA * 2, yA));
      rA.set(e), e = rA;
    }
  }, E = A.f || 0, n = A.p || 0, o = A.b || 0, r = A.l, l = A.d, c = A.m, h = A.n, u = I * 8;
  do {
    if (!r) {
      E = YA(t, n, 1);
      var y = YA(t, n + 1, 3);
      if (n += 3, y)
        if (y == 1)
          r = Di, l = di, c = 9, h = 5;
        else if (y == 2) {
          var m = YA(t, n, 31) + 257, N = YA(t, n + 10, 15) + 4, f = m + YA(t, n + 5, 31) + 1;
          n += 14;
          for (var D = new aA(f), R = new aA(19), S = 0; S < N; ++S)
            R[li[S]] = YA(t, n + S * 3, 7);
          n += N * 3;
          for (var M = Ne(R), L = (1 << M) - 1, G = bt(R, M, 1), S = 0; S < f; ) {
            var x = G[YA(t, n, L)];
            n += x & 15;
            var w = x >> 4;
            if (w < 16)
              D[S++] = w;
            else {
              var U = 0, J = 0;
              for (w == 16 ? (J = 3 + YA(t, n, 3), n += 2, U = D[S - 1]) : w == 17 ? (J = 3 + YA(t, n, 7), n += 3) : w == 18 && (J = 11 + YA(t, n, 127), n += 7); J--; )
                D[S++] = U;
            }
          }
          var AA = D.subarray(0, m), z = D.subarray(m);
          c = Ne(AA), h = Ne(z), r = bt(AA, c, 1), l = bt(z, h, 1);
        } else
          DA(1);
      else {
        var w = fg(n) + 4, d = t[w - 4] | t[w - 3] << 8, p = w + d;
        if (p > I) {
          i && DA(0);
          break;
        }
        B && C(o + d), e.set(t.subarray(w, p), o), A.b = o += d, A.p = n = p * 8, A.f = E;
        continue;
      }
      if (n > u) {
        i && DA(0);
        break;
      }
    }
    B && C(o + 131072);
    for (var eA = (1 << c) - 1, tA = (1 << h) - 1, X = n; ; X = n) {
      var U = r[Me(t, n) & eA], b = U >> 4;
      if (n += U & 15, n > u) {
        i && DA(0);
        break;
      }
      if (U || DA(2), b < 256)
        e[o++] = b;
      else if (b == 256) {
        X = n, r = null;
        break;
      } else {
        var W = b - 254;
        if (b > 264) {
          var S = b - 257, j = ug[S];
          W = YA(t, n, (1 << j) - 1) + dg[S], n += j;
        }
        var _ = l[Me(t, n) & tA], Y = _ >> 4;
        _ || DA(3), n += _ & 15;
        var z = yi[Y];
        if (Y > 3) {
          var j = wg[Y];
          z += Me(t, n) & (1 << j) - 1, n += j;
        }
        if (n > u) {
          i && DA(0);
          break;
        }
        B && C(o + 131072);
        var uA = o + W;
        if (o < z) {
          var nA = s - z, wA = Math.min(z, uA);
          for (nA + o < 0 && DA(3); o < wA; ++o)
            e[o] = g[nA + o];
        }
        for (; o < uA; ++o)
          e[o] = e[o - z];
      }
    }
    A.l = r, A.p = X, A.b = o, A.f = E, r && (E = 1, A.m = c, A.d = l, A.n = h);
  } while (!E);
  return o != e.length && Q ? ft(e, 0, o) : e.subarray(0, o);
}, fi = /* @__PURE__ */ new aA(0), HA = function(t, A) {
  return t[A] | t[A + 1] << 8;
}, vA = function(t, A) {
  return (t[A] | t[A + 1] << 8 | t[A + 2] << 16 | t[A + 3] << 24) >>> 0;
}, me = function(t, A) {
  return vA(t, A) + vA(t, A + 4) * 4294967296;
}, Ni = function(t) {
  (t[0] != 31 || t[1] != 139 || t[2] != 8) && DA(6, "invalid gzip data");
  var A = t[3], e = 10;
  A & 4 && (e += (t[10] | t[11] << 8) + 2);
  for (var g = (A >> 3 & 1) + (A >> 4 & 1); g > 0; g -= !t[e++])
    ;
  return e + (A & 2);
}, Se = /* @__PURE__ */ function() {
  function t(A, e) {
    typeof A == "function" && (e = A, A = {}), this.ondata = e;
    var g = A && A.dictionary && A.dictionary.subarray(-32768);
    this.s = { i: 0, b: g ? g.length : 0 }, this.o = new aA(32768), this.p = new aA(0), g && this.o.set(g);
  }
  return t.prototype.e = function(A) {
    if (this.ondata || DA(5), this.d && DA(4), !this.p.length)
      this.p = A;
    else if (A.length) {
      var e = new aA(this.p.length + A.length);
      e.set(this.p), e.set(A, this.p.length), this.p = e;
    }
  }, t.prototype.c = function(A) {
    this.s.i = +(this.d = A || !1);
    var e = this.s.b, g = Ng(this.p, this.s, this.o);
    this.ondata(ft(g, e, this.s.b), this.d), this.o = ft(g, this.s.b - 32768), this.s.b = this.o.length, this.p = ft(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  }, t.prototype.push = function(A, e) {
    this.e(A), this.c(e);
  }, t;
}();
function Mi(t, A) {
  return Ng(t, { i: 2 }, A && A.out, A && A.dictionary);
}
var Mg = /* @__PURE__ */ function() {
  function t(A, e) {
    this.v = 1, this.r = 0, Se.call(this, A, e);
  }
  return t.prototype.push = function(A, e) {
    if (Se.prototype.e.call(this, A), this.r += A.length, this.v) {
      var g = this.p.subarray(this.v - 1), I = g.length > 3 ? Ni(g) : 4;
      if (I > g.length) {
        if (!e)
          return;
      } else this.v > 1 && this.onmember && this.onmember(this.r - g.length);
      this.p = g.subarray(I), this.v = 0;
    }
    Se.prototype.c.call(this, e), this.s.f && !this.s.l && !e && (this.v = fg(this.s.p) + 9, this.s = { i: 0 }, this.o = new aA(0), this.push(new aA(0), e));
  }, t;
}(), Re = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), mi = 0;
try {
  Re.decode(fi, { stream: !0 }), mi = 1;
} catch {
}
var Si = function(t) {
  for (var A = "", e = 0; ; ) {
    var g = t[e++], I = (g > 127) + (g > 223) + (g > 239);
    if (e + I > t.length)
      return { s: A, r: ft(t, e - 1) };
    I ? I == 3 ? (g = ((g & 15) << 18 | (t[e++] & 63) << 12 | (t[e++] & 63) << 6 | t[e++] & 63) - 65536, A += String.fromCharCode(55296 | g >> 10, 56320 | g & 1023)) : I & 1 ? A += String.fromCharCode((g & 31) << 6 | t[e++] & 63) : A += String.fromCharCode((g & 15) << 12 | (t[e++] & 63) << 6 | t[e++] & 63) : A += String.fromCharCode(g);
  }
};
function Fi(t, A) {
  if (A) {
    for (var e = "", g = 0; g < t.length; g += 16384)
      e += String.fromCharCode.apply(null, t.subarray(g, g + 16384));
    return e;
  } else {
    if (Re)
      return Re.decode(t);
    var I = Si(t), s = I.s, e = I.r;
    return e.length && DA(8), s;
  }
}
var Gi = function(t, A) {
  return A + 30 + HA(t, A + 26) + HA(t, A + 28);
}, xi = function(t, A, e) {
  var g = HA(t, A + 28), I = Fi(t.subarray(A + 46, A + 46 + g), !(HA(t, A + 8) & 2048)), s = A + 46 + g, Q = vA(t, A + 20), B = e && Q == 4294967295 ? ki(t, s) : [Q, vA(t, A + 24), vA(t, A + 42)], i = B[0], C = B[1], E = B[2];
  return [HA(t, A + 10), i, C, I, s + HA(t, A + 30) + HA(t, A + 32), E];
}, ki = function(t, A) {
  for (; HA(t, A) != 1; A += 4 + HA(t, A + 2))
    ;
  return [me(t, A + 12), me(t, A + 4), me(t, A + 20)];
};
function Ri(t, A) {
  for (var e = {}, g = t.length - 22; vA(t, g) != 101010256; --g)
    (!g || t.length - g > 65558) && DA(13);
  var I = HA(t, g + 8);
  if (!I)
    return {};
  var s = vA(t, g + 16), Q = s == 4294967295 || I == 65535;
  if (Q) {
    var B = vA(t, g - 12);
    Q = vA(t, B) == 101075792, Q && (I = vA(t, B + 32), s = vA(t, B + 48));
  }
  for (var i = A && A.filter, C = 0; C < I; ++C) {
    var E = xi(t, s, Q), n = E[0], o = E[1], r = E[2], l = E[3], c = E[4], h = E[5], u = Gi(t, h);
    s = c, (!i || i({
      name: l,
      size: o,
      originalSize: r,
      compression: n
    })) && (n ? n == 8 ? e[l] = Mi(t.subarray(u, u + o), { out: new aA(r) }) : DA(14, "unknown compression type " + n) : e[l] = ft(t, u, u + o));
  }
  return e;
}
let jA;
const mg = typeof TextDecoder < "u" ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
typeof TextDecoder < "u" && mg.decode();
let Yt = null;
function Ui() {
  return (Yt === null || Yt.byteLength === 0) && (Yt = new Uint8Array(jA.memory.buffer)), Yt;
}
function Li(t, A) {
  return t = t >>> 0, mg.decode(Ui().subarray(t, t + A));
}
function Yi(t, A, e, g, I, s, Q, B, i, C, E) {
  return jA.raycast_splats(t, A, e, g, I, s, Q, B, i, C, E);
}
async function Ji(t, A) {
  if (typeof Response == "function" && t instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming == "function")
      try {
        return await WebAssembly.instantiateStreaming(t, A);
      } catch (g) {
        if (t.headers.get("Content-Type") != "application/wasm")
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", g);
        else
          throw g;
      }
    const e = await t.arrayBuffer();
    return await WebAssembly.instantiate(e, A);
  } else {
    const e = await WebAssembly.instantiate(t, A);
    return e instanceof WebAssembly.Instance ? { instance: e, module: t } : e;
  }
}
function vi() {
  const t = {};
  return t.wbg = {}, t.wbg.__wbg_buffer_609cc3eee51ed158 = function(A) {
    return A.buffer;
  }, t.wbg.__wbg_length_3b4f022188ae8db6 = function(A) {
    return A.length;
  }, t.wbg.__wbg_length_6ca527665d89694d = function(A) {
    return A.length;
  }, t.wbg.__wbg_length_8cfd2c6409af88ad = function(A) {
    return A.length;
  }, t.wbg.__wbg_new_9fee97a409b32b68 = function(A) {
    return new Uint16Array(A);
  }, t.wbg.__wbg_new_e3b321dcfef89fc7 = function(A) {
    return new Uint32Array(A);
  }, t.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(A, e, g) {
    return new Float32Array(A, e >>> 0, g >>> 0);
  }, t.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(A, e, g) {
    return new Uint32Array(A, e >>> 0, g >>> 0);
  }, t.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(A) {
    return new Float32Array(A >>> 0);
  }, t.wbg.__wbg_set_10bad9bee0e9c58b = function(A, e, g) {
    A.set(e, g >>> 0);
  }, t.wbg.__wbg_set_d23661d19148b229 = function(A, e, g) {
    A.set(e, g >>> 0);
  }, t.wbg.__wbg_set_f4f1f0daa30696fc = function(A, e, g) {
    A.set(e, g >>> 0);
  }, t.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(A, e, g) {
    return A.subarray(e >>> 0, g >>> 0);
  }, t.wbg.__wbg_subarray_769e1e0f81bb259b = function(A, e, g) {
    return A.subarray(e >>> 0, g >>> 0);
  }, t.wbg.__wbindgen_init_externref_table = function() {
    const A = jA.__wbindgen_export_0, e = A.grow(4);
    A.set(0, void 0), A.set(e + 0, void 0), A.set(e + 1, null), A.set(e + 2, !0), A.set(e + 3, !1);
  }, t.wbg.__wbindgen_memory = function() {
    return jA.memory;
  }, t.wbg.__wbindgen_throw = function(A, e) {
    throw new Error(Li(A, e));
  }, t;
}
function bi(t, A) {
  return jA = t.exports, Sg.__wbindgen_wasm_module = A, Yt = null, jA.__wbindgen_start(), jA;
}
async function Sg(t) {
  if (jA !== void 0) return jA;
  typeof t < "u" && (Object.getPrototypeOf(t) === Object.prototype ? { module_or_path: t } = t : console.warn("using deprecated parameters for the initialization function; pass a single object instead")), typeof t > "u" && (t = new URL("data:application/wasm;base64,AGFzbQEAAAAB8gEjYAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AX9gAX8AYAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAR/f39/AGABbwFvYANvb38AYAFvAX9gAAF/YAAAYAd/f39/f39/AX9gAX0BfWAGf39/f39/AGAEf39/fwF/YAN/b28Bf2ABfwFvYAABb2AHf39/f39/fwBgAn9+AX9gA39+fgBgC319fX19fX19f29/AW9gBn9/f39/fwF/YAV/f31/fwBgBH99f38AYAV/f35/fwBgBH9+f38AYAV/f3x/fwBgBH98f38AYAN/fn4Bf2ACfX0BfQLyBBEDd2JnHV9fd2JnX2J1ZmZlcl82MDljYzNlZWU1MWVkMTU4AAoDd2JnGl9fd2JnX25ld185ZmVlOTdhNDA5YjMyYjY4AAoDd2JnGl9fd2JnX3NldF9mNGYxZjBkYWEzMDY5NmZjAAsDd2JnHV9fd2JnX2xlbmd0aF84Y2ZkMmM2NDA5YWY4OGFkAAwDd2JnMV9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoX2YxZGVhZDQ0ZDFmYzcyMTIABwN3YmcaX193YmdfbmV3X2UzYjMyMWRjZmVmODlmYzcACgN3YmcaX193Ymdfc2V0X2QyMzY2MWQxOTE0OGIyMjkACwN3YmcdX193YmdfbGVuZ3RoXzZjYTUyNzY2NWQ4OTY5NGQADAN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZTZiN2U2OWFjZDRjNzM1NAAHA3diZxpfX3diZ19zZXRfMTBiYWQ5YmVlMGU5YzU4YgALA3diZx1fX3diZ19sZW5ndGhfM2I0ZjAyMjE4OGFlOGRiNgAMA3diZx9fX3diZ19zdWJhcnJheV83NjllMWUwZjgxYmIyNTliAAcDd2JnH19fd2JnX3N1YmFycmF5XzNhYWVlYzg5YmIyNTQ0ZjAABwN3YmckX193YmdfbmV3d2l0aGxlbmd0aF81YTVlZmUzMTNjZmQ1OWYxABQDd2JnEF9fd2JpbmRnZW5fdGhyb3cAAgN3YmcRX193YmluZGdlbl9tZW1vcnkAFQN3YmcfX193YmluZGdlbl9pbml0X2V4dGVybnJlZl90YWJsZQAOA8ABvgEEAAAGAAQCBAEADwQE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gP4HcgwDCyADQRB0IQMgAkUNASACQQ10QYCAgPwAcSABQQ10ckGAgIDAA2ogA3IMAgtBAkECQeiJwAAQaQALIAEgAWdBEGsiAUH//wNxQQhqdEH///8DcSADQYCAgNgDciABQRd0a3ILNgIIIAAgBDYCBCAAIAU2AgALlgQBBH8jAEGAAWsiBCQAAkACQAJAIAEoAggiAkGAgIAQcUUEQCACQYCAgCBxDQFBASECIAAoAgAgARAxRQ0CDAMLIAAoAgAhAgNAIAMgBGpB/wBqIAJBD3EiBUEwciAFQdcAaiAFQQpJGzoAACADQQFrIQMgAkEQSSACQQR2IQJFDQALQQEhAiABQc++wABBAiADIARqQYABakEAIANrECBFDQEMAgsgACgCACECA0AgAyAEakH/AGogAkEPcSIFQTByIAVBN2ogBUEKSRs6AAAgA0EBayEDIAJBD0sgAkEEdiECDQALQQEhAiABQc++wABBAiADIARqQYABakEAIANrECANAQsgASgCAEG7u8AAQQIgASgCBCgCDBEBAA0AAkAgASgCCCICQYCAgBBxRQRAIAJBgICAIHENASAAKAIEIAEQMSECDAILIAAoAgQhAkEAIQMDQCADIARqQf8AaiACQQ9xIgBBMHIgAEHXAGogAEEKSRs6AAAgA0EBayEDIAJBD0sgAkEEdiECDQALIAFBz77AAEECIAMgBGpBgAFqQQAgA2sQICECDAELIAAoAgQhAkEAIQMDQCADIARqQf8AaiACQQ9xIgBBMHIgAEE3aiAAQQpJGzoAACADQQFrIQMgAkEPSyACQQR2IQINAAsgAUHPvsAAQQIgAyAEakGAAWpBACADaxAgIQILIARBgAFqJAAgAgu6BAEIfyMAQRBrIgMkACADIAE2AgQgAyAANgIAIANCoICAgA43AggCfwJAAkACQCACKAIQIgkEQCACKAIUIgANAQwCCyACKAIMIgBFDQEgAigCCCIBIABBA3RqIQQgAEEBa0H/////AXFBAWohBiACKAIAIQADQAJAIABBBGooAgAiBUUNACADKAIAIAAoAgAgBSADKAIEKAIMEQEARQ0AQQEMBQtBASABKAIAIAMgAUEEaigCABEAAA0EGiAAQQhqIQAgBCABQQhqIgFHDQALDAILIABBGGwhCiAAQQFrQf////8BcUEBaiEGIAIoAggh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EGokAAuCAwEEfyAAKAIMIQICQAJAAkAgAUGAAk8EQCAAKAIYIQMCQAJAIAAgAkYEQCAAQRRBECAAKAIUIgIbaigCACIBDQFBACECDAILIAAoAggiASACNgIMIAIgATYCCAwBCyAAQRRqIABBEGogAhshBANAIAQhBSABIgJBFGogAkEQaiACKAIUIgEbIQQgAkEUQRAgARtqKAIAIgENAAsgBUEANgIACyADRQ0CAkAgACgCHEECdEG41sAAaiIBKAIAIABHBEAgAygCECAARg0BIAMgAjYCFCACDQMMBAsgASACNgIAIAJFDQQMAgsgAyACNgIQIAINAQwCCyAAKAIIIgAgAkcEQCAAIAI2AgwgAiAANgIIDwtB0NnAAEHQ2cAAKAIAQX4gAUEDdndxNgIADwsgAiADNgIYIAAoAhAiAQRAIAIgATYCECABIAI2AhgLIAAoAhQiAEUNACACIAA2AhQgACACNgIYDwsPC0HU2cAAQdTZwAAoAgBBfiAAKAIcd3E2AgAL+QICBH8BfiMAQSBrIgIkAAJAAkACQCAAKAIAIgNFDQAgACgCCCIBIAAoAgRPDQACQAJAAkAgASADaiIDLQAAQcIARgRAIAAgAUEBajYCCCACIAAQXiACKAIADQEgACgCECIBRQ0CQZyswABBjKzAACACLQAEQQFxIgMbQRlBECADGyABEMcBRQ0CQQIhAQwGCyADLQAAQckARw0DIAAgAUEBajYCCEECIQEgAEEAEBJFDQQMBQsgACgCEEUNASAAKQIAIQUgACACKQIANwIAIAJBGGoiAyAAQQhqIgEpAgA3AwAgASACQQhqKQIANwIAIAIgBTcDECAAEDMgASADKQMANwIAIAAgAikDEDcCAEH/AXEhAQwECyAAIAIpAgA3AgAgAEEIaiACQQhqKQIANwIAC0EAIQEMAgtBAkEAIABBABASGyEBDAELIAAoAhAiAwRAQcCmwABBASADEMcBDQELQQJBASAAEDlBAXEbIQELIAJBIGokACABC/MCAgd/A34jAEEQayIEJAAgASgCACEGAkACQCABKAIIIgIgASgCBCIHSQRAIAIgBmotAABB3wBGDQELIAIgByACIAdLGyEIAkADQAJAIAIgB0kEQCACIAZqLQAAQd8ARg0DCyACIAhGDQACQCACIAZqLQAAIgVBMGsiA0H/AXFB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OgABDAILIAAgAy0AAToAAQwBC0EAIQILIAAgAjoAACADQRBqJAALqwEBAn8jAEEgayIBJAACQCAAKAIEIgJBA0YgAkECSXINAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGkiMAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGIicAAEIABAAsgAEEIahBLIAAoAggiAkUNACAAKAIMIAJBDGxBBBCsAQsgACgCHCICBEAgACgCICACQQEQrAELIABBKEEEEKwBIAFBIGokAAuiAQICfwF+IwBBEGsiAiQAIAEoAgghAyACIAEQNAJAIAItAABBAUYEQCACLQABIQEgAEEANgIAIAAgAToABAwBCyACKQMIIgQgA0EBa61UBEAgASgCDEEBaiIDQfQDTQRAIAAgAzYCDCAAIAQ+AgggACABKQIANwIADAILIABBADYCACAAQQE6AAQMAQsgAEEANgIAIABBADoABAsgAkEQaiQAC5sBAgR/AW8jAEEgayIDJAAgACgCACIGEMsBIQAgAyACNgIEIAMgADYCACAAIAJGBEAQmgEiBBCSASIFJQEgASACEAQhBxBWIgAgByYBIARBhAFPBEAgBBBVCyAFQYQBTwRAIAUQVQsgBiAAQQAQqwEgAEGEAU8EQCAAEFULIANBIGokAA8LIANBADYCCCADIANBBGogA0EIahB8AAuUAQEDfyMAQRBrIgIkAAJ/QQEgASgCACIDQScgASgCBCIEKAIQIgERAAANABogAkEEaiAAKAIAQYECEB8CQCACLQAEQYABRgRAIAMgAigCCCABEQAARQ0BQQEMAgsgAyACLQAOIgAgAkEEamogAi0ADyAAayAEKAIMEQEARQ0AQQEMAQsgA0EnIAERAAALIAJBEGokAAuiAQECfyMAQSBrIgEkAAJAIAAoAgQiAkEDRiACQQJJcg0AAkACQCAALQAYQQFrDgICAAELIAFBATYCCCABQaSIwAA2AgQgAUIANwIQIAEgAUEcajYCDCABQQRqQYiJwAAQgAEACyAAQQhqEEsgACgCCCICRQ0AIAAoAgwgAkEMbEEEEKwBCyAAKAIcIgIEQCAAKAIgIAJBARCsAQsgAUEgaiQAC5UBAQN/An8CQAJAIAEoAgAiA0UEQAwBCwNAAkAgASgCCCIEIAEoAgRPDQAgAyAEai0AAEHFAEcNACABIARBAWo2AggMAgsCQCACRQ0AIAEoAhAiA0UNAEG9rMAAQQIgAxDHAQ0DCyABEBYNAiACQQFqIQIgASgCACIDDQALC0EADAELQQELIQEgACACNgIEIAAgATYCAAuVAQECfyMAQSBrIgMkAAJAIAAoAgQiBEEDRiAEQQJJcg0AAkACQCAALQAYQQFrDgICAAELIANBATYCCCADQaSIwAA2AgQgA0IANwIQIAMgA0EcajYCDCADQQRqQYiJwAAQgAEACyAAQQhqEEsgACgCCCIERQ0AIAAoAgwgBEEMbEEEEKwBCyAAQShBBBCsASADQSBqJAALhAEBA38CfwJAIAAoAgAiAUUNAANAAkAgACgCCCIDIAAoAgRPDQAgASADai0AAEHFAEcNACAAIANBAWo2AggMAgsCQCACRQ0AIAAoAhAiAUUNAEG9rMAAQQIgARDHAUUNAEEBDwtBASAAQQEQEw0CGiACQQFrIQIgACgCACIBDQALC0EACwt6AQF/IwBBIGsiAiQAAn8gACgCAEGAgICAeEcEQCABIAAoAgQgACgCCBCWAQwBCyACQRBqIAAoAgwoAgAiAEEIaikCADcDACACQRhqIABBEGopAgA3AwAgAiAAKQIANwMIIAEoAgAgASgCBCACQQhqECYLIAJBIGokAAt8AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQQI2AhwgBUGUvsAANgIYIAVCAjcCJCAFIAVBEGqtQoCAgIDAC4Q3AzggBSAFQQhqrUKAgICA0AuENwMwIAUgBUEwajYCICAFQRhqIAQQgAEAC3gBA38CQCAAKAIAIgFBgICAgHhHBEAgAUUNASAAKAIEIAFBARCsAQ8LIAAtAARBA0cNACAAKAIIIgAoAgAhASAAQQRqKAIAIgMoAgAiAgRAIAEgAhEFAAsgAygCBCICBEAgASACIAMoAggQrAELIABBDEEEEKwBCwtuAQF/IwBBEGsiACQAIAACfyACKAIABEBBxJzAACEDQQkMAQsgAEEEaiACKAIEIAIoAggQIUHEnMAAIAAoAgggACgCBCICGyEDQQkgACgCDCACGws2AgggACADNgIEIABBBGogARBaIABBEGokAAtpAgF/AX4jAEEwayIDJAAgAyABNgIEIAMgADYCACADQQI2Agwg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A3FBAXQiBEHSvsAAai0AADoAACACQQJrIARB0b7AAGotAAA6AAAgAEEEayEAIAhC/6ziBFYgByEIDQALCyAHQglWBEAgACADakELaiAHpyICIAJB//8DcUHkAG4iAkHkAGxrQf//A3FBAXQiBEHSvsAAai0AADoAACAAQQJrIgAgA0EMamogBEHRvsAAai0AADoAACACrSEHCyAJUEUgB1BxRQRAIABBAWsiACADQQxqaiAHp0EBdEEecUHSvsAAai0AADoAAAsgAUEBQQAgA0EMaiAAakEUIABrECAgA0EgaiQACw0AIABB5IrAACABECYLCgAgACABIAIQJgsOACABQfCMwABBBRCWAQvCAwIGfwF+IAAoAgAhACMAQdAAayICJAAgAkEgaiAAIAAoAgAoAgQRAgAgAiACQcgAaq1CgICAgMADhDcDKEEBIQMgAkEBNgI0IAJB1I7AADYCMCACQgE3AjwgAiACKQMgNwJIIAIgAkEoajYCOAJAIAEoAgAiBiABKAIEIgcgAkEwahAmDQAgAS0ACkGAAXFFBEBBACEDDAELIAJBGGogACAAKAIAKAIEEQIAIAJBEGogAigCGCACKAIcKAIYEQIAIAIoAhAiBEUEQEEAIQMMAQsgAkEIaiAEIAIoAhQiBSgCGBECACACKAIMIQEgAigCCCEAIAIgBTYCLCACIAQ2AiggAkEBNgI0IAJB4I7AADYCMCACQgE3AjwgAiACQShqrUKAgICAwAOEIgg3A0ggAiACQcgAajYCOCAGIAcgAkEwahC1AQ0AA0AgAEUEQEEAIQMMAgsgAiAAIAEoAhgRAgAgAigCBCACKAIAIAIgATYCLCACIAA2AiggAkEBNgI0IAJB4I7AADYCMCACQgE3AjwgAiAINwNIIAIgAkHIAGo2AjghACEBIAYgByACQTBqELUBRQ0ACwsgAkHQAGokACADCw0AIABBmJLAACABECYLCQAgACABEA4ACykAAn8gACgCAC0AAEUEQCABQbTAwABBBRAjDAELIAFBucDAAEEEECMLCw0AIABB9JfAACABECYLygECA38BfiAAKAIAIQIjAEGAAWsiBCQAAkAgASkCCCIFpyIAQYCAgARxRQ0AIABBgICAwABxBEAgAEGAgIAIciEADAELIAFBCjsBDCAAQYCAgMgAciEACyABIABBgICABHI2AghBACEAA0AgACAEakH/AGogAkEPcSIDQTByIANB1wBqIANBCkkbOgAAIABBAWshACACQQ9LIAJBBHYhAg0ACyABQc++wABBAiAAIARqQYABakEAIABrECAgASAFNwIIIARBgAFqJAALDAAgACABKQIANwMAC8IYAhN/AX4gACgCACEAIwBBIGsiECQAAn8gACgCAEUEQCAQQQA2AhwgECABNgIYIBBCADcCECAQIAApAgQ3AgggEEEIakEBEBIMAQsgASEKIwBBEGsiDSQAIAAoAgghEiAAKAIEIQ8gACgCACEIAkACQAJAA0AgFCIGIBJJIRMgBiASTw0CIAghAQJAAkAgD0UNACAGQQFqIgsgBiATGyEUIA9BAWshCCABLQAAIQRBACEDAkACQANAAkACQCAEwEEASARAIARBH3EhByABIANqIgJBAWotAABBP3EhBSAEQf8BcSIAQd8BSw0BIAdBBnQgBXIhAgwCCyAEQf8BcSECDAELIAJBAmotAABBP3EgBUEGdHIhBSAAQfABSQRAIAUgB0EMdHIhAgwBCyAHQRJ0QYCA8ABxIAJBA2otAABBP3EgBUEGdHJyIgJBgIDEAEYNBAsgAkEwa0EKSQRAIAMgCEYNBCABIANqIgBBAWosAAAiBEG/f0wNAiADQQFqIQMMAQsLIAMNAUEAIQAMBQsgACAPIANrIgBBASAAQYSlwAAQmQEACyABIANqIgksAABBv39KDQEgASAPQQAgA0GUpcAAEJkBAAtB9KTAABCyAQALIAEtAAAhCAJAAkACQAJAIANBAUYEQEEBIQAgASECIAhBK2sOAwYBBgELIAhBK0YEQCADQQFrIQAgAUEBaiECIANBCkkNAQwCCyABIQIgAyEAIANBCU8NAQtBACEFA0AgAi0AAEEwayIIQQlLDQIgAkEBaiECIAggBUEKbGohBSAAQQFrIgANAAsMAgtBACEFIAAhCANAIAhFDQIgAi0AAEEwayIOQQlLDQFBAiEAIAWtQgp+IhVCIIinDQQgAkEBaiECIAhBAWshCCAOIBWnIgdqIgUgB08NAAsMAwtBASEADAILIA8gBWshBwJAAkACQAJAIAVFDQAgDyADayIIIAVNBEAgAyAHRg0BDAQLIAEgBWogA2oiACwAAEFASA0DIAAsAABBv39MDQELIAEgBWogA2ohCCALIBJH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bGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5L3J1c3RjLzZiMDBiYzM4ODAxOTg2MDAxMzBlMWNmNjJiOGY4YTkzNDk0NDg4Y2MvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAAATBhAASwAAAPAKAAAOAAAARXJyb3Jhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbikAAAATBhAASwAAALUFAAANAAAAAAAAABAAAAAEAAAAGQAAABoAAAAbAAAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYW55aG93LTEuMC45OC9zcmMvZXJyb3IucnPoBhAAXAAAAGcEAAAOAAAAAQAAAAAAAAA6IAAAXAcQAAIAAAAKCkNhdXNlZCBieToKAAAAdAcQAAEAAAAKCnN0YWNrIGJhY2t0cmFjZTpTdGFjayBiYWNrdHJhY2U6CgCSBxAAEQAAAFMvcnVzdGMvNmIwMGJjMzg4MDE5ODYwMDEzMGUxY2Y2MmI4ZjhhOTM0OTQ0ODhjYy9saWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjL21vZC5ycwAAAK0HEABQAAAALgIAABEAAAAvcnVzdGMvNmIwMGJjMzg4MDE5ODYwMDEzMGUxY2Y2MmI4ZjhhOTM0OTQ0ODhjYy9saWJyYXJ5L2NvcmUvc3JjL3NsaWNlL2luZGV4LnJzABAIEABPAAAATAMAADQAAAAQCBAATwAAAFMDAAAyAAAAYXNzZXJ0aW9uIGZhaWxlZDogc2VsZi5pc19jaGFyX2JvdW5kYXJ5KG4pL3J1c3RjLzZiMDBiYzM4ODAxOTg2MDAxMzBlMWNmNjJiOGY4YTkzNDk0NDg4Y2MvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAAAAqggQAEsAAAAMCAAAHQAAAKoIEABLAAAAFAgAAB0AAAAjAAAADAAAAAQAAAAkAAAAJQAAACEAAAAvcnVzdGMvNmIwMGJjMzg4MDE5ODYwMDEzMGUxY2Y2MmI4ZjhhOTM0OTQ0ODhjYy9saWJyYXJ5L2NvcmUvc3JjL2l0ZXIvdHJhaXRzL2l0ZXJhdG9yLnJzMAkQAFgAAADRBwAACQAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2pzLXN5cy0wLjMuNzcvc3JjL2xpYi5ycwAAmAkQAFoAAAD7GAAAAQAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3dhc20tYmluZGdlbi0wLjIuMTAwL3NyYy9jb252ZXJ0L3NsaWNlcy5ycwQKEABsAAAAJAEAAA4AAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZExhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZLIKEAAqAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvb25jZV9jZWxsLTEuMjEuMy9zcmMvbGliLnJzAAAA5AoQAF0AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AABUCxAADgAAAOQKEABdAAAAegIAAA0AAAA6IAAAAAAAAAQAAAAEAAAANwAAAC9ydXN0Yy82YjAwYmMzODgwMTk4NjAwMTMwZTFjZjYyYjhmOGE5MzQ5NDQ4OGNjL2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMvbW9kLnJzkAsQAFAAAAAuAgAAEQAAADoAAAA4AAAADAAAAAQAAAA5AAAAOgAAADsAAAAvcnVzdC9kZXBzL2RsbWFsbG9jLTAuMi44L3NyYy9kbG1hbGxvYy5yc2Fzc2VydGlvbiBmYWlsZWQ6IHBzaXplID49IHNpemUgKyBtaW5fb3ZlcmhlYWQADAwQACkAAACsBAAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IHBzaXplIDw9IHNpemUgKyBtYXhfb3ZlcmhlYWQAAAwMEAApAAAAsgQAAA0AAABsaWJyYXJ5L3N0ZC9zcmMvc3luYy9sYXp5X2xvY2sucnMAAAC0DBAAIQAAANEAAAATAAAAbGlicmFyeS9z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", import.meta.url));
  const A = vi();
  (typeof t == "string" || typeof Request == "function" && t instanceof Request || typeof URL == "function" && t instanceof URL) && (t = fetch(t));
  const { instance: e, module: g } = await Ji(await t, A);
  return bi(e, g);
}
const TA = -12, Hi = 9, XA = (Hi - TA) / 254, Ti = -30, Nt = Math.exp(Ti), Ki = 11, qi = 11, O = 1 << Ki, It = 1 << qi, Fg = 1;
function ht(t) {
  return t === "bool" || t === "bvec2" || t === "bvec3" || t === "bvec4";
}
function lt(t) {
  return t === "int" || t === "uint" || t === "float";
}
function cA(t) {
  return t === "int" || t === "ivec2" || t === "ivec3" || t === "ivec4";
}
function hA(t) {
  return t === "uint" || t === "uvec2" || t === "uvec3" || t === "uvec4";
}
function Vt(t) {
  return t === "float" || t === "vec2" || t === "vec3" || t === "vec4";
}
function Gg(t) {
  return t === "mat2" || t === "mat2x2" || t === "mat2x3" || t === "mat2x4" || t === "mat3" || t === "mat3x2" || t === "mat3x3" || t === "mat3x4" || t === "mat4" || t === "mat4x2" || t === "mat4x3" || t === "mat4x4";
}
function Bt(t) {
  return Vt(t) || Gg(t);
}
function xt(t) {
  return t === "vec2" || t === "ivec2" || t === "uvec2";
}
function kt(t) {
  return t === "vec3" || t === "ivec3" || t === "uvec3";
}
function Zt(t) {
  return t === "vec4" || t === "ivec4" || t === "uvec4";
}
function zi(t) {
  return xt(t) || kt(t) || Zt(t);
}
function it(t) {
  return t === "mat2" || t === "mat2x2";
}
function nt(t) {
  return t === "mat3" || t === "mat3x3";
}
function Ct(t) {
  return t === "mat4" || t === "mat4x4";
}
function xg(t) {
  switch (t) {
    case "vec2":
      return "float";
    case "vec3":
      return "float";
    case "vec4":
      return "float";
    case "ivec2":
      return "int";
    case "ivec3":
      return "int";
    case "ivec4":
      return "int";
    case "uvec2":
      return "uint";
    case "uvec3":
      return "uint";
    case "uvec4":
      return "uint";
    default:
      throw new Error(`Invalid vector type: ${t}`);
  }
}
function kg(t) {
  switch (t) {
    case "vec2":
    case "ivec2":
    case "uvec2":
      return 2;
    case "vec3":
    case "ivec3":
    case "uvec3":
      return 3;
    case "vec4":
    case "ivec4":
    case "uvec4":
      return 4;
    default:
      throw new Error(`Invalid vector type: ${t}`);
  }
}
function Vi(t) {
  if (lt(t))
    return "float";
  if (xt(t))
    return "vec2";
  if (kt(t))
    return "vec3";
  if (Zt(t))
    return "vec4";
  throw new Error(`Invalid vector type: ${t}`);
}
function Rg(t) {
  if (lt(t))
    return "uint";
  if (xt(t))
    return "uvec2";
  if (kt(t))
    return "uvec3";
  if (Zt(t))
    return "uvec4";
  throw new Error(`Invalid vector type: ${t}`);
}
function Zi(t) {
  if (lt(t))
    return "int";
  if (xt(t))
    return "ivec2";
  if (kt(t))
    return "ivec3";
  if (Zt(t))
    return "ivec4";
  throw new Error(`Invalid vector type: ${t}`);
}
function Ug(t) {
  if (typeof t == "string")
    return t;
  if (typeof t == "object" && t.type)
    return t.type;
  throw new Error(`Invalid DynoType: ${String(t)}`);
}
function sA(t) {
  return Math.trunc(t).toString();
}
function QA(t) {
  return `${Math.max(0, Math.trunc(t)).toString()}u`;
}
function T(t) {
  return t === Number.POSITIVE_INFINITY ? "INFINITY" : t === Number.NEGATIVE_INFINITY ? "-INFINITY" : Number.isInteger(t) ? t.toFixed(1) : t.toString();
}
function V(t) {
  return t instanceof st ? t.type : t.dynoOut().type;
}
class st {
  constructor(A) {
    this.__isDynoValue = !0, this.type = A;
  }
}
class q extends st {
  constructor(A, e) {
    super(A.outTypes[e]), this.dyno = A, this.key = e;
  }
}
class Mt extends st {
  constructor(A, e) {
    super(A), this.literal = e;
  }
  getLiteral() {
    return this.literal;
  }
}
function Qe(t, A) {
  return new Mt(t, A);
}
class Lg extends Mt {
  constructor(A, e) {
    super(A, ""), this.value = e;
  }
  getLiteral() {
    const { type: A, value: e } = this;
    switch (A) {
      case "bool":
        return e ? "true" : "false";
      case "uint":
        return QA(e);
      case "int":
        return sA(e);
      case "float":
        return T(e);
      case "bvec2": {
        const g = e;
        return `bvec2(${g[0]}, ${g[1]})`;
      }
      case "uvec2": {
        if (e instanceof a.Vector2)
          return `uvec2(${QA(e.x)}, ${QA(e.y)})`;
        const g = e;
        return `uvec2(${QA(g[0])}, ${QA(g[1])})`;
      }
      case "ivec2": {
        if (e instanceof a.Vector2)
          return `ivec2(${sA(e.x)}, ${sA(e.y)})`;
        const g = e;
        return `ivec2(${sA(g[0])}, ${sA(g[1])})`;
      }
      case "vec2": {
        if (e instanceof a.Vector2)
          return `vec2(${T(e.x)}, ${T(e.y)})`;
        const g = e;
        return `vec2(${T(g[0])}, ${T(g[1])})`;
      }
      case "bvec3": {
        const g = e;
        return `bvec3(${g[0]}, ${g[1]}, ${g[2]})`;
      }
      case "uvec3": {
        if (e instanceof a.Vector3)
          return `uvec3(${QA(e.x)}, ${QA(e.y)}, ${QA(e.z)})`;
        const g = e;
        return `uvec3(${QA(g[0])}, ${QA(g[1])}, ${QA(g[2])})`;
      }
      case "ivec3": {
        if (e instanceof a.Vector3)
          return `ivec3(${sA(e.x)}, ${sA(e.y)}, ${sA(e.z)})`;
        const g = e;
        return `ivec3(${sA(g[0])}, ${sA(g[1])}, ${sA(g[2])})`;
      }
      case "vec3": {
        if (e instanceof a.Vector3)
          return `vec3(${T(e.x)}, ${T(e.y)}, ${T(e.z)})`;
        const g = e;
        return `vec3(${T(g[0])}, ${T(g[1])}, ${T(g[2])})`;
      }
      case "bvec4": {
        const g = e;
        return `bvec4(${g[0]}, ${g[1]}, ${g[2]}, ${g[3]})`;
      }
      case "uvec4": {
        if (e instanceof a.Vector4)
          return `uvec4(${QA(e.x)}, ${QA(e.y)}, ${QA(e.z)}, ${QA(e.w)})`;
        const g = e;
        return `uvec4(${QA(g[0])}, ${QA(g[1])}, ${QA(g[2])}, ${QA(g[3])})`;
      }
      case "ivec4": {
        if (e instanceof a.Vector4)
          return `ivec4(${sA(e.x)}, ${sA(e.y)}, ${sA(e.z)}, ${sA(e.w)})`;
        const g = e;
        return `ivec4(${sA(g[0])}, ${sA(g[1])}, ${sA(g[2])}, ${sA(g[3])})`;
      }
      case "vec4": {
        if (e instanceof a.Vector4)
          return `vec4(${T(e.x)}, ${T(e.y)}, ${T(e.z)}, ${T(e.w)})`;
        if (e instanceof a.Quaternion)
          return `vec4(${T(e.x)}, ${T(e.y)}, ${T(e.z)}, ${T(e.w)})`;
        const g = e;
        return `vec4(${T(g[0])}, ${T(g[1])}, ${T(g[2])}, ${T(g[3])})`;
      }
      case "mat2":
      case "mat2x2": {
        const g = e, I = g instanceof a.Matrix2 ? g.elements : e, s = new Array(4).fill(0).map((Q, B) => T(I[B]));
        return `${A}(${s.join(", ")})`;
      }
      case "mat2x3": {
        const g = e, I = new Array(6).fill(0).map((s, Q) => T(g[Q]));
        return `${A}(${I.join(", ")})`;
      }
      case "mat2x4": {
        const g = e, I = new Array(8).fill(0).map((s, Q) => T(g[Q]));
        return `${A}(${I.join(", ")})`;
      }
      case "mat3":
      case "mat3x3": {
        const g = e, I = g instanceof a.Matrix3 ? g.elements : e, s = new Array(9).fill(0).map((Q, B) => T(I[B]));
        return `${A}(${s.join(", ")})`;
      }
      case "mat3x2": {
        const g = e, I = new Array(6).fill(0).map((s, Q) => T(g[Q]));
        return `${A}(${I.join(", ")})`;
      }
      case "mat3x4": {
        const g = e, I = new Array(12).fill(0).map((s, Q) => T(g[Q]));
        return `${A}(${I.join(", ")})`;
      }
      case "mat4":
      case "mat4x4": {
        const g = e, I = g instanceof a.Matrix4 ? g.elements : e, s = new Array(16).fill(0).map((Q, B) => T(I[B]));
        return `${A}(${s.join(", ")})`;
      }
      case "mat4x2": {
        const g = e, I = new Array(8).fill(0).map((s, Q) => T(g[Q]));
        return `${A}(${I.join(", ")})`;
      }
      case "mat4x3": {
        const g = e, I = new Array(12).fill(0).map((s, Q) => T(g[Q]));
        return `${A}(${I.join(", ")})`;
      }
      default:
        throw new Error(`Type not implemented: ${String(A)}`);
    }
  }
}
function K(t, A) {
  return new Lg(t, A);
}
function Jt(t) {
  const A = String(t);
  if (ht(t))
    return `${A}(false)`;
  if (Bt(t))
    return `${A}(0.0)`;
  if (cA(t))
    return `${A}(0)`;
  if (hA(t))
    return `${A}(0u)`;
  throw new Error(`Type not implemented: ${A}`);
}
function ji(t) {
  const A = String(t);
  if (ht(t))
    return `${A}(true)`;
  if (Bt(t))
    return `${A}(1.0)`;
  if (cA(t))
    return `${A}(1)`;
  if (hA(t))
    return `${A}(1u)`;
  throw new Error(`Type not implemented: ${A}`);
}
function Xi(t) {
  const A = String(t);
  if (ht(t))
    return `${A}(true)`;
  if (Bt(t))
    return `${A}(-1.0)`;
  if (cA(t))
    return `${A}(-1)`;
  if (hA(t))
    return `${A}(0xFFFFFFFFu)`;
  throw new Error(`Type not implemented: ${A}`);
}
const ig = "    ";
class Yg {
  constructor({ indent: A } = {}) {
    this.globals = /* @__PURE__ */ new Set(), this.statements = [], this.uniforms = {}, this.declares = /* @__PURE__ */ new Set(), this.updaters = [], this.sequence = 0, this.indent = ig, this.indent = A ?? ig;
  }
  nextSequence() {
    return this.sequence++;
  }
}
class Z {
  constructor({
    inTypes: A,
    outTypes: e,
    inputs: g,
    update: I,
    globals: s,
    statements: Q,
    generate: B
  }) {
    this.inTypes = A ?? {}, this.outTypes = e ?? {}, this.inputs = g ?? {}, this.update = I, this.globals = s, this.statements = Q, this.generate = B ?? (({ inputs: i, outputs: C, compile: E }) => {
      var n, o;
      return {
        globals: (n = this.globals) == null ? void 0 : n.call(this, { inputs: i, outputs: C, compile: E }),
        statements: (o = this.statements) == null ? void 0 : o.call(this, { inputs: i, outputs: C, compile: E })
      };
    });
  }
  get outputs() {
    const A = {};
    for (const e in this.outTypes)
      A[e] = new q(this, e);
    return A;
  }
  apply(A) {
    return Object.assign(this.inputs, A), this.outputs;
  }
  compile({
    inputs: A,
    outputs: e,
    compile: g
  }) {
    const I = [
      `// ${this.constructor.name}(${Object.values(A).join(", ")}) => (${Object.values(e).join(", ")})`
    ], s = [];
    for (const C in e) {
      const E = e[C];
      E && !g.declares.has(E) && (g.declares.add(E), s.push(C));
    }
    const { globals: Q, statements: B, uniforms: i } = this.generate({
      inputs: A,
      outputs: e,
      compile: g
    });
    for (const C of Q ?? [])
      g.globals.add(C);
    for (const C in i)
      g.uniforms[C] = i[C];
    this.update && g.updaters.push(this.update);
    for (const C of s) {
      const E = e[C];
      E && (g.uniforms[E] || I.push(`${je(E, this.outTypes[C])};`));
    }
    return B != null && B.length && (I.push("{"), I.push(...B.map((C) => g.indent + C)), I.push("}")), I;
  }
}
class zA extends Z {
  constructor({
    inTypes: A,
    outTypes: e,
    inputs: g,
    update: I,
    globals: s,
    construct: Q
  }) {
    super({
      inTypes: A,
      outTypes: e,
      inputs: g,
      update: I,
      globals: s,
      generate: (B) => this.generateBlock(B)
    }), this.construct = Q;
  }
  generateBlock({
    inputs: A,
    outputs: e,
    compile: g
  }) {
    var l, c;
    const I = {}, s = {};
    for (const h in A)
      A[h] != null && (I[h] = new Mt(this.inTypes[h], A[h]));
    for (const h in e)
      e[h] != null && (s[h] = new st(this.outTypes[h]));
    const Q = { roots: [] }, B = this.construct(I, s, Q);
    for (const h of ((l = this.globals) == null ? void 0 : l.call(this, { inputs: A, outputs: e, compile: g })) ?? [])
      g.globals.add(h);
    const i = [], C = /* @__PURE__ */ new Map();
    function E(h, u, y) {
      let w = C.get(h);
      if (!w) {
        w = {
          sequence: g.nextSequence(),
          outNames: /* @__PURE__ */ new Map(),
          newOuts: /* @__PURE__ */ new Set()
        }, C.set(h, w);
        for (const d in h.inputs) {
          let p = h.inputs[d];
          for (; p; ) {
            if (p instanceof st) {
              p instanceof q && E(p.dyno, p.key);
              break;
            }
            p = p.dynoOut();
          }
        }
        i.push(h);
      }
      u && (y || w.newOuts.add(u), w.outNames.set(u, y ?? `${u}_${w.sequence}`));
    }
    for (const h of Q.roots)
      E(h);
    for (const h in s) {
      let u = (B == null ? void 0 : B[h]) ?? s[h];
      for (; u; ) {
        if (u instanceof st) {
          u instanceof q && E(u.dyno, u.key, e[h]);
          break;
        }
        u = u.dynoOut();
      }
      s[h] = u;
    }
    const n = [];
    for (const h of i) {
      const u = {}, y = {};
      for (const p in h.inputs) {
        let m = h.inputs[p];
        for (; m; ) {
          if (m instanceof st) {
            if (m instanceof Mt)
              u[p] = m.getLiteral();
            else if (m instanceof q) {
              const N = (c = C.get(m.dyno)) == null ? void 0 : c.outNames.get(m.key);
              if (!N)
                throw new Error(
                  `Source not found for ${m.dyno.constructor.name}.${m.key}`
                );
              u[p] = N;
            }
            break;
          }
          m = m.dynoOut();
        }
      }
      const w = C.get(h) ?? { outNames: /* @__PURE__ */ new Map() };
      for (const [p, m] of w.outNames.entries())
        y[p] = m;
      const d = h.compile({ inputs: u, outputs: y, compile: g });
      n.push(d);
    }
    const o = [];
    for (const h in e)
      s[h] instanceof Mt && o.push(
        `${e[h]} = ${s[h].getLiteral()};`
      );
    return o.length > 0 && n.push(o), { statements: n.flatMap((h, u) => u === 0 ? h : ["", ...h]) };
  }
}
function SA(t, A, e, { update: g, globals: I } = {}) {
  return new zA({ inTypes: t, outTypes: A, construct: e, update: g, globals: I });
}
function jt({
  inTypes: t,
  outTypes: A,
  inputs: e,
  update: g,
  globals: I,
  statements: s,
  generate: Q
}) {
  return new Z({
    inTypes: t,
    outTypes: A,
    inputs: e,
    update: g,
    globals: I,
    statements: s,
    generate: Q
  });
}
function je(t, A, e) {
  const g = typeof A == "string" ? A : A.type;
  if (!g)
    throw new Error(`Invalid DynoType: ${String(A)}`);
  return `${g} ${t}${e != null ? `[${e}]` : ""}`;
}
function UA(t) {
  var s;
  let A = !1;
  const e = t.split(`
`).map((Q) => {
    const B = Q.trimEnd();
    return A ? B : B.length > 0 ? (A = !0, B) : null;
  }).filter((Q) => Q != null);
  for (; e.length > 0 && e[e.length - 1].length === 0; )
    e.pop();
  if (e.length === 0)
    return [];
  const g = (s = e[0].match(/^\s*/)) == null ? void 0 : s[0];
  if (!g)
    return e;
  const I = new RegExp(`^${g}`);
  return e.map((Q) => Q.replace(I, ""));
}
function oA(t) {
  return UA(t).join(`
`);
}
class F extends Z {
  constructor({
    a: A,
    outKey: e,
    outTypeFunc: g
  }) {
    const I = { a: V(A) }, s = g(V(A)), Q = { [e]: s };
    super({ inTypes: I, outTypes: Q, inputs: { a: A } }), this.outKey = e;
  }
  dynoOut() {
    return new q(this, this.outKey);
  }
}
class $ extends Z {
  constructor({
    a: A,
    b: e,
    outKey: g,
    outTypeFunc: I
  }) {
    const s = { a: V(A), b: V(e) }, Q = I(V(A), V(e)), B = { [g]: Q };
    super({ inTypes: s, outTypes: B, inputs: { a: A, b: e } }), this.outKey = g;
  }
  dynoOut() {
    return new q(this, this.outKey);
  }
}
class ut extends Z {
  constructor({
    a: A,
    b: e,
    c: g,
    outKey: I,
    outTypeFunc: s
  }) {
    const Q = { a: V(A), b: V(e), c: V(g) }, B = s(V(A), V(e), V(g)), i = { [I]: B };
    super({ inTypes: Q, outTypes: i, inputs: { a: A, b: e, c: g } }), this.outKey = I;
  }
  dynoOut() {
    return new q(this, this.outKey);
  }
}
const P = { type: "Gsplat" }, Xt = { type: "PackedSplats" }, Wi = (t) => new vg({ packedSplats: t }), mt = (t, A) => new Hg({ packedSplats: t, index: A }), Jg = (t, A, e, g) => new Tg({ packedSplats: t, index: A, base: e, count: g }), at = (t) => new Kg({ gsplat: t }), Qt = ({
  gsplat: t,
  flags: A,
  index: e,
  center: g,
  scales: I,
  quaternion: s,
  rgba: Q,
  rgb: B,
  opacity: i,
  x: C,
  y: E,
  z: n,
  r: o,
  g: r,
  b: l
}) => new qg({
  gsplat: t,
  flags: A,
  index: e,
  center: g,
  scales: I,
  quaternion: s,
  rgba: Q,
  rgb: B,
  opacity: i,
  x: C,
  y: E,
  z: n,
  r: o,
  g: r,
  b: l
}), Ue = (t) => new Vg({ gsplat: t }), Xe = (t, {
  scale: A,
  rotate: e,
  translate: g,
  recolor: I
}) => new Zg({ gsplat: t, scale: A, rotate: e, translate: g, recolor: I }), FA = oA(`
  struct Gsplat {
    vec3 center;
    uint flags;
    vec3 scales;
    int index;
    vec4 quaternion;
    vec4 rgba;
  };
  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;

  bool isGsplatActive(uint flags) {
    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;
  }
`), he = oA(`
  struct PackedSplats {
    usampler2DArray texture;
    int numSplats;
  };
`);
class vg extends F {
  constructor({
    packedSplats: A
  }) {
    super({ a: A, outKey: "numSplats", outTypeFunc: () => "int" }), this.statements = ({ inputs: e, outputs: g }) => [
      `${g.numSplats} = ${e.a}.numSplats;`
    ];
  }
}
const bg = oA(`
  bool readPackedSplat(usampler2DArray texture, int numSplats, int index, out Gsplat gsplat) {
    if ((index >= 0) && (index < numSplats)) {
      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);
      unpackSplat(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba);
      return true;
    } else {
      return false;
    }
  }
`);
class Hg extends Z {
  constructor({
    packedSplats: A,
    index: e
  }) {
    super({
      inTypes: { packedSplats: Xt, index: "int" },
      outTypes: { gsplat: P },
      inputs: { packedSplats: A, index: e },
      globals: () => [FA, he, bg],
      statements: ({ inputs: g, outputs: I }) => {
        const { gsplat: s } = I;
        if (!s)
          return [];
        const { packedSplats: Q, index: B } = g;
        let i;
        return Q && B ? i = UA(`
            if (readPackedSplat(${Q}.texture, ${Q}.numSplats, ${B}, ${s})) {
              bool zeroSize = all(equal(${s}.scales, vec3(0.0, 0.0, 0.0)));
              ${s}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
            } else {
              ${s}.flags = 0u;
            }
          `) : i = [`${s}.flags = 0u;`], i.push(`${s}.index = ${B ?? "0"};`), i;
      }
    });
  }
  dynoOut() {
    return new q(this, "gsplat");
  }
}
class Tg extends Z {
  constructor({
    packedSplats: A,
    index: e,
    base: g,
    count: I
  }) {
    super({
      inTypes: {
        packedSplats: Xt,
        index: "int",
        base: "int",
        count: "int"
      },
      outTypes: { gsplat: P },
      inputs: { packedSplats: A, index: e, base: g, count: I },
      globals: () => [FA, he, bg],
      statements: ({ inputs: s, outputs: Q }) => {
        const { gsplat: B } = Q;
        if (!B)
          return [];
        const { packedSplats: i, index: C, base: E, count: n } = s;
        let o;
        return i && C && E && n ? o = UA(`
            ${B}.flags = 0u;
            if ((${C} >= ${E}) && (${C} < (${E} + ${n}))) {
              if (readPackedSplat(${i}.texture, ${i}.numSplats, ${C}, ${B})) {
                bool zeroSize = all(equal(${B}.scales, vec3(0.0, 0.0, 0.0)));
                ${B}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
              }
            }
          `) : o = [`${B}.flags = 0u;`], o.push(`${B}.index = ${C ?? "0"};`), o;
      }
    });
  }
  dynoOut() {
    return new q(this, "gsplat");
  }
}
class Kg extends Z {
  constructor({ gsplat: A }) {
    super({
      inTypes: { gsplat: P },
      outTypes: {
        flags: "uint",
        active: "bool",
        index: "int",
        center: "vec3",
        scales: "vec3",
        quaternion: "vec4",
        rgba: "vec4",
        rgb: "vec3",
        opacity: "float",
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      },
      inputs: { gsplat: A },
      globals: () => [FA],
      statements: ({ inputs: e, outputs: g }) => {
        const { gsplat: I } = e, {
          flags: s,
          active: Q,
          index: B,
          center: i,
          scales: C,
          quaternion: E,
          rgba: n,
          rgb: o,
          opacity: r,
          x: l,
          y: c,
          z: h,
          r: u,
          g: y,
          b: w
        } = g;
        return [
          s ? `${s} = ${I ? `${I}.flags` : "0u"};` : null,
          Q ? `${Q} = isGsplatActive(${I ? `${I}.flags` : "0u"});` : null,
          B ? `${B} = ${I ? `${I}.index` : "0"};` : null,
          i ? `${i} = ${I ? `${I}.center` : "vec3(0.0, 0.0, 0.0)"};` : null,
          C ? `${C} = ${I ? `${I}.scales` : "vec3(0.0, 0.0, 0.0)"};` : null,
          E ? `${E} = ${I ? `${I}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)"};` : null,
          n ? `${n} = ${I ? `${I}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)"};` : null,
          o ? `${o} = ${I ? `${I}.rgba.rgb` : "vec3(0.0, 0.0, 0.0)"};` : null,
          r ? `${r} = ${I ? `${I}.rgba.a` : "0.0"};` : null,
          l ? `${l} = ${I ? `${I}.center.x` : "0.0"};` : null,
          c ? `${c} = ${I ? `${I}.center.y` : "0.0"};` : null,
          h ? `${h} = ${I ? `${I}.center.z` : "0.0"};` : null,
          u ? `${u} = ${I ? `${I}.rgba.r` : "0.0"};` : null,
          y ? `${y} = ${I ? `${I}.rgba.g` : "0.0"};` : null,
          w ? `${w} = ${I ? `${I}.rgba.b` : "0.0"};` : null
        ].filter(Boolean);
      }
    });
  }
}
class qg extends Z {
  constructor({
    gsplat: A,
    flags: e,
    index: g,
    center: I,
    scales: s,
    quaternion: Q,
    rgba: B,
    rgb: i,
    opacity: C,
    x: E,
    y: n,
    z: o,
    r,
    g: l,
    b: c
  }) {
    super({
      inTypes: {
        gsplat: P,
        flags: "uint",
        index: "int",
        center: "vec3",
        scales: "vec3",
        quaternion: "vec4",
        rgba: "vec4",
        rgb: "vec3",
        opacity: "float",
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      },
      outTypes: { gsplat: P },
      inputs: {
        gsplat: A,
        flags: e,
        index: g,
        center: I,
        scales: s,
        quaternion: Q,
        rgba: B,
        rgb: i,
        opacity: C,
        x: E,
        y: n,
        z: o,
        r,
        g: l,
        b: c
      },
      globals: () => [FA],
      statements: ({ inputs: h, outputs: u }) => {
        const { gsplat: y } = u;
        if (!y)
          return [];
        const {
          gsplat: w,
          flags: d,
          index: p,
          center: m,
          scales: N,
          quaternion: f,
          rgba: D,
          rgb: R,
          opacity: S,
          x: M,
          y: L,
          z: G,
          r: x,
          g: U,
          b: J
        } = h;
        return [
          `${y}.flags = ${d ?? (w ? `${w}.flags` : "0u")};`,
          `${y}.index = ${p ?? (w ? `${w}.index` : "0")};`,
          `${y}.center = ${m ?? (w ? `${w}.center` : "vec3(0.0, 0.0, 0.0)")};`,
          `${y}.scales = ${N ?? (w ? `${w}.scales` : "vec3(0.0, 0.0, 0.0)")};`,
          `${y}.quaternion = ${f ?? (w ? `${w}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)")};`,
          `${y}.rgba = ${D ?? (w ? `${w}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)")};`,
          R ? `${y}.rgba.rgb = ${R};` : null,
          S ? `${y}.rgba.a = ${S};` : null,
          M ? `${y}.center.x = ${M};` : null,
          L ? `${y}.center.y = ${L};` : null,
          G ? `${y}.center.z = ${G};` : null,
          x ? `${y}.rgba.r = ${x};` : null,
          U ? `${y}.rgba.g = ${U};` : null,
          J ? `${y}.rgba.b = ${J};` : null
        ].filter(Boolean);
      }
    });
  }
  dynoOut() {
    return new q(this, "gsplat");
  }
}
const zg = oA(`
  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {
    float minScale = min(scales.x, min(scales.y, scales.z));
    vec3 normal;
    if (scales.z == minScale) {
      normal = vec3(0.0, 0.0, 1.0);
    } else if (scales.y == minScale) {
      normal = vec3(0.0, 1.0, 0.0);
    } else {
      normal = vec3(1.0, 0.0, 0.0);
    }
    return quatVec(quaternion, normal);
  }
`);
class Vg extends F {
  constructor({ gsplat: A }) {
    super({ a: A, outKey: "normal", outTypeFunc: () => "vec3" }), this.globals = () => [FA, zg], this.statements = ({ inputs: e, outputs: g }) => [
      `${g.normal} = gsplatNormal(${e.a}.scales, ${e.a}.quaternion);`
    ];
  }
}
class Zg extends Z {
  constructor({
    gsplat: A,
    scale: e,
    rotate: g,
    translate: I,
    recolor: s
  }) {
    super({
      inTypes: {
        gsplat: P,
        scale: "float",
        rotate: "vec4",
        translate: "vec3",
        recolor: "vec4"
      },
      outTypes: { gsplat: P },
      inputs: { gsplat: A, scale: e, rotate: g, translate: I, recolor: s },
      globals: () => [FA],
      statements: ({ inputs: Q, outputs: B, compile: i }) => {
        const { gsplat: C } = B;
        if (!C || !Q.gsplat)
          return [];
        const { scale: E, rotate: n, translate: o, recolor: r } = Q, l = i.indent;
        return [
          `${C} = ${Q.gsplat};`,
          `if (isGsplatActive(${C}.flags)) {`,
          E ? `${l}${C}.center *= ${E};` : null,
          n ? `${l}${C}.center = quatVec(${n}, ${C}.center);` : null,
          o ? `${l}${C}.center += ${o};` : null,
          E ? `${l}${C}.scales *= ${E};` : null,
          n ? `${l}${C}.quaternion = quatQuat(${n}, ${C}.quaternion);` : null,
          r ? `${l}${C}.rgba *= ${r};` : null,
          "}"
        ].filter(Boolean);
      }
    });
  }
  dynoOut() {
    return new q(this, "gsplat");
  }
}
const jg = (t) => new Xg({ gsplat: t }), _i = (t) => new We({ rgba8: t });
class Xg extends Z {
  constructor({ gsplat: A }) {
    super({
      inTypes: { gsplat: P },
      inputs: { gsplat: A },
      globals: () => [FA],
      statements: ({ inputs: e, outputs: g }) => {
        const { output: I } = g;
        if (!I)
          return [];
        const { gsplat: s } = e;
        return s ? UA(`
            if (isGsplatActive(${s}.flags)) {
              ${I} = packSplat(${s}.center, ${s}.scales, ${s}.quaternion, ${s}.rgba);
            } else {
              ${I} = uvec4(0u, 0u, 0u, 0u);
            }
          `) : [`${I} = uvec4(0u, 0u, 0u, 0u);`];
      }
    });
  }
  dynoOut() {
    return new q(this, "output");
  }
}
class We extends Z {
  constructor({ rgba8: A }) {
    super({
      inTypes: { rgba8: "vec4" },
      inputs: { rgba8: A },
      statements: ({ inputs: e, outputs: g }) => [
        `target = ${e.rgba8 ?? "vec4(0.0, 0.0, 0.0, 0.0)"};`
      ]
    });
  }
  dynoOut() {
    return new q(this, "rgba8");
  }
}
const Oi = (t, A, e) => new k({ key: t, type: A, value: e }), Pi = (t = !1, A) => new Be({ key: A, value: t }), $i = (t = 0, A) => new Wg({ key: A, value: t }), An = (t = 0, A) => new Kt({ key: A, value: t }), bA = (t = 0, A) => new ot({ key: A, value: t }), tn = (t, A) => new _g({ key: A, value: t }), en = (t, A) => new Og({ key: A, value: t }), gn = (t, A) => new Pg({ key: A, value: t }), In = (t, A) => new $g({ key: A, value: t }), sn = (t, A) => new AI({ key: A, value: t }), Qn = (t, A) => new tI({ key: A, value: t }), Bn = (t, A) => new eI({ key: A, value: t }), At = (t, A) => new Ft({ key: A, value: t }), nn = (t, A) => new gI({ key: A, value: t }), Cn = (t, A) => new II({ key: A, value: t }), En = (t, A) => new sI({ key: A, value: t }), an = (t, A) => new Wt({ key: A, value: t }), on = (t, A) => new QI({ key: A, value: t }), rn = (t, A) => new BI({ key: A, value: t }), cn = (t, A) => new iI({ key: A, value: t }), hn = (t, A) => new nI({ key: A, value: t }), ln = (t, A) => new CI({ key: A, value: t }), un = (t, A) => new EI({ key: A, value: t }), wn = (t, A) => new aI({ key: A, value: t }), yn = (t, A) => new oI({ key: A, value: t }), Dn = (t, A) => new rI({ key: A, value: t }), dn = (t, A) => new cI({ key: A, value: t }), pn = (t, A) => new hI({ key: A, value: t }), fn = (t, A) => new lI({ key: A, value: t }), Nn = (t, A) => new uI({ key: A, value: t }), Mn = (t, A) => new wI({ key: A, value: t }), mn = (t, A) => new yI({ key: A, value: t }), Sn = (t, A) => new Ht({ key: A, value: t }), Fn = (t, A) => new DI({ key: t, value: A }), Gn = (t, A) => new dI({ key: A, value: t }), xn = (t, A) => new pI({ key: A, value: t }), kn = (t, A) => new fI({ key: A, value: t }), Rn = (t, A) => new NI({ key: A, value: t }), Un = (t, A) => new MI({ key: A, value: t }), Ln = (t, A) => new mI({ key: A, value: t }), Yn = (t, A) => new SI({ key: A, value: t }), Jn = (t, A) => new FI({ key: A, value: t }), vn = (t, A) => new GI({ key: A, value: t }), bn = (t, A) => new xI({ key: A, value: t });
class k extends Z {
  constructor({
    key: A,
    type: e,
    count: g,
    value: I,
    update: s,
    globals: Q
  }) {
    A = A ?? "value", super({
      outTypes: { [A]: e },
      update: () => {
        if (s) {
          const B = s(this.value);
          B !== void 0 && (this.value = B);
        }
        this.uniform.value = this.value;
      },
      generate: ({ inputs: B, outputs: i }) => {
        const C = (Q == null ? void 0 : Q({ inputs: B, outputs: i })) ?? [], E = {}, n = i[A];
        return n && (C.push(`uniform ${je(n, e, g)};`), E[n] = this.uniform), { globals: C, uniforms: E };
      }
    }), this.type = e, this.count = g, this.value = I, this.uniform = { value: I }, this.outKey = A;
  }
  dynoOut() {
    return new q(this, this.outKey);
  }
}
class Be extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "bool", value: e, update: g });
  }
}
class Wg extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "uint", value: e, update: g });
  }
}
class Kt extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "int", value: e, update: g });
  }
}
class ot extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "float", value: e, update: g });
  }
}
class _g extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "bvec2", value: e, update: g });
  }
}
class Og extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "uvec2", value: e, update: g });
  }
}
class Pg extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "ivec2", value: e, update: g });
  }
}
class $g extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "vec2", value: e, update: g });
  }
}
class AI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "bvec3", value: e, update: g });
  }
}
class tI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "uvec3", value: e, update: g });
  }
}
class eI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "ivec3", value: e, update: g });
  }
}
class Ft extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "vec3", value: e, update: g });
  }
}
class gI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "bvec4", value: e, update: g });
  }
}
class II extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "uvec4", value: e, update: g });
  }
}
class sI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "ivec4", value: e, update: g });
  }
}
class Wt extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "vec4", value: e, update: g });
  }
}
class QI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "mat2", value: e, update: g });
  }
}
class BI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "mat2x2", value: e, update: g });
  }
}
class iI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "mat2x3", value: e, update: g });
  }
}
class nI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "mat2x4", value: e, update: g });
  }
}
class CI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "mat3", value: e, update: g });
  }
}
class EI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "mat3x2", value: e, update: g });
  }
}
class aI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "mat3x3", value: e, update: g });
  }
}
class oI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "mat3x4", value: e, update: g });
  }
}
class rI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "mat4", value: e, update: g });
  }
}
class cI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "mat4x2", value: e, update: g });
  }
}
class hI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "mat4x3", value: e, update: g });
  }
}
class lI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "mat4x4", value: e, update: g });
  }
}
class uI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "usampler2D", value: e, update: g });
  }
}
class wI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "isampler2D", value: e, update: g });
  }
}
class yI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "sampler2D", value: e, update: g });
  }
}
class Ht extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "usampler2DArray", value: e, update: g });
  }
}
class DI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "isampler2DArray", value: e, update: g });
  }
}
class dI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "sampler2DArray", value: e, update: g });
  }
}
class pI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "usampler3D", value: e, update: g });
  }
}
class fI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "isampler3D", value: e, update: g });
  }
}
class NI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "sampler3D", value: e, update: g });
  }
}
class MI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "usamplerCube", value: e, update: g });
  }
}
class mI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "isamplerCube", value: e, update: g });
  }
}
class SI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "samplerCube", value: e, update: g });
  }
}
class FI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "sampler2DShadow", value: e, update: g });
  }
}
class GI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "sampler2DArrayShadow", value: e, update: g });
  }
}
class xI extends k {
  constructor({
    key: A,
    value: e,
    update: g
  }) {
    super({ key: A, type: "samplerCubeShadow", value: e, update: g });
  }
}
const _t = new Float32Array(1), le = new Uint32Array(_t.buffer);
function Hn(t) {
  return _t[0] = t, le[0];
}
function Tn(t) {
  return le[0] = t, _t[0];
}
function rt(t) {
  _t[0] = t;
  const A = le[0], e = A >> 31 & 1, g = A >> 23 & 255, I = A & 8388607, s = e << 15;
  if (g === 255)
    return I !== 0 ? s | 32767 : s | 31744;
  const Q = g - 127 + 15;
  if (Q >= 31)
    return s | 31744;
  if (Q <= 0) {
    if (Q < -10)
      return s;
    const i = (I | 8388608) >> 1 - Q + 13;
    return s | i;
  }
  const B = I >> 13;
  return s | Q << 10 | B;
}
function dA(t) {
  const A = t >> 15 & 1, e = t >> 10 & 31, g = t & 1023;
  let I;
  if (e === 0)
    if (g === 0)
      I = A << 31;
    else {
      let s = g, Q = -14;
      for (; (s & 1024) === 0; )
        s <<= 1, Q--;
      s &= 1023;
      const B = Q + 127, i = s << 13;
      I = A << 31 | B << 23 | i;
    }
  else if (e === 31)
    g === 0 ? I = A << 31 | 2139095040 : I = A << 31 | 2143289344;
  else {
    const s = e - 15 + 127, Q = g << 13;
    I = A << 31 | s << 23 | Q;
  }
  return le[0] = I, _t[0];
}
function GA(t) {
  return Math.max(0, Math.min(255, Math.round(t * 255)));
}
function ge(t) {
  return Math.max(-127, Math.min(127, Math.round(t * 127)));
}
function Kn(t) {
  return t / 255;
}
function qn(t) {
  return t / 127;
}
class zn {
  // Create a DataCache with a given function that fetches data not in the cache.
  constructor({
    asyncFetch: A,
    maxItems: e = 5
  }) {
    this.asyncFetch = A, this.maxItems = e, this.items = [];
  }
  // Fetch data for the key, returning cached data if available.
  async getFetch(A) {
    const e = this.items.findIndex((I) => I.key === A);
    if (e >= 0) {
      const I = this.items.splice(e, 1)[0];
      return this.items.push(I), I.data;
    }
    const g = await this.asyncFetch(A);
    for (this.items.push({ key: A, data: g }); this.items.length > this.maxItems; )
      this.items.shift();
    return g;
  }
}
function Vn(t, A) {
  const e = Object.entries(t).map(([g, I]) => [
    g,
    A(I, g)
  ]);
  return Object.fromEntries(e);
}
function Zn(t, A) {
  const e = Object.entries(t).map(([g, I]) => [g, A(I, g)]).filter(([g, I]) => I !== void 0);
  return Object.fromEntries(e);
}
function kI(t) {
  const A = [], e = /* @__PURE__ */ new Set();
  function g(I) {
    I && typeof I == "object" && !e.has(I) && (e.add(I), I instanceof ArrayBuffer ? A.push(I) : ArrayBuffer.isView(I) ? A.push(I.buffer) : Array.isArray(I) ? I.forEach(g) : Object.values(I).forEach(g));
  }
  return g(t), A;
}
function jn(t, A) {
  return new Array(t).fill(null).map((e, g) => A(g));
}
class RI {
  constructor({
    // Allocate a new item with the given args
    allocate: A,
    // Dispose of an item (optional, if GC is enough)
    dispose: e,
    // Check if an existing item in the list is valid for the given args,
    // allowing you to store heterogeneous items in the list.
    valid: g
  }) {
    this.items = [], this.allocate = A, this.dispose = e, this.valid = g;
  }
  // Allocate a new item from the free list, first checking if a existing item
  // on the freelist is valid for the given args.
  alloc(A) {
    for (; ; ) {
      const e = this.items.pop();
      if (!e)
        break;
      if (this.valid(e, A))
        return e;
      this.dispose && this.dispose(e);
    }
    return this.allocate(A);
  }
  free(A) {
    this.items.push(A);
  }
  disposeAll() {
    let A;
    for (A = this.items.pop(); A; )
      this.dispose && this.dispose(A), A = this.items.pop();
  }
}
function Le(t, A, e, g, I, s, Q, B, i, C, E, n, o, r, l, c) {
  const h = GA(r), u = GA(l), y = GA(c), w = GA(o), d = _e(
    new a.Quaternion(i, C, E, n)
  ), p = d & 255, m = d >>> 8 & 255, N = d >>> 16 & 255, f = s < Nt ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(s) - TA) / XA) + 1
    )
  ), D = Q < Nt ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(Q) - TA) / XA) + 1
    )
  ), R = B < Nt ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(B) - TA) / XA) + 1
    )
  ), S = rt(e), M = rt(g), L = rt(I), G = A * 4;
  t[G] = h | u << 8 | y << 16 | w << 24, t[G + 1] = S | M << 16, t[G + 2] = L | p << 16 | m << 24, t[G + 3] = f | D << 8 | R << 16 | N << 24;
}
function Xn(t, A, e, g, I) {
  const s = rt(e), Q = rt(g), B = rt(I), i = A * 4;
  t[i + 1] = s | Q << 16, t[i + 2] = B | t[i + 2] & 4294901760;
}
function Wn(t, A, e, g, I) {
  const s = e < Nt ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(e) - TA) / XA) + 1
    )
  ), Q = g < Nt ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(g) - TA) / XA) + 1
    )
  ), B = I < Nt ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(I) - TA) / XA) + 1
    )
  ), i = A * 4;
  t[i + 3] = s | Q << 8 | B << 16 | t[i + 3] & 4278190080;
}
function _n(t, A, e, g, I, s) {
  const Q = _e(
    new a.Quaternion(e, g, I, s)
  ), B = Q & 255, i = Q >>> 8 & 255, C = Q >>> 16 & 255, E = A * 4;
  t[E + 2] = t[E + 2] & 65535 | B << 16 | i << 24, t[E + 3] = t[E + 3] & 16777215 | C << 24;
}
function On(t, A, e, g, I, s) {
  const Q = GA(e), B = GA(g), i = GA(I), C = GA(s), E = A * 4;
  t[E] = Q | B << 8 | i << 16 | C << 24;
}
function Pn(t, A, e, g, I) {
  const s = GA(e), Q = GA(g), B = GA(I), i = A * 4;
  t[i] = s | Q << 8 | B << 16 | t[i] & 4278190080;
}
function $n(t, A, e) {
  const g = GA(e), I = A * 4;
  t[I] = t[I] & 16777215 | g << 24;
}
const AC = new a.Vector3(), tC = new a.Vector3(), eC = new a.Quaternion(), gC = new a.Color(), IC = {
  center: AC,
  scales: tC,
  quaternion: eC,
  color: gC,
  opacity: 0
};
function Ye(t, A) {
  const e = IC, g = A * 4, I = t[g], s = t[g + 1], Q = t[g + 2], B = t[g + 3];
  e.color.set(
    (I & 255) / 255,
    (I >>> 8 & 255) / 255,
    (I >>> 16 & 255) / 255
  ), e.opacity = (I >>> 24 & 255) / 255, e.center.set(
    dA(s & 65535),
    dA(s >>> 16 & 65535),
    dA(Q & 65535)
  );
  const i = B & 255;
  e.scales.x = i === 0 ? 0 : Math.exp(TA + (i - 1) * XA);
  const C = B >>> 8 & 255;
  e.scales.y = C === 0 ? 0 : Math.exp(TA + (C - 1) * XA);
  const E = B >>> 16 & 255;
  e.scales.z = E === 0 ? 0 : Math.exp(TA + (E - 1) * XA);
  const n = Q >>> 16 & 65535 | B >>> 8 & 16711680;
  return HI(n, e.quaternion), e;
}
function fA(t) {
  const A = O, e = Math.max(
    Fg,
    Math.min(It, Math.ceil(t / A))
  ), g = Math.ceil(t / (A * e)), I = A * e * g;
  return { width: A, height: e, depth: g, maxSplats: I };
}
function sC(t) {
  const A = O, e = Math.max(
    Fg,
    Math.min(It, Math.ceil(t / A))
  ), g = Math.ceil(t / (A * e));
  return A * e * g;
}
function QC() {
  return navigator.maxTouchPoints > 0 ? !0 : /Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile/.test(
    navigator.userAgent
  );
}
function BC() {
  return /Android/.test(navigator.userAgent);
}
function iC() {
  return /Oculus/.test(navigator.userAgent);
}
function nC(t, A, e) {
  const g = new Uint8Array(A * 4);
  for (let I = 0; I < e / 2; I++) {
    const s = I * A * 4, Q = (e - 1 - I) * A * 4;
    g.set(t.subarray(s, s + A * 4)), t.set(
      t.subarray(Q, Q + A * 4),
      s
    ), t.set(g, Q);
  }
  return t;
}
function CC(t, A, e) {
  const g = document.createElement("canvas");
  g.width = A, g.height = e;
  const I = g.getContext("2d");
  if (!I)
    throw new Error("Can't get 2d context");
  const s = I.createImageData(A, e);
  return s.data.set(t), I.putImageData(s, 0, 0), g.toDataURL("image/png");
}
function UI(t) {
  const A = new a.Clock(t.autoStart);
  return A.startTime = t.startTime, A.oldTime = t.oldTime, A.elapsedTime = t.elapsedTime, A.running = t.running, A;
}
function EC(t) {
  return Object.fromEntries(
    Object.entries(t).filter(([A, e]) => e !== void 0)
  );
}
const LI = oA(`
  precision highp float;

  in vec3 position;

  void main() {
    gl_Position = vec4(position.xy, 0.0, 1.0);
  }
`);
function YI(t) {
  const A = new a.Vector3();
  for (const e of t)
    A.add(e);
  return A.divideScalar(t.length);
}
function JI(t) {
  if (t.length === 0)
    return new a.Quaternion();
  const A = t[0].clone();
  for (let e = 1; e < t.length; e++)
    t[e].dot(t[0]) < 0 ? (A.x -= t[e].x, A.y -= t[e].y, A.z -= t[e].z, A.w -= t[e].w) : (A.x += t[e].x, A.y += t[e].y, A.z += t[e].z, A.w += t[e].w);
  return A.normalize();
}
function vI(t, A) {
  const e = new a.Vector3(0, 0, 0).applyMatrix4(t), g = new a.Vector3(0, 0, 0).applyMatrix4(A), I = new a.Vector3(0, 0, -1).applyMatrix4(t).sub(e).normalize(), s = new a.Vector3(0, 0, -1).applyMatrix4(A).sub(g).normalize(), Q = e.distanceTo(g), B = I.dot(s);
  return { distance: Q, coincidence: B };
}
function aC({
  matrix1: t,
  matrix2: A,
  maxDistance: e
}) {
  const g = new a.Vector3(0, 0, 0).applyMatrix4(t), I = new a.Vector3(0, 0, 0).applyMatrix4(A);
  return g.distanceTo(I) <= e;
}
function oC({
  matrix1: t,
  matrix2: A,
  maxDistance: e,
  minCoincidence: g
}) {
  const { distance: I, coincidence: s } = vI(t, A);
  return I <= e && (g == null || s >= g);
}
function bI(t, A) {
  const [e, g] = [new a.Vector3(), new a.Quaternion()], [I, s] = [new a.Vector3(), new a.Quaternion()];
  t.decompose(e, g, new a.Vector3()), A.decompose(I, s, new a.Vector3());
  const Q = e.distanceTo(I), B = Math.abs(g.dot(s));
  return { distance: Q, coorient: B };
}
function ie({
  matrix1: t,
  matrix2: A,
  maxDistance: e,
  minCoorient: g
}) {
  const { distance: I, coorient: s } = bI(t, A);
  return I <= e && (g == null || s >= g);
}
function rC(t, A = 1e-3) {
  return Math.abs(t) < A ? 0 : Math.sign(t);
}
function cC(t) {
  const A = t.w < 0, e = ge(A ? -t.x : t.x), g = ge(A ? -t.y : t.y), I = ge(A ? -t.z : t.z), s = e & 255, Q = g & 255, B = I & 255;
  return s | Q << 8 | B << 16;
}
function hC(t, A) {
  const e = t << 24 >> 24, g = t << 16 >> 24, I = t << 8 >> 24;
  A.set(e / 127, g / 127, I / 127, 0);
  const s = A.x * A.x + A.y * A.y + A.z * A.z;
  return A.w = Math.sqrt(Math.max(0, 1 - s)), A;
}
function _e(t) {
  const A = t.clone().normalize();
  A.w < 0 && A.set(-A.x, -A.y, -A.z, -A.w);
  const e = 2 * Math.acos(A.w), g = Math.sqrt(
    A.x * A.x + A.y * A.y + A.z * A.z
  ), I = g < 1e-6 ? new a.Vector3(1, 0, 0) : new a.Vector3(A.x, A.y, A.z).divideScalar(g), s = Math.abs(I.x) + Math.abs(I.y) + Math.abs(I.z);
  let Q = I.x / s, B = I.y / s;
  if (I.z < 0) {
    const r = Q;
    Q = (1 - Math.abs(B)) * (Q >= 0 ? 1 : -1), B = (1 - Math.abs(r)) * (B >= 0 ? 1 : -1);
  }
  const i = Q * 0.5 + 0.5, C = B * 0.5 + 0.5, E = Math.round(i * 255), n = Math.round(C * 255);
  return Math.round(e * (255 / Math.PI)) << 16 | n << 8 | E;
}
function HI(t, A) {
  const e = t & 255, g = t >>> 8 & 255, I = t >>> 16 & 255, s = e / 255, Q = g / 255;
  let B = (s - 0.5) * 2, i = (Q - 0.5) * 2;
  const C = 1 - (Math.abs(B) + Math.abs(i)), E = Math.max(-C, 0);
  B += B >= 0 ? -E : E, i += i >= 0 ? -E : E;
  const n = new a.Vector3(B, i, C).normalize(), r = I / 255 * Math.PI * 0.5, l = Math.sin(r), c = Math.cos(r);
  return A.set(n.x * l, n.y * l, n.z * l, c), A;
}
function lC(t) {
  const A = t.clone().normalize(), e = 2 * (A.w * A.x + A.y * A.z), g = 1 - 2 * (A.x * A.x + A.y * A.y), I = Math.atan2(e, g), s = 2 * (A.w * A.y - A.z * A.x), Q = Math.abs(s) >= 1 ? Math.sign(s) * (Math.PI / 2) : Math.asin(s), B = 2 * (A.w * A.z + A.x * A.y), i = 1 - 2 * (A.y * A.y + A.z * A.z), C = Math.atan2(B, i), E = (I + Math.PI) / (2 * Math.PI), n = (Q + Math.PI) / (2 * Math.PI), o = (C + Math.PI) / (2 * Math.PI), r = Math.round(E * 255), l = Math.round(n * 255);
  return Math.round(o * 255) << 16 | l << 8 | r;
}
function uC(t, A) {
  const e = t & 255, g = t >>> 8 & 255, I = t >>> 16 & 255, s = e / 255, Q = g / 255, B = I / 255, i = s * (2 * Math.PI) - Math.PI, C = Q * (2 * Math.PI) - Math.PI, E = B * (2 * Math.PI) - Math.PI, n = Math.cos(i * 0.5), o = Math.sin(i * 0.5), r = Math.cos(C * 0.5), l = Math.sin(C * 0.5), c = Math.cos(E * 0.5), h = Math.sin(E * 0.5);
  return A.w = n * r * c + o * l * h, A.x = o * r * c - n * l * h, A.y = n * l * c + o * r * h, A.z = n * r * h - o * l * c, A.normalize(), A;
}
function Pt(t, A, e, g) {
  const I = Math.max(-127, Math.min(127, t * 127)), s = Math.max(-127, Math.min(127, A * 127)), Q = Math.max(-127, Math.min(127, e * 127)), B = Math.max(-127, Math.min(127, g * 127));
  return I & 255 | (s & 255) << 8 | (Q & 255) << 16 | (B & 255) << 24;
}
function wC(t, A, e) {
  const g = A * 2;
  for (let I = 0; I < 9; ++I) {
    const s = Math.max(-63, Math.min(63, e[I] * 63)) & 127, Q = I * 7, B = Q + 7, i = Math.floor(Q / 32), C = Q - i * 32, E = s << C & 4294967295;
    if (t[g + i] |= E, B > i * 32 + 32) {
      const n = s >>> 32 - C & 4294967295;
      t[g + i + 1] |= n;
    }
  }
}
function yC(t, A, e) {
  t[A * 4 + 0] = Pt(
    e[0],
    e[1],
    e[2],
    e[3]
  ), t[A * 4 + 1] = Pt(
    e[4],
    e[5],
    e[6],
    e[7]
  ), t[A * 4 + 2] = Pt(
    e[8],
    e[9],
    e[10],
    e[11]
  ), t[A * 4 + 3] = Pt(
    e[12],
    e[13],
    e[14],
    0
  );
}
function DC(t, A, e) {
  const g = A * 4;
  for (let I = 0; I < 21; ++I) {
    const s = Math.max(-31, Math.min(31, e[I] * 31)) & 63, Q = I * 6, B = Q + 6, i = Math.floor(Q / 32), C = Q - i * 32, E = s << C & 4294967295;
    if (t[g + i] |= E, B > i * 32 + 32) {
      const n = s >>> 32 - C & 4294967295;
      t[g + i + 1] |= n;
    }
  }
}
function TI(t, A) {
  const e = [];
  let g = 0, I = null;
  const s = new Mg((i, C) => {
    if (e.push(i), g += i.length, C || g >= A) {
      const E = new Uint8Array(g);
      let n = 0;
      for (const o of e)
        E.set(o, n), n += o.length;
      I = E.slice(0, A);
    }
  }), Q = 1024;
  let B = 0;
  for (; I == null && B < t.length; ) {
    const i = t.slice(B, B + Q);
    s.push(i, !1), B += Q;
  }
  if (I == null && (s.push(new Uint8Array(), !0), I == null))
    throw new Error("Failed to decompress partial gzip");
  return I;
}
class KI {
  constructor({
    fileBytes: A,
    chunkBytes: e = 64 * 1024
  }) {
    this.fileBytes = A, this.chunkBytes = e, this.offset = 0, this.chunks = [], this.totalBytes = 0, this.gunzip = new Mg((g, I) => {
      this.chunks.push(g), this.totalBytes += g.length;
    });
  }
  read(A) {
    for (; this.totalBytes < A && this.offset < this.fileBytes.length; ) {
      const s = Math.min(
        this.offset + this.chunkBytes,
        this.fileBytes.length
      );
      this.gunzip.push(this.fileBytes.subarray(this.offset, s), !1), this.offset = s;
    }
    if (this.totalBytes < A && this.offset >= this.fileBytes.length && this.gunzip.push(new Uint8Array(0), !0), this.totalBytes < A)
      throw new Error(
        `Unexpected EOF: needed ${A}, got ${this.totalBytes}`
      );
    const e = new Uint8Array(this.totalBytes);
    let g = 0;
    for (const s of this.chunks)
      e.set(s, g), g += s.length;
    const I = e.subarray(0, A);
    return this.chunks = [e.subarray(A)], this.totalBytes -= A, I;
  }
}
const wr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DataCache: zn,
  FreeList: RI,
  GunzipReader: KI,
  IDENT_VERTEX_SHADER: LI,
  Sint8ToFloat: qn,
  Uint8ToFloat: Kn,
  averagePositions: YI,
  averageQuaternions: JI,
  cloneClock: UI,
  coinciDist: vI,
  computeMaxSplats: sC,
  coorientDist: bI,
  decodeQuatEulerXyz888: uC,
  decodeQuatOctXy88R8: HI,
  decodeQuatXyz888: hC,
  decompressPartialGzip: TI,
  encodeQuatEulerXyz888: lC,
  encodeQuatOctXy88R8: _e,
  encodeQuatXyz888: cC,
  encodeSh1Rgb: wC,
  encodeSh2Rgb: yC,
  encodeSh3Rgb: DC,
  epsilonSign: rC,
  flipPixels: nC,
  floatBitsToUint: Hn,
  floatToSint8: ge,
  floatToUint8: GA,
  fromHalf: dA,
  getArrayBuffers: kI,
  getTextureSize: fA,
  isAndroid: BC,
  isMobile: QC,
  isOculus: iC,
  mapFilterObject: Zn,
  mapObject: Vn,
  newArray: jn,
  omitUndefined: EC,
  pixelsToPngUrl: CC,
  setPackedSplat: Le,
  setPackedSplatCenter: Xn,
  setPackedSplatOpacity: $n,
  setPackedSplatQuat: _n,
  setPackedSplatRgb: Pn,
  setPackedSplatRgba: On,
  setPackedSplatScales: Wn,
  toHalf: rt,
  uintBitsToFloat: Tn,
  unpackSplat: Ye,
  withinCoinciDist: oC,
  withinCoorientDist: ie,
  withinDist: aC
}, Symbol.toStringTag, { value: "Module" }));
class Oe {
  constructor({
    graph: A,
    inputs: e,
    outputs: g,
    template: I
  }) {
    this.graph = A, this.template = I, this.inputs = e ?? {}, this.outputs = g ?? {};
    const s = new Yg({ indent: this.template.indent });
    for (const B in this.outputs)
      this.outputs[B] && s.declares.add(this.outputs[B]);
    const Q = A.compile({
      inputs: this.inputs,
      outputs: this.outputs,
      compile: s
    });
    this.shader = I.generate({ globals: s.globals, statements: Q }), this.uniforms = s.uniforms, this.updaters = s.updaters;
  }
  prepareMaterial() {
    return dC(this);
  }
  update() {
    for (const A of this.updaters)
      A();
  }
}
class Pe {
  constructor(A) {
    const e = A.match(/^([ \t]*)\{\{\s*GLOBALS\s*\}\}/m), g = A.match(/^([ \t]*)\{\{\s*STATEMENTS\s*\}\}/m);
    if (!e || !g)
      throw new Error(
        "Template must contain {{ GLOBALS }} and {{ STATEMENTS }}"
      );
    this.before = A.substring(0, e.index), this.between = A.substring(
      e.index + e[0].length,
      g.index
    ), this.after = A.substring(
      g.index + g[0].length
    ), this.indent = g[1];
  }
  generate({
    globals: A,
    statements: e
  }) {
    return this.before + Array.from(A).join(`

`) + this.between + e.map((g) => this.indent + g).join(`
`) + this.after;
  }
}
const ng = /* @__PURE__ */ new Map();
function dC(t) {
  let A = ng.get(t);
  return A || (A = new a.RawShaderMaterial({
    glslVersion: a.GLSL3,
    vertexShader: LI,
    fragmentShader: t.shader,
    uniforms: t.uniforms
  }), ng.set(t, A), A);
}
function $e(t, A, e = "add") {
  const g = () => {
    throw new Error(`Invalid ${e} types: ${t}, ${A}`);
  };
  if (t === A) return t;
  if (t === "int") {
    if (cA(A)) return A;
    g();
  }
  if (A === "int") {
    if (cA(t)) return t;
    g();
  }
  if (t === "uint") {
    if (hA(A)) return A;
    g();
  }
  if (A === "uint") {
    if (hA(t)) return t;
    g();
  }
  if (t === "float") {
    if (Bt(A)) return A;
    g();
  }
  if (A === "float") {
    if (Bt(t)) return t;
    g();
  }
  throw new Error(`Invalid ${e} types: ${t}, ${A}`);
}
function pC(t, A) {
  return $e(t, A, "sub");
}
function fC(t, A) {
  const e = () => {
    throw new Error(`Invalid mul types: ${t}, ${A}`);
  }, g = (I) => I;
  if (t === "int") {
    if (cA(A)) return g(A);
    e();
  }
  if (A === "int") {
    if (cA(t)) return g(t);
    e();
  }
  if (t === "uint") {
    if (hA(A)) return g(A);
    e();
  }
  if (A === "uint") {
    if (hA(t)) return g(t);
    e();
  }
  if (t === "float") {
    if (Bt(A)) return g(A);
    e();
  }
  if (A === "float") {
    if (Bt(t)) return g(t);
    e();
  }
  if (cA(t) || hA(t) || cA(A) || hA(A)) {
    if (t === A) return g(t);
    e();
  }
  if (t === "vec2") {
    if (A === "vec2" || it(A)) return g("vec2");
    if (A === "mat3x2") return g("vec3");
    if (A === "mat4x2") return g("vec4");
    e();
  }
  if (t === "vec3") {
    if (A === "mat2x3") return g("vec2");
    if (A === "vec3" || nt(A)) return g("vec3");
    if (A === "mat4x3") return g("vec4");
    e();
  }
  if (t === "vec4") {
    if (A === "mat2x4") return g("vec2");
    if (A === "mat3x4") return g("vec3");
    if (A === "vec4" || Ct(A)) return g("vec4");
    e();
  }
  if (A === "vec2") {
    if (it(t)) return g("vec2");
    if (t === "mat2x3") return g("vec3");
    if (t === "mat2x4") return g("vec4");
    e();
  }
  if (A === "vec3") {
    if (t === "mat3x2") return g("vec2");
    if (nt(t)) return g("vec3");
    if (t === "mat3x4") return g("vec4");
    e();
  }
  if (A === "vec4") {
    if (t === "mat4x2") return g("vec2");
    if (t === "mat4x3") return g("vec3");
    if (Ct(t)) return g("vec4");
    e();
  }
  if (it(t)) {
    if (it(A)) return g("mat2");
    if (A === "mat3x2") return g("mat3x2");
    if (A === "mat4x2") return g("mat4x2");
    e();
  }
  if (t === "mat2x3") {
    if (it(A)) return g("mat2x3");
    if (A === "mat3x2") return g("mat3");
    if (A === "mat4x2") return g("mat4x3");
    e();
  }
  if (t === "mat2x4") {
    if (it(A)) return g("mat2x4");
    if (A === "mat3x2") return g("mat3x4");
    if (A === "mat4x2") return g("mat4");
    e();
  }
  if (t === "mat3x2") {
    if (A === "mat2x3") return g("mat2");
    if (nt(A)) return g("mat3x2");
    if (A === "mat4x3") return g("mat4x2");
    e();
  }
  if (nt(t)) {
    if (A === "mat2x3") return g("mat2x3");
    if (nt(A)) return g("mat3");
    if (A === "mat4x3") return g("mat4x3");
    e();
  }
  if (t === "mat3x4") {
    if (A === "mat2x3") return g("mat2x4");
    if (nt(A)) return g("mat3x4");
    if (A === "mat4x3") return g("mat4");
    e();
  }
  if (t === "mat4x2") {
    if (A === "mat2x4") return g("mat2");
    if (A === "mat3x4") return g("mat3x2");
    if (Ct(A)) return g("mat4x2");
    e();
  }
  if (t === "mat4x3") {
    if (A === "mat2x4") return g("mat2x3");
    if (A === "mat3x4") return g("mat3");
    if (Ct(A)) return g("mat4x3");
    e();
  }
  if (Ct(t)) {
    if (A === "mat2x4") return g("mat2x4");
    if (A === "mat3x4") return g("mat3x4");
    if (Ct(A)) return g("mat4");
    e();
  }
  throw new Error(`Invalid mul types: ${t}, ${A}`);
}
function NC(t, A) {
  return $e(t, A, "div");
}
function MC(t, A) {
  if (t === A) return t;
  if (t === "int") {
    if (cA(A)) return A;
  } else if (A === "int") {
    if (cA(t)) return t;
  } else if (t === "uint") {
    if (hA(A)) return A;
  } else if (A === "uint" && hA(t))
    return t;
  throw new Error(`Invalid imod types: ${t}, ${A}`);
}
function mC(t, A) {
  if (t === A || A === "float") return t;
  throw new Error(`Invalid mod types: ${t}, ${A}`);
}
function SC(t) {
  return t;
}
function FC(t) {
  return t;
}
function GC(t) {
  return t;
}
function xC(t) {
  return t;
}
function kC(t) {
  return t;
}
function RC(t) {
  return t;
}
function UC(t) {
  return t;
}
function LC(t) {
  return t;
}
function YC(t) {
  return t;
}
function JC(t) {
  return t;
}
function vC(t) {
  return t;
}
function bC(t) {
  return t;
}
function HC(t) {
  return t;
}
function TC(t) {
  return t;
}
function KC(t) {
  return t;
}
function qC(t) {
  return t;
}
function qI(t, A, e = "min") {
  if (t === A) return t;
  if (A === "float") {
    if (Vt(t)) return t;
  } else if (A === "int") {
    if (cA(t)) return t;
  } else if (A === "uint" && hA(t))
    return t;
  throw new Error(`Invalid ${e} types: ${t}, ${A}`);
}
function zC(t, A) {
  return qI(t, A, "max");
}
function VC(t, A, e) {
  if (A === "float") {
    if (Vt(t)) return t;
  } else if (A === "int") {
    if (cA(t)) return t;
  } else if (A === "uint" && hA(t))
    return t;
  throw new Error(`Invalid clamp types: ${t}, ${A}`);
}
function ZC(t, A, e) {
  if (e === t || e === "float" || e === "bool" && t === "float" || e === "bvec2" && t === "vec2" || e === "bvec3" && t === "vec3" || e === "bvec4" && t === "vec4") return t;
  throw new Error(`Invalid mix types: ${t}, ${A}, ${e}`);
}
function jC(t, A) {
  if (t === A || A === "float") return A;
  throw new Error(`Invalid step types: ${t}, ${A}`);
}
function XC(t, A, e) {
  if (t === A && (t === e || t === "float"))
    return e;
  throw new Error(`Invalid smoothstep types: ${t}, ${A}, ${e}`);
}
function zI(t, A = "isNan") {
  if (t === "float") return "bool";
  if (t === "vec2") return "bvec2";
  if (t === "vec3") return "bvec3";
  if (t === "vec4") return "bvec4";
  throw new Error(`Invalid ${A} types: ${t}`);
}
function WC(t) {
  return zI(t, "isInf");
}
const pA = (t, A) => new XI({ a: t, b: A }), Gt = (t, A) => new WI({ a: t, b: A }), EA = (t, A) => new _I({ a: t, b: A }), Ie = (t, A) => new OI({ a: t, b: A }), Je = (t, A) => new PI({ a: t, b: A }), VI = (t, A) => new $I({ a: t, b: A }), _C = (t) => new As({ a: t }).outputs, Ag = (t) => new ts({ a: t }), OC = (t) => new es({ a: t }), PC = (t) => new gs({ a: t }), $C = (t) => new Is({ a: t }), AE = (t) => new ss({ a: t }), tE = (t) => new Qs({ a: t }), eE = (t) => new Bs({ a: t }), se = (t) => new is({ a: t }), gE = (t, A) => new ns({ a: t, b: A }), IE = (t) => new Cs({ a: t }), sE = (t) => new Es({ a: t }), QE = (t) => new as({ a: t }), BE = (t) => new os({ a: t }), iE = (t) => new rs({ a: t }), nE = (t) => new cs({ a: t }), CE = (t) => new hs({ a: t }), EE = (t, A) => new ls({ a: t, b: A }), ZI = (t, A) => new us({ a: t, b: A }), aE = (t, A, e) => new ws({ a: t, min: A, max: e }), jI = (t, A, e) => new ys({ a: t, b: A, t: e }), oE = (t, A) => new Ds({ edge: t, x: A }), rE = (t, A, e) => new ds({ edge0: t, edge1: A, x: e }), cE = (t) => new ps({ a: t }), hE = (t) => new fs({ a: t });
class XI extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "sum", outTypeFunc: $e }), this.statements = ({ inputs: g, outputs: I }) => [`${I.sum} = ${g.a} + ${g.b};`];
  }
}
class WI extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "difference", outTypeFunc: pC }), this.statements = ({ inputs: g, outputs: I }) => [`${I.difference} = ${g.a} - ${g.b};`];
  }
}
class _I extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "product", outTypeFunc: fC }), this.statements = ({ inputs: g, outputs: I }) => [`${I.product} = ${g.a} * ${g.b};`];
  }
}
class OI extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "quotient", outTypeFunc: NC }), this.statements = ({ inputs: g, outputs: I }) => [`${I.quotient} = ${g.a} / ${g.b};`];
  }
}
class PI extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "remainder", outTypeFunc: MC }), this.statements = ({ inputs: g, outputs: I }) => [`${I.remainder} = ${g.a} % ${g.b};`];
  }
}
class $I extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "remainder", outTypeFunc: mC }), this.statements = ({ inputs: g, outputs: I }) => [`${I.remainder} = mod(${g.a}, ${g.b});`];
  }
}
class As extends Z {
  constructor({ a: A }) {
    const e = { a: V(A) }, g = e.a, I = {
      fract: g,
      integer: g
    };
    super({ inTypes: e, outTypes: I, inputs: { a: A } }), this.statements = ({ inputs: s, outputs: Q }) => [`${Q.fract} = modf(${s.a}, ${Q.integer});`];
  }
}
class ts extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "neg", outTypeFunc: SC }), this.statements = ({ inputs: e, outputs: g }) => [`${g.neg} = -${e.a};`];
  }
}
class es extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "abs", outTypeFunc: FC }), this.statements = ({ inputs: e, outputs: g }) => [`${g.abs} = abs(${e.a});`];
  }
}
class gs extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "sign", outTypeFunc: GC }), this.statements = ({ inputs: e, outputs: g }) => [`${g.sign} = sign(${e.a});`];
  }
}
class Is extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "floor", outTypeFunc: xC }), this.statements = ({ inputs: e, outputs: g }) => [`${g.floor} = floor(${e.a});`];
  }
}
class ss extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "ceil", outTypeFunc: kC }), this.statements = ({ inputs: e, outputs: g }) => [`${g.ceil} = ceil(${e.a});`];
  }
}
class Qs extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "trunc", outTypeFunc: RC }), this.statements = ({ inputs: e, outputs: g }) => [`${g.trunc} = trunc(${e.a});`];
  }
}
class Bs extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "round", outTypeFunc: UC }), this.statements = ({ inputs: e, outputs: g }) => [`${g.round} = round(${e.a});`];
  }
}
class is extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "fract", outTypeFunc: LC }), this.statements = ({ inputs: e, outputs: g }) => [`${g.fract} = fract(${e.a});`];
  }
}
class ns extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "power", outTypeFunc: YC }), this.statements = ({ inputs: g, outputs: I }) => [`${I.power} = pow(${g.a}, ${g.b});`];
  }
}
class Cs extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "exp", outTypeFunc: JC }), this.statements = ({ inputs: e, outputs: g }) => [`${g.exp} = exp(${e.a});`];
  }
}
class Es extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "exp2", outTypeFunc: vC }), this.statements = ({ inputs: e, outputs: g }) => [`${g.exp2} = exp2(${e.a});`];
  }
}
class as extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "log", outTypeFunc: bC }), this.statements = ({ inputs: e, outputs: g }) => [`${g.log} = log(${e.a});`];
  }
}
class os extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "log2", outTypeFunc: HC }), this.statements = ({ inputs: e, outputs: g }) => [`${g.log2} = log2(${e.a});`];
  }
}
class rs extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "sqr", outTypeFunc: TC }), this.statements = ({ inputs: e, outputs: g }) => [`${g.sqr} = ${e.a} * ${e.a};`];
  }
}
class cs extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "sqrt", outTypeFunc: KC }), this.statements = ({ inputs: e, outputs: g }) => [`${g.sqrt} = sqrt(${e.a});`];
  }
}
class hs extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "inversesqrt", outTypeFunc: qC }), this.statements = ({ inputs: e, outputs: g }) => [`${g.inversesqrt} = inversesqrt(${e.a});`];
  }
}
class ls extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "min", outTypeFunc: qI }), this.statements = ({ inputs: g, outputs: I }) => [`${I.min} = min(${g.a}, ${g.b});`];
  }
}
class us extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "max", outTypeFunc: zC }), this.statements = ({ inputs: g, outputs: I }) => [`${I.max} = max(${g.a}, ${g.b});`];
  }
}
class ws extends ut {
  constructor({
    a: A,
    min: e,
    max: g
  }) {
    super({
      a: A,
      b: e,
      c: g,
      outKey: "clamp",
      outTypeFunc: VC
    }), this.statements = ({ inputs: I, outputs: s }) => {
      const { a: Q, b: B, c: i } = I;
      return [`${s.clamp} = clamp(${Q}, ${B}, ${i});`];
    };
  }
}
class ys extends ut {
  constructor({ a: A, b: e, t: g }) {
    super({ a: A, b: e, c: g, outKey: "mix", outTypeFunc: ZC }), this.statements = ({ inputs: I, outputs: s }) => {
      const { a: Q, b: B, c: i } = I;
      return [`${s.mix} = mix(${Q}, ${B}, ${i});`];
    };
  }
}
class Ds extends $ {
  constructor({ edge: A, x: e }) {
    super({
      a: A,
      b: e,
      outKey: "step",
      outTypeFunc: jC
    }), this.statements = ({ inputs: g, outputs: I }) => {
      const { a: s, b: Q } = g;
      return [`${I.step} = step(${s}, ${Q});`];
    };
  }
}
class ds extends ut {
  constructor({
    edge0: A,
    edge1: e,
    x: g
  }) {
    super({
      a: A,
      b: e,
      c: g,
      outKey: "smoothstep",
      outTypeFunc: XC
    }), this.statements = ({ inputs: I, outputs: s }) => {
      const { a: Q, b: B, c: i } = I;
      return [`${s.smoothstep} = smoothstep(${Q}, ${B}, ${i});`];
    };
  }
}
class ps extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "isNan", outTypeFunc: zI }), this.statements = ({ inputs: e, outputs: g }) => [`${g.isNan} = isNan(${e.a});`];
  }
}
class fs extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "isInf", outTypeFunc: WC }), this.statements = ({ inputs: e, outputs: g }) => [`${g.isInf} = isInf(${e.a});`];
  }
}
const lE = (t, A) => new Ms({ a: t, b: A }), uE = (t, A) => new ms({ a: t, b: A }), wE = (t, A) => new Ss({ a: t, b: A }), yE = (t) => new Fs({ a: t }), DE = (t, A) => new Gs({ a: t, b: A }), dE = (t, A) => new xs({ a: t, b: A }), pE = (t, A) => new ks({ a: t, b: A }), Ns = (t, A) => new Rs({ a: t, b: A }), fE = (t, A) => new Us({ a: t, b: A }), NE = (t, A) => new Ls({ a: t, b: A }), ME = (t) => new Ys({ a: t }), mE = (t) => new Js({ a: t }), tg = (t, A, e) => new vs({ cond: t, t: A, f: e }), SE = (t) => new Hs({ a: t });
class Ms extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outTypeFunc: (g, I) => g, outKey: "and" }), this.statements = ({ inputs: g, outputs: I }) => this.outTypes.and === "bool" ? [`${I.and} = ${g.a} && ${g.b};`] : [`${I.and} = ${g.a} & ${g.b};`];
  }
}
class ms extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outTypeFunc: (g, I) => g, outKey: "or" }), this.statements = ({ inputs: g, outputs: I }) => this.outTypes.or === "bool" ? [`${I.or} = ${g.a} || ${g.b};`] : [`${I.or} = ${g.a} | ${g.b};`];
  }
}
class Ss extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outTypeFunc: (g, I) => g, outKey: "xor" }), this.statements = ({ inputs: g, outputs: I }) => this.outTypes.xor === "bool" ? [`${I.xor} = ${g.a} ^^ ${g.b};`] : [`${I.xor} = ${g.a} ^ ${g.b};`];
  }
}
class Fs extends F {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "not" }), this.statements = ({ inputs: e, outputs: g }) => this.outTypes.not === "bool" ? [`${g.not} = !${e.a};`] : [`${g.not} = not(${e.a});`];
  }
}
class Gs extends $ {
  constructor({ a: A, b: e }) {
    super({
      a: A,
      b: e,
      outTypeFunc: (g, I) => ue(g, "lessThan"),
      outKey: "lessThan"
    }), this.statements = ({ inputs: g, outputs: I }) => this.outTypes.lessThan === "bool" ? [`${I.lessThan} = ${g.a} < ${g.b};`] : [`${I.lessThan} = lessThan(${g.a}, ${g.b});`];
  }
}
class xs extends $ {
  constructor({ a: A, b: e }) {
    super({
      a: A,
      b: e,
      outTypeFunc: (g, I) => ue(g, "lessThanEqual"),
      outKey: "lessThanEqual"
    }), this.statements = ({ inputs: g, outputs: I }) => this.outTypes.lessThanEqual === "bool" ? [`${I.lessThanEqual} = ${g.a} <= ${g.b};`] : [
      `${I.lessThanEqual} = lessThanEqual(${g.a}, ${g.b});`
    ];
  }
}
class ks extends $ {
  constructor({ a: A, b: e }) {
    super({
      a: A,
      b: e,
      outTypeFunc: (g, I) => ue(g, "greaterThan"),
      outKey: "greaterThan"
    }), this.statements = ({ inputs: g, outputs: I }) => this.outTypes.greaterThan === "bool" ? [`${I.greaterThan} = ${g.a} > ${g.b};`] : [
      `${I.greaterThan} = greaterThan(${g.a}, ${g.b});`
    ];
  }
}
class Rs extends $ {
  constructor({ a: A, b: e }) {
    super({
      a: A,
      b: e,
      outTypeFunc: (g, I) => ue(g, "greaterThanEqual"),
      outKey: "greaterThanEqual"
    }), this.statements = ({ inputs: g, outputs: I }) => this.outTypes.greaterThanEqual === "bool" ? [`${I.greaterThanEqual} = ${g.a} >= ${g.b};`] : [
      `${I.greaterThanEqual} = greaterThanEqual(${g.a}, ${g.b});`
    ];
  }
}
class Us extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outTypeFunc: bs, outKey: "equal" }), this.statements = ({ inputs: g, outputs: I }) => this.outTypes.equal === "bool" ? [`${I.equal} = ${g.a} == ${g.b};`] : [`${I.equal} = equal(${g.a}, ${g.b});`];
  }
}
class Ls extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outTypeFunc: FE, outKey: "notEqual" }), this.statements = ({ inputs: g, outputs: I }) => this.outTypes.notEqual === "bool" ? [`${I.notEqual} = ${g.a} != ${g.b};`] : [`${I.notEqual} = notEqual(${g.a}, ${g.b});`];
  }
}
class Ys extends F {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (e) => "bool", outKey: "any" }), this.statements = ({ inputs: e, outputs: g }) => [`${g.any} = any(${e.a});`];
  }
}
class Js extends F {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (e) => "bool", outKey: "all" }), this.statements = ({ inputs: e, outputs: g }) => [`${g.all} = all(${e.a});`];
  }
}
class vs extends ut {
  constructor({
    cond: A,
    t: e,
    f: g
  }) {
    super({
      a: A,
      b: e,
      c: g,
      outKey: "select",
      outTypeFunc: (I, s, Q) => s
    }), this.statements = ({ inputs: I, outputs: s }) => {
      const { a: Q, b: B, c: i } = I;
      return [`${s.select} = (${Q}) ? (${B}) : (${i});`];
    };
  }
}
function ue(t, A) {
  if (lt(t))
    return "bool";
  if (t === "ivec2" || t === "uvec2" || t === "vec2")
    return "bvec2";
  if (t === "ivec3" || t === "uvec3" || t === "vec3")
    return "bvec3";
  if (t === "ivec4" || t === "uvec4" || t === "vec4")
    return "bvec4";
  throw new Error(`Invalid ${A} type: ${t}`);
}
function bs(t, A = "equal") {
  if (lt(t))
    return "bool";
  if (ht(t))
    return t;
  if (t === "ivec2" || t === "uvec2" || t === "vec2")
    return "bvec2";
  if (t === "ivec3" || t === "uvec3" || t === "vec3")
    return "bvec3";
  if (t === "ivec4" || t === "uvec4" || t === "vec4")
    return "bvec4";
  throw new Error(`Invalid ${A} type: ${t}`);
}
function FE(t) {
  return bs(t, "notEqual");
}
function GE(t) {
  if (ht(t))
    return "bool";
  if (cA(t))
    return "int";
  if (hA(t))
    return "uint";
  throw new Error(`Invalid compXor type: ${t}`);
}
class Hs extends F {
  constructor({ a: A }) {
    const e = GE(V(A));
    super({ a: A, outTypeFunc: (g) => e, outKey: "compXor" }), this.statements = ({ inputs: g, outputs: I }) => {
      if (lt(this.outTypes.compXor))
        return [`${I.compXor} = ${g.a};`];
      const Q = (xt(e) ? ["x", "y"] : kt(e) ? ["x", "y", "z"] : ["x", "y", "z", "w"]).map((i) => `${g.a}.${i}`), B = ht(e) ? "^^" : "^";
      return [`${I.compXor} = ${Q.join(` ${B} `)};`];
    };
  }
}
const xE = (t) => new js({ value: t }), kE = (t) => new Xs({ value: t }), RE = (t) => new Ws({ value: t }), Ts = (t) => new _s({ value: t }), UE = (t) => new Os({ value: t }), LE = (t) => new Ps({ value: t }), YE = (t) => new $s({ value: t }), JE = (t) => new AQ({ value: t }), vE = (t) => new tQ({ value: t }), bE = (t) => new eQ({ value: t }), HE = (t) => new gQ({ value: t }), TE = (t) => new IQ({ value: t }), KE = (t) => new sQ({ value: t }), Ks = (t) => new QQ({ value: t }), ct = (t) => new BQ({ value: t }), qs = (t) => new iQ({ value: t }), qE = (t) => new nQ({ value: t }), zE = (t) => new CQ({ value: t }), VE = (t) => new EQ({ value: t }), zs = (t) => new aQ({ value: t }), Vs = (t) => new oQ({ value: t }), ZE = (t) => new rQ({ value: t }), jE = (t) => new cQ({ value: t }), XE = (t) => new hQ({ value: t }), WE = (t) => new lQ({ value: t }), _E = (t) => new uQ({ value: t }), OE = (t) => new wQ({ value: t }), Zs = (t) => new yQ({ value: t }), PE = (t) => new DQ({ value: t }), ve = (t) => new dQ({ value: t });
class iA extends F {
  constructor({
    value: A,
    outType: e,
    outKey: g
  }) {
    super({ a: A, outTypeFunc: () => e, outKey: g }), this.statements = ({ inputs: I, outputs: s }) => [
      `${s[g]} = ${Ug(e)}(${I.a});`
    ];
  }
}
class js extends iA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bool", outKey: "bool" });
  }
}
class Xs extends iA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "int", outKey: "int" });
  }
}
class Ws extends iA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uint", outKey: "uint" });
  }
}
class _s extends iA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "float", outKey: "float" });
  }
}
class Os extends iA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bvec2", outKey: "bvec2" });
  }
}
class Ps extends iA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bvec3", outKey: "bvec3" });
  }
}
class $s extends iA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bvec4", outKey: "bvec4" });
  }
}
class AQ extends iA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "ivec2", outKey: "ivec2" });
  }
}
class tQ extends iA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "ivec3", outKey: "ivec3" });
  }
}
class eQ extends iA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "ivec4", outKey: "ivec4" });
  }
}
class gQ extends iA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uvec2", outKey: "uvec2" });
  }
}
class IQ extends iA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uvec3", outKey: "uvec3" });
  }
}
class sQ extends iA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uvec4", outKey: "uvec4" });
  }
}
class QQ extends iA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "vec2", outKey: "vec2" });
  }
}
class BQ extends iA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "vec3", outKey: "vec3" });
  }
}
class iQ extends iA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "vec4", outKey: "vec4" });
  }
}
class nQ extends iA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "mat2", outKey: "mat2" });
  }
}
class CQ extends iA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "mat3", outKey: "mat3" });
  }
}
class EQ extends iA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "mat4", outKey: "mat4" });
  }
}
class aQ extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "int", outTypeFunc: () => "int" }), this.statements = ({ inputs: e, outputs: g }) => [`${g.int} = floatBitsToInt(${e.a});`];
  }
}
class oQ extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: e, outputs: g }) => [`${g.uint} = floatBitsToUint(${e.a});`];
  }
}
class rQ extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "float", outTypeFunc: () => "float" }), this.statements = ({ inputs: e, outputs: g }) => [`${g.float} = intBitsToFloat(${e.a});`];
  }
}
class cQ extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "float", outTypeFunc: () => "float" }), this.statements = ({ inputs: e, outputs: g }) => [`${g.float} = uintBitsToFloat(${e.a});`];
  }
}
class hQ extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: e, outputs: g }) => [`${g.uint} = packSnorm2x16(${e.a});`];
  }
}
class lQ extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "vec2", outTypeFunc: () => "vec2" }), this.statements = ({ inputs: e, outputs: g }) => [`${g.vec2} = unpackSnorm2x16(${e.a});`];
  }
}
class uQ extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: e, outputs: g }) => [`${g.uint} = packUnorm2x16(${e.a});`];
  }
}
class wQ extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "vec2", outTypeFunc: () => "vec2" }), this.statements = ({ inputs: e, outputs: g }) => [`${g.vec2} = unpackUnorm2x16(${e.a});`];
  }
}
class yQ extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: e, outputs: g }) => [`${g.uint} = packHalf2x16(${e.a});`];
  }
}
class DQ extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "vec2", outTypeFunc: () => "vec2" }), this.statements = ({ inputs: e, outputs: g }) => [`${g.vec2} = unpackHalf2x16(${e.a});`];
  }
}
class dQ extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "rgba8", outTypeFunc: () => "vec4" }), this.statements = ({ inputs: e, outputs: g }) => [
      `uvec4 uRgba = uvec4(${e.a} & 0xffu, (${e.a} >> 8u) & 0xffu, (${e.a} >> 16u) & 0xffu, (${e.a} >> 24u) & 0xffu);`,
      `${g.rgba8} = vec4(uRgba) / 255.0;`
    ];
  }
}
const $E = (t) => new MQ({ a: t }), Aa = (t, A) => new mQ({ a: t, b: A }), pQ = (t, A) => new SQ({ a: t, b: A }), ta = (t, A) => new FQ({ a: t, b: A }), fQ = (t) => new GQ({ a: t }), ea = (t, A, e) => new RQ({ a: t, b: A, c: e }), ga = (t, A) => new UQ({ incident: t, normal: A }), Ia = (t, A, e) => new LQ({ incident: t, normal: A, eta: e }), St = (t) => new TQ({ vector: t }), KA = ({
  vector: t,
  vectorType: A,
  x: e,
  y: g,
  z: I,
  w: s,
  r: Q,
  g: B,
  b: i,
  a: C
}) => new KQ({ vector: t, vectorType: A, x: e, y: g, z: I, w: s, r: Q, g: B, b: i, a: C }), sa = (t) => new xQ({ a: t }), NQ = (t, A) => new kQ({ a: t, b: A }), Qa = (t, A) => new qQ({ vector: t, select: A }), Ba = (t, A) => new YQ({ a: t, b: A }), ia = (t, A) => new JQ({ a: t, b: A }), na = (t) => new vQ({ a: t }), Ca = (t) => new bQ({ a: t }), Ea = (t) => new HQ({ a: t });
class MQ extends F {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (e) => "float", outKey: "length" }), this.statements = ({ inputs: e, outputs: g }) => [
      `${g.length} = length(${e.a});`
    ];
  }
}
class mQ extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "distance", outTypeFunc: (g, I) => "float" }), this.statements = ({ inputs: g, outputs: I }) => [
      `${I.distance} = distance(${g.a}, ${g.b});`
    ];
  }
}
class SQ extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "dot", outTypeFunc: (g, I) => "float" }), this.statements = ({ inputs: g, outputs: I }) => [
      `${I.dot} = dot(${g.a}, ${g.b});`
    ];
  }
}
class FQ extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "cross", outTypeFunc: (g, I) => "vec3" }), this.statements = ({ inputs: g, outputs: I }) => [
      `${I.cross} = cross(${g.a}, ${g.b});`
    ];
  }
}
class GQ extends F {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "normalize" }), this.statements = ({ inputs: e, outputs: g }) => [
      `${g.normalize} = normalize(${e.a});`
    ];
  }
}
function aa(t) {
  if (t === "vec3")
    return "vec2";
  if (t === "vec4")
    return "vec3";
  throw new Error("Invalid type");
}
class xQ extends F {
  constructor({ a: A }) {
    super({
      a: A,
      outTypeFunc: (e) => aa(e),
      outKey: "projected"
    }), this.statements = ({ inputs: e, outputs: g }) => {
      if (this.inTypes.a === "vec3")
        return [`${g.projected} = ${e.a}.xy / ${e.a}.z;`];
      if (this.inTypes.a === "vec4")
        return [`${g.projected} = ${e.a}.xyz / ${e.a}.w;`];
      throw new Error("Invalid type");
    };
  }
}
function oa(t) {
  if (t === "float") return "vec2";
  if (t === "vec2") return "vec3";
  if (t === "vec3") return "vec4";
  throw new Error("Invalid type");
}
class kQ extends $ {
  constructor({ a: A, b: e }) {
    const g = V(A), I = oa(g);
    super({ a: A, b: e, outKey: "extend", outTypeFunc: () => I }), this.statements = ({ inputs: s, outputs: Q }) => [
      `${Q.extend} = ${I}(${s.a}, ${s.b});`
    ];
  }
}
class RQ extends ut {
  constructor({ a: A, b: e, c: g }) {
    super({
      a: A,
      b: e,
      c: g,
      outKey: "forward",
      outTypeFunc: (I, s, Q) => I
    }), this.statements = ({ inputs: I, outputs: s }) => [
      `${s.forward} = faceforward(${I.a}, ${I.b}, ${I.c});`
    ];
  }
}
class UQ extends $ {
  constructor({
    incident: A,
    normal: e
  }) {
    super({
      a: A,
      b: e,
      outKey: "reflection",
      outTypeFunc: (g, I) => g
    }), this.statements = ({ inputs: g, outputs: I }) => [
      `${I.reflection} = reflect(${g.a}, ${g.b});`
    ];
  }
}
class LQ extends ut {
  constructor({
    incident: A,
    normal: e,
    eta: g
  }) {
    super({
      a: A,
      b: e,
      c: g,
      outKey: "refraction",
      outTypeFunc: (I, s, Q) => I
    }), this.statements = ({ inputs: I, outputs: s }) => [
      `${s.refraction} = refract(${I.a}, ${I.b}, ${I.c});`
    ];
  }
}
class YQ extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "product", outTypeFunc: (g, I) => g }), this.statements = ({ inputs: g, outputs: I }) => [
      `${I.product} = matrixCompMult(${A}, ${e});`
    ];
  }
}
function ra(t, A) {
  if (t === "vec2") {
    if (A === "vec2") return "mat2";
    if (A === "vec3") return "mat3x2";
    if (A === "vec4") return "mat4x2";
  }
  if (t === "vec3") {
    if (A === "vec2") return "mat2x3";
    if (A === "vec3") return "mat3";
    if (A === "vec4") return "mat4x3";
  }
  if (t === "vec4") {
    if (A === "vec2") return "mat2x4";
    if (A === "vec3") return "mat3x4";
    if (A === "vec4") return "mat4";
  }
  throw new Error(`Invalid outer type: ${t}, ${A}`);
}
class JQ extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "outer", outTypeFunc: ra }), this.statements = ({ inputs: g, outputs: I }) => [
      `${I.outer} = outerProduct(${g.a}, ${g.b});`
    ];
  }
}
function ca(t) {
  if (t === "mat2") return "mat2";
  if (t === "mat3") return "mat3";
  if (t === "mat4") return "mat4";
  if (t === "mat2x2") return "mat2x2";
  if (t === "mat2x3") return "mat3x2";
  if (t === "mat2x4") return "mat4x2";
  if (t === "mat3x2") return "mat2x3";
  if (t === "mat3x3") return "mat3x3";
  if (t === "mat3x4") return "mat4x3";
  if (t === "mat4x2") return "mat2x4";
  if (t === "mat4x3") return "mat3x4";
  if (t === "mat4x4") return "mat4x4";
  throw new Error(`Invalid transpose type: ${t}`);
}
class vQ extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "transpose", outTypeFunc: ca }), this.statements = ({ inputs: e, outputs: g }) => [
      `${g.transpose} = transpose(${e.a});`
    ];
  }
}
class bQ extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "det", outTypeFunc: (e) => "float" }), this.statements = ({ inputs: e, outputs: g }) => [
      `${g.det} = determinant(${e.a});`
    ];
  }
}
class HQ extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "inverse", outTypeFunc: (e) => e }), this.statements = ({ inputs: e, outputs: g }) => [
      `${g.inverse} = inverse(${A});`
    ];
  }
}
function ha(t) {
  const A = (e) => e;
  switch (t) {
    case "vec2":
      return A({ x: "float", y: "float", r: "float", g: "float" });
    case "vec3":
      return A({
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      });
    case "vec4":
      return A({
        x: "float",
        y: "float",
        z: "float",
        w: "float",
        r: "float",
        g: "float",
        b: "float",
        a: "float"
      });
    case "ivec2":
      return A({ x: "int", y: "int", r: "int", g: "int" });
    case "ivec3":
      return A({
        x: "int",
        y: "int",
        z: "int",
        r: "int",
        g: "int",
        b: "int"
      });
    case "ivec4":
      return A({
        x: "int",
        y: "int",
        z: "int",
        w: "int",
        r: "int",
        g: "int",
        b: "int",
        a: "int"
      });
    case "uvec2":
      return A({ x: "uint", y: "uint", r: "uint", g: "uint" });
    case "uvec3":
      return A({
        x: "uint",
        y: "uint",
        z: "uint",
        r: "uint",
        g: "uint",
        b: "uint"
      });
    case "uvec4":
      return A({
        x: "uint",
        y: "uint",
        z: "uint",
        w: "uint",
        r: "uint",
        g: "uint",
        b: "uint",
        a: "uint"
      });
    default:
      throw new Error(`Invalid vector type: ${t}`);
  }
}
class TQ extends Z {
  constructor({ vector: A }) {
    const g = { vector: V(A) }, I = ha(g.vector);
    super({ inTypes: g, outTypes: I, inputs: { vector: A } }), this.statements = ({ inputs: s, outputs: Q }) => {
      const { x: B, y: i, z: C, w: E, r: n, g: o, b: r, a: l } = Q, { vector: c } = s;
      return [
        B ? `${B} = ${c}.x;` : null,
        i ? `${i} = ${c}.y;` : null,
        C ? `${C} = ${c}.z;` : null,
        E ? `${E} = ${c}.w;` : null,
        n ? `${n} = ${c}.r;` : null,
        o ? `${o} = ${c}.g;` : null,
        r ? `${r} = ${c}.b;` : null,
        l ? `${l} = ${c}.a;` : null
      ].filter(Boolean);
    };
  }
}
class KQ extends Z {
  constructor({
    vector: A,
    vectorType: e,
    x: g,
    y: I,
    z: s,
    w: Q,
    r: B,
    g: i,
    b: C,
    a: E
  }) {
    if (!A && !e)
      throw new Error("Either vector or vectorType must be provided");
    const n = e ?? V(A), o = xg(n), r = kg(n), l = {
      vector: n,
      x: o,
      y: o,
      r: o,
      g: o
    }, c = { vector: A, x: g, y: I, r: B, g: i };
    r >= 3 && (Object.assign(l, { z: o, b: o }), Object.assign(c, { z: s, b: C })), r >= 4 && (Object.assign(l, { w: o, a: o }), Object.assign(c, { w: Q, a: E })), super({ inTypes: l, outTypes: { vector: n }, inputs: c }), this.statements = ({ inputs: h, outputs: u }) => {
      const { vector: y } = u, {
        vector: w,
        x: d,
        y: p,
        z: m,
        w: N,
        r: f,
        g: D,
        b: R,
        a: S
      } = h, M = [
        `${y}.x = ${d ?? f ?? (w ? `${w}.x` : Jt(o))};`,
        `${y}.y = ${p ?? D ?? (w ? `${w}.y` : Jt(o))};`
      ];
      return r >= 3 && M.push(
        `${y}.z = ${m ?? R ?? (w ? `${w}.z` : Jt(o))};`
      ), r >= 4 && M.push(
        `${y}.w = ${N ?? S ?? (w ? `${w}.w` : Jt(o))};`
      ), M;
    };
  }
  dynoOut() {
    return new q(
      this,
      "vector"
    );
  }
}
function la(t, A) {
  let e = null;
  if (Vt(t) ? e = A.length === 1 ? "float" : A.length === 2 ? "vec2" : A.length === 3 ? "vec3" : A.length === 4 ? "vec4" : null : cA(t) ? e = A.length === 1 ? "int" : A.length === 2 ? "ivec2" : A.length === 3 ? "ivec3" : A.length === 4 ? "ivec4" : null : hA(t) && (e = A.length === 1 ? "uint" : A.length === 2 ? "uvec2" : A.length === 3 ? "uvec3" : A.length === 4 ? "uvec4" : null), e == null)
    throw new Error(`Invalid swizzle: ${A}`);
  return e;
}
class qQ extends F {
  constructor({ vector: A, select: e }) {
    super({
      a: A,
      outKey: "swizzle",
      outTypeFunc: (g) => la(g, e)
    }), this.statements = ({ inputs: g, outputs: I }) => [
      `${I.swizzle} = ${g.a}.${e};`
    ];
  }
}
const ua = (t, A, e) => new _Q({ index: t, from: A, to: e }), wa = (t) => new Rt({ value: t }), ya = (t) => new kA({ state: t }), Da = (t) => new RA({ state: t }), zQ = (t) => new OQ({ value: t }), VQ = (t) => new PQ({ value: t }), ZQ = (t) => new $Q({ value: t }), jQ = (t) => new AB({ value: t }), da = (t) => new tB({ value: t }), pa = (t) => new eB({ value: t }), XQ = (t) => new gB({ value: t }), be = (t) => new IB({ value: t }), WQ = (t, A, e) => new sB({ z: t, zNear: A, zFar: e }).outputs.depth;
class _Q extends Z {
  constructor({
    from: A,
    to: e,
    index: g
  }) {
    super({
      inTypes: { from: "int", to: "int", index: "int" },
      outTypes: { index: "int" },
      inputs: { from: A, to: e, index: g },
      statements: ({ inputs: I, outputs: s }) => [
        `${s.index} = ${I.index} - ${I.from} + ${I.to};`
      ]
    });
  }
  dynoOut() {
    return new q(this, "index");
  }
}
class kA extends Z {
  constructor({ state: A }) {
    const e = V(A);
    super({
      inTypes: { state: e },
      outTypes: { state: "uint" },
      inputs: { state: A },
      globals: () => [
        oA(`
          uint pcg_next(uint state) {
            return state * 747796405u + 2891336453u;
          }
        `)
      ],
      statements: ({ inputs: g, outputs: I }) => {
        const s = e === "uint" ? `${g.state}` : e === "int" ? `uint(${g.state})` : `floatBitsToUint(${g.state})`;
        return [`${I.state} = pcg_next(${s});`];
      }
    });
  }
  dynoOut() {
    return new q(this, "state");
  }
}
class RA extends Z {
  constructor({ state: A }) {
    super({
      inTypes: { state: "uint" },
      outTypes: { hash: "uint" },
      inputs: { state: A },
      globals: () => [
        oA(`
          uint pcg_hash(uint state) {
            uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
            return (hash >> 22u) ^ hash;
          }
        `)
      ],
      statements: ({ inputs: e, outputs: g }) => [
        `${g.hash} = pcg_hash(${e.state});`
      ]
    });
  }
  dynoOut() {
    return new q(this, "hash");
  }
}
class Rt extends Z {
  constructor({ value: A }) {
    const e = V(A), g = Rg(e);
    super({
      inTypes: { value: e },
      outTypes: { state: "uint" },
      inputs: { value: A },
      globals: () => [
        oA(`
          uint pcg_mix(uint value) {
            return value;
          }
          uint pcg_mix(uvec2 value) {
            return value.x + 0x9e3779b9u * value.y;
          }
          uint pcg_mix(uvec3 value) {
            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z;
          }
          uint pcg_mix(uvec4 value) {
            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z + 0xc2b2ae35u * value.w;
          }
        `)
      ],
      statements: ({ inputs: I, outputs: s }) => {
        const Q = hA(e) ? `${I.value}` : cA(e) ? `${g}(${I.value})` : `floatBitsToUint(${I.value})`;
        return [
          `${g} bits = ${Q};`,
          `${s.state} = pcg_mix(bits);`
        ];
      }
    });
  }
  dynoOut() {
    return new q(this, "state");
  }
}
class OQ extends zA {
  constructor({ value: A }) {
    super({
      inTypes: { value: V(A) },
      outTypes: { hash: "uint" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        let g = new Rt({ value: e }).outputs.state;
        return g = new kA({ state: g }).outputs.state, new RA({ state: g }).outputs;
      }
    });
  }
  dynoOut() {
    return new q(this, "hash");
  }
}
class PQ extends zA {
  constructor({ value: A }) {
    super({
      inTypes: { value: V(A) },
      outTypes: { hash: "uvec2" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        let g = new Rt({ value: e }).outputs.state;
        g = new kA({ state: g }).outputs.state;
        const I = new RA({ state: g }).outputs.hash;
        g = new kA({ state: g }).outputs.state;
        const s = new RA({ state: g }).outputs.hash;
        return { hash: KA({ vectorType: "uvec2", x: I, y: s }) };
      }
    });
  }
  dynoOut() {
    return new q(this, "hash");
  }
}
class $Q extends zA {
  constructor({ value: A }) {
    super({
      inTypes: { value: V(A) },
      outTypes: { hash: "uvec3" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        let g = new Rt({ value: e }).outputs.state;
        g = new kA({ state: g }).outputs.state;
        const I = new RA({ state: g }).outputs.hash;
        g = new kA({ state: g }).outputs.state;
        const s = new RA({ state: g }).outputs.hash;
        g = new kA({ state: g }).outputs.state;
        const Q = new RA({ state: g }).outputs.hash;
        return { hash: KA({ vectorType: "uvec3", x: I, y: s, z: Q }) };
      }
    });
  }
  dynoOut() {
    return new q(this, "hash");
  }
}
class AB extends zA {
  constructor({ value: A }) {
    super({
      inTypes: { value: V(A) },
      outTypes: { hash: "uvec4" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        let g = new Rt({ value: e }).outputs.state;
        g = new kA({ state: g }).outputs.state;
        const I = new RA({ state: g }).outputs.hash;
        g = new kA({ state: g }).outputs.state;
        const s = new RA({ state: g }).outputs.hash;
        g = new kA({ state: g }).outputs.state;
        const Q = new RA({ state: g }).outputs.hash;
        g = new kA({ state: g }).outputs.state;
        const B = new RA({ state: g }).outputs.hash;
        return { hash: KA({ vectorType: "uvec4", x: I, y: s, z: Q, w: B }) };
      }
    });
  }
  dynoOut() {
    return new q(this, "hash");
  }
}
class tB extends zA {
  constructor({ value: A }) {
    super({
      inTypes: { value: V(A) },
      outTypes: { hash: "float" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        const g = zQ(e);
        return { hash: EA(Ts(g), K("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new q(this, "hash");
  }
}
class eB extends zA {
  constructor({ value: A }) {
    super({
      inTypes: { value: V(A) },
      outTypes: { hash: "vec2" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        const g = VQ(e);
        return { hash: EA(Ks(g), K("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new q(this, "hash");
  }
}
class gB extends zA {
  constructor({ value: A }) {
    super({
      inTypes: { value: V(A) },
      outTypes: { hash: "vec3" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        const g = ZQ(e);
        return { hash: EA(ct(g), K("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new q(this, "hash");
  }
}
class IB extends zA {
  constructor({ value: A }) {
    super({
      inTypes: { value: V(A) },
      outTypes: { hash: "vec4" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        const g = jQ(e);
        return { hash: EA(qs(g), K("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new q(this, "hash");
  }
}
class sB extends Z {
  constructor({
    z: A,
    zNear: e,
    zFar: g
  }) {
    super({
      inTypes: { z: "float", zNear: "float", zFar: "float" },
      outTypes: { depth: "float" },
      inputs: { z: A, zNear: e, zFar: g },
      statements: ({ inputs: I, outputs: s }) => [
        `float clamped = clamp(${I.z}, ${I.zNear}, ${I.zFar});`,
        `${s.depth} = (log2(clamped + 1.0) - log2(${I.zNear} + 1.0)) / (log2(${I.zFar} + 1.0) - log2(${I.zNear} + 1.0));`
      ]
    });
  }
  dynoOut() {
    return new q(this, "depth");
  }
}
const QB = (t, {
  scale: A,
  scales: e,
  rotate: g,
  translate: I
}) => new iB({ position: t, scale: A, scales: e, rotate: g, translate: I }).outputs.position, BB = (t, {
  scale: A,
  scales: e,
  rotate: g
}) => new nB({ dir: t, scale: A, scales: e, rotate: g }).outputs.dir, fa = (t, { rotate: A }) => new CB({ quaternion: t, rotate: A }).outputs.quaternion;
class iB extends Z {
  constructor({
    position: A,
    scale: e,
    scales: g,
    rotate: I,
    translate: s
  }) {
    super({
      inTypes: {
        position: "vec3",
        scale: "float",
        scales: "vec3",
        rotate: "vec4",
        translate: "vec3"
      },
      outTypes: { position: "vec3" },
      inputs: { position: A, scale: e, scales: g, rotate: I, translate: s },
      statements: ({ inputs: Q, outputs: B }) => {
        const { position: i } = B;
        if (!i)
          return [];
        const { scale: C, scales: E, rotate: n, translate: o } = Q;
        return [
          `${i} = ${Q.position ?? "vec3(0.0, 0.0, 0.0)"};`,
          C ? `${i} *= ${C};` : null,
          E ? `${i} *= ${E};` : null,
          n ? `${i} = quatVec(${n}, ${i});` : null,
          o ? `${i} += ${o};` : null
        ].filter(Boolean);
      }
    });
  }
}
class nB extends Z {
  constructor({
    dir: A,
    scale: e,
    scales: g,
    rotate: I
  }) {
    super({
      inTypes: { dir: "vec3", scale: "float", scales: "vec3", rotate: "vec4" },
      outTypes: { dir: "vec3" },
      inputs: { dir: A, scale: e, scales: g, rotate: I },
      statements: ({ inputs: s, outputs: Q }) => {
        const { dir: B } = Q;
        if (!B)
          return [];
        const { scale: i, scales: C, rotate: E } = s;
        return [
          `${B} = ${s.dir ?? "vec3(0.0, 0.0, 0.0)"};`,
          i ? `${B} *= ${i};` : null,
          C ? `${B} *= ${C};` : null,
          E ? `${B} = quatVec(${E}, ${B});` : null
        ].filter(Boolean);
      }
    });
  }
}
class CB extends Z {
  constructor({
    quaternion: A,
    rotate: e
  }) {
    super({
      inTypes: { quaternion: "vec4", rotate: "vec4" },
      outTypes: { quaternion: "vec4" },
      inputs: { quaternion: A, rotate: e },
      statements: ({ inputs: g, outputs: I }) => {
        const { quaternion: s } = I;
        return s ? [
          `${s} = ${g.quaternion ?? "vec4(0.0, 0.0, 0.0, 1.0)"};`,
          e ? `${s} = quatQuat(${g.rotate}, ${s});` : null
        ].filter(Boolean) : [];
      }
    });
  }
}
const Na = () => {
  throw new Error("Not implemented");
}, Ma = () => {
  throw new Error("Not implemented");
}, ma = () => {
  throw new Error("Not implemented");
}, Sa = () => {
  throw new Error("Not implemented");
}, Fa = () => {
  throw new Error("Not implemented");
}, Ga = () => {
  throw new Error("Not implemented");
}, xa = (t, A) => new EB({ texture: t, lod: A }), ka = (t, A, e) => new aB({ texture: t, coord: A, bias: e }), Ra = (t, A, e) => new oB({ texture: t, coord: A, lod: e });
class EB extends Z {
  constructor({ texture: A, lod: e }) {
    const g = V(A);
    super({
      inTypes: { texture: g, lod: "int" },
      outTypes: { size: rB(g) },
      inputs: { texture: A, lod: e },
      statements: ({ inputs: I, outputs: s }) => [
        `${s.size} = textureSize(${I.texture}, ${I.lod ?? "0"});`
      ]
    });
  }
  dynoOut() {
    return new q(this, "size");
  }
}
class aB extends Z {
  constructor({
    texture: A,
    coord: e,
    bias: g
  }) {
    const I = V(A);
    super({
      inTypes: {
        texture: I,
        coord: Ua(I),
        bias: "float"
      },
      outTypes: { sample: cB(I) },
      inputs: { texture: A, coord: e, bias: g },
      statements: ({ inputs: s, outputs: Q }) => [
        `${Q.sample} = texture(${s.texture}, ${s.coord}${s.bias ? `, ${s.bias}` : ""});`
      ]
    });
  }
  dynoOut() {
    return new q(this, "sample");
  }
}
class oB extends Z {
  constructor({
    texture: A,
    coord: e,
    lod: g
  }) {
    const I = V(A);
    super({
      inTypes: {
        texture: I,
        coord: rB(I),
        lod: "int"
      },
      outTypes: { texel: cB(I) },
      inputs: { texture: A, coord: e, lod: g },
      statements: ({ inputs: s, outputs: Q }) => [
        `${Q.texel} = texelFetch(${s.texture}, ${s.coord}, ${s.lod ?? "0"});`
      ]
    });
  }
  dynoOut() {
    return new q(this, "texel");
  }
}
function rB(t) {
  switch (t) {
    case "sampler2D":
    case "usampler2D":
    case "isampler2D":
    case "samplerCube":
    case "usamplerCube":
    case "isamplerCube":
    case "sampler2DShadow":
    case "samplerCubeShadow":
      return "ivec2";
    case "sampler3D":
    case "usampler3D":
    case "isampler3D":
    case "sampler2DArray":
    case "usampler2DArray":
    case "isampler2DArray":
    case "sampler2DArrayShadow":
      return "ivec3";
    default:
      throw new Error(`Invalid texture type: ${t}`);
  }
}
function Ua(t) {
  switch (t) {
    case "sampler2D":
    case "usampler2D":
    case "isampler2D":
      return "vec2";
    case "sampler3D":
    case "usampler3D":
    case "isampler3D":
    case "samplerCube":
    case "usamplerCube":
    case "isamplerCube":
    case "sampler2DArray":
    case "usampler2DArray":
    case "isampler2DArray":
    case "sampler2DShadow":
      return "vec3";
    case "samplerCubeShadow":
    case "sampler2DArrayShadow":
      return "vec4";
    default:
      throw new Error(`Invalid texture type: ${t}`);
  }
}
function cB(t) {
  switch (t) {
    case "sampler2D":
    case "sampler2DArray":
    case "sampler3D":
    case "samplerCube":
    case "sampler2DShadow":
      return "vec4";
    case "usampler2D":
    case "usampler2DArray":
    case "usampler3D":
    case "usamplerCube":
      return "uvec4";
    case "isampler2D":
    case "isampler2DArray":
    case "isampler3D":
    case "isamplerCube":
      return "ivec4";
    case "samplerCubeShadow":
    case "sampler2DArrayShadow":
      return "float";
    default:
      throw new Error(`Invalid texture type: ${t}`);
  }
}
const La = (t) => new hB({ degrees: t }), Ya = (t) => new lB({ radians: t }), He = (t) => new uB({ radians: t }), Ja = (t) => new wB({ radians: t }), va = (t) => new yB({ radians: t }), ba = (t) => new DB({ sin: t }), Ha = (t) => new dB({ cos: t }), Ta = (t) => new pB({ tan: t }), Ka = (t, A) => new fB({ y: t, x: A }), qa = (t) => new NB({ x: t }), za = (t) => new MB({ x: t }), Va = (t) => new mB({ x: t }), Za = (t) => new SB({ x: t }), ja = (t) => new FB({ x: t }), Xa = (t) => new GB({ x: t });
class hB extends F {
  constructor({ degrees: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "radians" }), this.statements = ({ inputs: e, outputs: g }) => [
      `${g.radians} = radians(${e.a});`
    ];
  }
}
class lB extends F {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "degrees" }), this.statements = ({ inputs: e, outputs: g }) => [
      `${g.degrees} = degrees(${e.a});`
    ];
  }
}
class uB extends F {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "sin" }), this.statements = ({ inputs: e, outputs: g }) => [
      `${g.sin} = sin(${e.a});`
    ];
  }
}
class wB extends F {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "cos" }), this.statements = ({ inputs: e, outputs: g }) => [
      `${g.cos} = cos(${e.a});`
    ];
  }
}
class yB extends F {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "tan" }), this.statements = ({ inputs: e, outputs: g }) => [
      `${g.tan} = tan(${e.a});`
    ];
  }
}
class DB extends F {
  constructor({ sin: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "asin" }), this.statements = ({ inputs: e, outputs: g }) => [
      `${g.asin} = asin(${e.a});`
    ];
  }
}
class dB extends F {
  constructor({ cos: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "acos" }), this.statements = ({ inputs: e, outputs: g }) => [
      `${g.acos} = acos(${e.a});`
    ];
  }
}
class pB extends F {
  constructor({ tan: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "atan" }), this.statements = ({ inputs: e, outputs: g }) => [
      `${g.atan} = atan(${e.a});`
    ];
  }
}
class fB extends $ {
  constructor({ y: A, x: e }) {
    super({
      a: A,
      b: e,
      outTypeFunc: (g, I) => g,
      outKey: "atan2"
    }), this.statements = ({ inputs: g, outputs: I }) => [
      `${I.atan2} = atan2(${g.a}, ${g.b});`
    ];
  }
}
class NB extends F {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "sinh" }), this.statements = ({ inputs: e, outputs: g }) => [
      `${g.sinh} = sinh(${e.a});`
    ];
  }
}
class MB extends F {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "cosh" }), this.statements = ({ inputs: e, outputs: g }) => [
      `${g.cosh} = cosh(${e.a});`
    ];
  }
}
class mB extends F {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "tanh" }), this.statements = ({ inputs: e, outputs: g }) => [
      `${g.tanh} = tanh(${e.a});`
    ];
  }
}
class SB extends F {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "asinh" }), this.statements = ({ inputs: e, outputs: g }) => [
      `${g.asinh} = asinh(${e.a});`
    ];
  }
}
class FB extends F {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "acosh" }), this.statements = ({ inputs: e, outputs: g }) => [
      `${g.acosh} = acosh(${e.a});`
    ];
  }
}
class GB extends F {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "atanh" }), this.statements = ({ inputs: e, outputs: g }) => [
      `${g.atanh} = atanh(${e.a});`
    ];
  }
}
const yr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Abs: es,
  Acos: dB,
  Acosh: FB,
  Add: XI,
  All: Js,
  And: Ms,
  Any: Ys,
  Asin: DB,
  Asinh: SB,
  Atan: pB,
  Atan2: fB,
  Atanh: GB,
  BVec2: Os,
  BVec3: Ps,
  BVec4: $s,
  BinaryOp: $,
  Bool: js,
  Ceil: ss,
  Clamp: ws,
  Combine: KQ,
  CombineGsplat: qg,
  CompMult: YQ,
  CompXor: Hs,
  Compilation: Yg,
  Cos: wB,
  Cosh: MB,
  Cross: FQ,
  Degrees: lB,
  Determinant: bQ,
  Distance: mQ,
  Div: OI,
  Dot: SQ,
  Dyno: Z,
  DynoBlock: zA,
  DynoBool: Be,
  DynoBvec2: _g,
  DynoBvec3: AI,
  DynoBvec4: gI,
  DynoConst: Lg,
  DynoFloat: ot,
  DynoInt: Kt,
  DynoIsampler2D: wI,
  DynoIsampler2DArray: DI,
  DynoIsampler3D: fI,
  DynoIsamplerCube: mI,
  DynoIvec2: Pg,
  DynoIvec3: eI,
  DynoIvec4: sI,
  DynoLiteral: Mt,
  DynoMat2: QI,
  DynoMat2x2: BI,
  DynoMat2x3: iI,
  DynoMat2x4: nI,
  DynoMat3: CI,
  DynoMat3x2: EI,
  DynoMat3x3: aI,
  DynoMat3x4: oI,
  DynoMat4: rI,
  DynoMat4x2: cI,
  DynoMat4x3: hI,
  DynoMat4x4: lI,
  DynoOutput: q,
  DynoProgram: Oe,
  DynoProgramTemplate: Pe,
  DynoRemapIndex: _Q,
  DynoSampler2D: yI,
  DynoSampler2DArray: dI,
  DynoSampler2DArrayShadow: GI,
  DynoSampler2DShadow: FI,
  DynoSampler3D: NI,
  DynoSamplerCube: SI,
  DynoSamplerCubeShadow: xI,
  DynoUint: Wg,
  DynoUniform: k,
  DynoUsampler2D: uI,
  DynoUsampler2DArray: Ht,
  DynoUsampler3D: pI,
  DynoUsamplerCube: MI,
  DynoUvec2: Og,
  DynoUvec3: tI,
  DynoUvec4: II,
  DynoValue: st,
  DynoVec2: $g,
  DynoVec3: Ft,
  DynoVec4: Wt,
  Equal: Us,
  Exp: Cs,
  Exp2: Es,
  ExtendVec: kQ,
  FaceForward: RQ,
  Float: _s,
  FloatBitsToInt: aQ,
  FloatBitsToUint: oQ,
  Floor: Is,
  Fract: is,
  GreaterThan: ks,
  GreaterThanEqual: Rs,
  Gsplat: P,
  GsplatNormal: Vg,
  Hash: OQ,
  Hash2: PQ,
  Hash3: $Q,
  Hash4: AB,
  HashFloat: tB,
  HashVec2: eB,
  HashVec3: gB,
  HashVec4: IB,
  IMod: PI,
  IVec2: AQ,
  IVec3: tQ,
  IVec4: eQ,
  Int: Xs,
  IntBitsToFloat: rQ,
  Inverse: HQ,
  InverseSqrt: hs,
  IsInf: fs,
  IsNan: ps,
  Length: MQ,
  LessThan: Gs,
  LessThanEqual: xs,
  Log: as,
  Log2: os,
  Mat2: nQ,
  Mat3: CQ,
  Mat4: EQ,
  Max: us,
  Min: ls,
  Mix: ys,
  Mod: $I,
  Modf: As,
  Mul: _I,
  Neg: ts,
  Normalize: GQ,
  NormalizedDepth: sB,
  Not: Fs,
  NotEqual: Ls,
  NumPackedSplats: vg,
  Or: ms,
  Outer: JQ,
  OutputPackedSplat: Xg,
  OutputRgba8: We,
  PackHalf2x16: yQ,
  PackSnorm2x16: hQ,
  PackUnorm2x16: uQ,
  PcgHash: RA,
  PcgMix: Rt,
  PcgNext: kA,
  Pow: ns,
  ProjectH: xQ,
  Radians: hB,
  ReadPackedSplat: Hg,
  ReadPackedSplatRange: Tg,
  ReflectVec: UQ,
  RefractVec: LQ,
  Round: Bs,
  Select: vs,
  Sign: gs,
  SimpleCast: iA,
  Sin: uB,
  Sinh: NB,
  Smoothstep: ds,
  Split: TQ,
  SplitGsplat: Kg,
  Sqr: rs,
  Sqrt: cs,
  Step: Ds,
  Sub: WI,
  Swizzle: qQ,
  TPackedSplats: Xt,
  Tan: yB,
  Tanh: mB,
  TexelFetch: oB,
  Texture: aB,
  TextureSize: EB,
  TransformDir: nB,
  TransformGsplat: Zg,
  TransformPosition: iB,
  TransformQuaternion: CB,
  Transpose: vQ,
  TrinaryOp: ut,
  Trunc: Qs,
  UVec2: gQ,
  UVec3: IQ,
  UVec4: sQ,
  Uint: Ws,
  UintBitsToFloat: cQ,
  UintToRgba8: dQ,
  UnaryOp: F,
  UnpackHalf2x16: DQ,
  UnpackSnorm2x16: lQ,
  UnpackUnorm2x16: wQ,
  Vec2: QQ,
  Vec3: BQ,
  Vec4: iQ,
  Xor: Ss,
  abs: OC,
  acos: Ha,
  acosh: ja,
  add: pA,
  all: mE,
  and: lE,
  any: ME,
  arrayIndex: Fa,
  arrayLength: Ga,
  asin: ba,
  asinh: Za,
  atan: Ta,
  atan2: Ka,
  atanh: Xa,
  bool: xE,
  bvec2: UE,
  bvec3: LE,
  bvec4: YE,
  ceil: AE,
  clamp: aE,
  combine: KA,
  combineGsplat: Qt,
  comment: Sa,
  compMult: Ba,
  compXor: SE,
  cos: Ja,
  cosh: za,
  cross: ta,
  defineGsplat: FA,
  defineGsplatNormal: zg,
  definePackedSplats: he,
  degrees: Ya,
  determinant: Ca,
  distance: Aa,
  div: Ie,
  dot: pQ,
  dyno: jt,
  dynoBlock: SA,
  dynoBool: Pi,
  dynoBvec2: tn,
  dynoBvec3: sn,
  dynoBvec4: nn,
  dynoConst: K,
  dynoDeclare: je,
  dynoFloat: bA,
  dynoFor: ma,
  dynoIf: Na,
  dynoInt: An,
  dynoIsampler2D: Mn,
  dynoIsampler2DArray: Fn,
  dynoIsampler3D: kn,
  dynoIsamplerCube: Ln,
  dynoIvec2: gn,
  dynoIvec3: Bn,
  dynoIvec4: En,
  dynoLiteral: Qe,
  dynoMat2: on,
  dynoMat2x2: rn,
  dynoMat2x3: cn,
  dynoMat2x4: hn,
  dynoMat3: ln,
  dynoMat3x2: un,
  dynoMat3x3: wn,
  dynoMat3x4: yn,
  dynoMat4: Dn,
  dynoMat4x2: dn,
  dynoMat4x3: pn,
  dynoMat4x4: fn,
  dynoSampler2D: mn,
  dynoSampler2DArray: Gn,
  dynoSampler2DArrayShadow: vn,
  dynoSampler2DShadow: Jn,
  dynoSampler3D: Rn,
  dynoSamplerCube: Yn,
  dynoSamplerCubeShadow: bn,
  dynoSwitch: Ma,
  dynoUint: $i,
  dynoUsampler2D: Nn,
  dynoUsampler2DArray: Sn,
  dynoUsampler3D: xn,
  dynoUsamplerCube: Un,
  dynoUvec2: en,
  dynoUvec3: Qn,
  dynoUvec4: Cn,
  dynoVec2: In,
  dynoVec3: At,
  dynoVec4: an,
  equal: fE,
  exp: IE,
  exp2: sE,
  extendVec: NQ,
  faceforward: ea,
  float: Ts,
  floatBitsToInt: zs,
  floatBitsToUint: Vs,
  floor: $C,
  fract: se,
  greaterThan: pE,
  greaterThanEqual: Ns,
  gsplatNormal: Ue,
  hash: zQ,
  hash2: VQ,
  hash3: ZQ,
  hash4: jQ,
  hashFloat: da,
  hashVec2: pa,
  hashVec3: XQ,
  hashVec4: be,
  imod: Je,
  int: kE,
  intBitsToFloat: ZE,
  inverse: Ea,
  inversesqrt: CE,
  isAllFloatType: Bt,
  isBoolType: ht,
  isFloatType: Vt,
  isInf: hE,
  isIntType: cA,
  isMat2: it,
  isMat3: nt,
  isMat4: Ct,
  isMatFloatType: Gg,
  isNan: cE,
  isScalarType: lt,
  isUintType: hA,
  isVector2Type: xt,
  isVector3Type: kt,
  isVector4Type: Zt,
  isVectorType: zi,
  ivec2: JE,
  ivec3: vE,
  ivec4: bE,
  length: $E,
  lessThan: DE,
  lessThanEqual: dE,
  literalNegOne: Xi,
  literalOne: ji,
  literalZero: Jt,
  log: QE,
  log2: BE,
  mat2: qE,
  mat3: zE,
  mat4: VE,
  max: ZI,
  min: EE,
  mix: jI,
  mod: VI,
  modf: _C,
  mul: EA,
  neg: Ag,
  normalize: fQ,
  normalizedDepth: WQ,
  not: yE,
  notEqual: NE,
  numPackedSplats: Wi,
  numberAsFloat: T,
  numberAsInt: sA,
  numberAsUint: QA,
  or: uE,
  outer: ia,
  outputPackedSplat: jg,
  outputRgba8: _i,
  packHalf2x16: Zs,
  packSnorm2x16: XE,
  packUnorm2x16: _E,
  pcgHash: Da,
  pcgMix: wa,
  pcgNext: ya,
  pow: gE,
  projectH: sa,
  radians: La,
  readPackedSplat: mt,
  readPackedSplatRange: Jg,
  reflectVec: ga,
  refractVec: Ia,
  remapIndex: ua,
  round: eE,
  sameSizeIvec: Zi,
  sameSizeUvec: Rg,
  sameSizeVec: Vi,
  select: tg,
  sign: PC,
  sin: He,
  sinh: qa,
  smoothstep: rE,
  split: St,
  splitGsplat: at,
  sqr: iE,
  sqrt: nE,
  step: oE,
  sub: Gt,
  swizzle: Qa,
  tan: va,
  tanh: Va,
  texelFetch: Ra,
  texture: ka,
  textureSize: xa,
  transformDir: BB,
  transformGsplat: Xe,
  transformPos: QB,
  transformQuat: fa,
  transpose: na,
  trunc: tE,
  typeLiteral: Ug,
  uint: RE,
  uintBitsToFloat: jE,
  uintToRgba8: ve,
  uniform: Oi,
  unindent: oA,
  unindentLines: UA,
  unpackHalf2x16: PE,
  unpackSnorm2x16: WE,
  unpackUnorm2x16: OE,
  uvec2: HE,
  uvec3: TE,
  uvec4: KE,
  valType: V,
  vec2: Ks,
  vec3: ct,
  vec4: qs,
  vectorDim: kg,
  vectorElementType: xg,
  xor: wE
}, Symbol.toStringTag, { value: "Module" }));
var Wa = `precision highp float;
precision highp int;
precision highp sampler2D;
precision highp usampler2D;
precision highp isampler2D;
precision highp sampler2DArray;
precision highp usampler2DArray;
precision highp isampler2DArray;
precision highp sampler3D;
precision highp usampler3D;
precision highp isampler3D;

#include <splatDefines>

uniform uint targetLayer;
uniform int targetBase;
uniform int targetCount;

out vec4 target;

{{ GLOBALS }}

void computeReadback(int index) {
    {{ STATEMENTS }}
}

void main() {
    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);
    int index = targetIndex - targetBase;

    if ((index >= 0) && (index < targetCount)) {
        computeReadback(index);
    } else {
        target = vec4(0.0, 0.0, 0.0, 0.0);
    }
}`;
const xA = class xA {
  constructor({ renderer: A } = {}) {
    this.renderer = A, this.capacity = 0, this.count = 0;
  }
  dispose() {
    this.target && (this.target.dispose(), this.target = void 0);
  }
  // Ensure we have a buffer large enough for the readback of count indices.
  // Pass in previous bufer of the desired type.
  ensureBuffer(A, e) {
    const I = Math.ceil(Math.max(1, A) / O) * O * 4;
    if (e.byteLength >= I)
      return e;
    const s = new ArrayBuffer(I);
    if (e instanceof ArrayBuffer)
      return s;
    const Q = e.constructor;
    return new Q(s);
  }
  // Ensure our render target is large enough for the readback of capacity indices.
  ensureCapacity(A) {
    const { width: e, height: g, depth: I, maxSplats: s } = fA(A);
    (!this.target || s > this.capacity) && (this.dispose(), this.capacity = s, this.target = new a.WebGLArrayRenderTarget(e, g, I, {
      depthBuffer: !1,
      stencilBuffer: !1,
      generateMipmaps: !1,
      magFilter: a.NearestFilter,
      minFilter: a.NearestFilter
    }), this.target.texture.format = a.RGBAFormat, this.target.texture.type = a.UnsignedByteType, this.target.texture.internalFormat = "RGBA8", this.target.scissorTest = !0);
  }
  // Get a program and THREE.RawShaderMaterial for a given Rgba8Readback,
  // generating it if necessary and caching the result.
  prepareProgramMaterial(A) {
    let e = xA.readbackProgram.get(A);
    if (!e) {
      const I = SA(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index: s }) => (A.inputs.index = s, { rgba8: new We({ rgba8: A.outputs.rgba8 }) })
      );
      xA.programTemplate || (xA.programTemplate = new Pe(Wa)), e = new Oe({
        graph: I,
        inputs: { index: "index" },
        outputs: { rgba8: "target" },
        template: xA.programTemplate
      }), Object.assign(e.uniforms, {
        targetLayer: { value: 0 },
        targetBase: { value: 0 },
        targetCount: { value: 0 }
      }), xA.readbackProgram.set(A, e);
    }
    const g = e.prepareMaterial();
    return xA.fullScreenQuad.material = g, { program: e, material: g };
  }
  saveRenderState(A) {
    return {
      xrEnabled: A.xr.enabled,
      autoClear: A.autoClear
    };
  }
  resetRenderState(A, e) {
    A.setRenderTarget(null), A.xr.enabled = e.xrEnabled, A.autoClear = e.autoClear;
  }
  process({
    count: A,
    material: e
  }) {
    const g = this.renderer;
    if (!g)
      throw new Error("No renderer");
    if (!this.target)
      throw new Error("No target");
    const I = O * It;
    e.uniforms.targetBase.value = 0, e.uniforms.targetCount.value = A;
    let s = 0;
    for (; s < A; ) {
      const Q = Math.floor(s / I), B = Q * I, i = Math.min(
        It,
        Math.ceil((A - B) / O)
      );
      e.uniforms.targetLayer.value = Q, this.target.scissor.set(0, 0, O, i), g.setRenderTarget(this.target, Q), g.xr.enabled = !1, g.autoClear = !1, xA.fullScreenQuad.render(g), s += O * i;
    }
    this.count = A;
  }
  async read({
    readback: A
  }) {
    const e = this.renderer;
    if (!e)
      throw new Error("No renderer");
    if (!this.target)
      throw new Error("No target");
    const g = Math.ceil(this.count / O) * O;
    if (A.byteLength < g * 4)
      throw new Error(
        `Readback buffer too small: ${A.byteLength} < ${g * 4}`
      );
    const I = new Uint8Array(
      A instanceof ArrayBuffer ? A : A.buffer
    ), s = O * It;
    let Q = 0;
    const B = [];
    for (; Q < this.count; ) {
      const i = Math.floor(Q / s), C = i * s, E = Math.min(
        It,
        Math.ceil((this.count - C) / O)
      );
      e.setRenderTarget(this.target, i);
      const n = O * E * 4, o = I.subarray(
        C * 4,
        C * 4 + n
      ), r = e == null ? void 0 : e.readRenderTargetPixelsAsync(
        this.target,
        0,
        0,
        O,
        E,
        o
      );
      B.push(r), Q += O * E;
    }
    return Promise.all(B).then(() => A);
  }
  // Perform render operation to run the Rgba8Readback program
  // but don't perform the readback yet.
  render({
    reader: A,
    count: e,
    renderer: g
  }) {
    if (this.renderer = g || this.renderer, !this.renderer)
      throw new Error("No renderer");
    this.ensureCapacity(e);
    const { program: I, material: s } = this.prepareProgramMaterial(A);
    I.update();
    const Q = this.saveRenderState(this.renderer);
    this.process({ count: e, material: s }), this.resetRenderState(this.renderer, Q);
  }
  // Perform a readback of the render target, returning a buffer of the
  // given type.
  async readback({
    readback: A
  }) {
    if (!this.renderer)
      throw new Error("No renderer");
    const e = this.saveRenderState(this.renderer), g = this.read({ readback: A });
    return this.resetRenderState(this.renderer, e), g;
  }
  // Perform a render and readback operation for the given Rgba8Readback,
  // and readback buffer (call ensureBuffer first).
  async renderReadback({
    reader: A,
    count: e,
    renderer: g,
    readback: I
  }) {
    if (this.renderer = g || this.renderer, !this.renderer)
      throw new Error("No renderer");
    this.ensureCapacity(e);
    const { program: s, material: Q } = this.prepareProgramMaterial(A);
    s.update();
    const B = this.saveRenderState(this.renderer);
    this.process({ count: e, material: Q });
    const i = this.read({ readback: I });
    return this.resetRenderState(this.renderer, B), i;
  }
  getTexture() {
    var A;
    return (A = this.target) == null ? void 0 : A.texture;
  }
};
xA.programTemplate = null, xA.readbackProgram = /* @__PURE__ */ new Map(), xA.fullScreenQuad = new lg(
  new a.RawShaderMaterial({ visible: !1 })
);
let ne = xA;
const CA = class CA {
  constructor(A = {}) {
    this.capacity = 0, this.count = 0, this.array = null, this.readback = null, this.source = null, this.needsUpdate = !0, this.dyno = new k({
      key: "rgbaArray",
      type: xB,
      globals: () => [kB],
      value: {
        texture: CA.getEmpty(),
        count: 0
      },
      update: (e) => {
        var g;
        return e.texture = ((g = this.readback) == null ? void 0 : g.getTexture()) ?? this.source ?? CA.getEmpty(), e.count = this.count, e;
      }
    }), A.array ? (this.array = A.array, this.capacity = Math.floor(this.array.length / 4), this.capacity = Math.floor(this.capacity / O) * O, this.count = Math.min(
      this.capacity,
      A.count ?? Number.POSITIVE_INFINITY
    )) : (this.capacity = A.capacity ?? 0, this.count = 0);
  }
  // Free up resources
  dispose() {
    this.readback && (this.readback.dispose(), this.readback = null), this.source && (this.source.dispose(), this.source = null);
  }
  // Ensure that our array is large enough to hold capacity RGBA8 values.
  ensureCapacity(A) {
    var e;
    if (!this.array || A > (((e = this.array) == null ? void 0 : e.length) ?? 0) / 4) {
      this.capacity = fA(A).maxSplats;
      const g = new Uint8Array(this.capacity * 4);
      this.array && g.set(this.array), this.array = g;
    }
    return this.array;
  }
  // Get the THREE.DataArrayTexture from either the readback or the source.
  getTexture() {
    var e;
    let A = (e = this.readback) == null ? void 0 : e.getTexture();
    return (this.source || this.array) && (A = this.maybeUpdateSource()), A ?? CA.getEmpty();
  }
  // Create or get a THREE.DataArrayTexture from the data array.
  maybeUpdateSource() {
    if (!this.array)
      throw new Error("No array");
    if (this.needsUpdate || !this.source) {
      if (this.needsUpdate = !1, this.source) {
        const { width: A, height: e, depth: g } = this.source.image;
        this.capacity !== A * e * g && (this.source.dispose(), this.source = null);
      }
      if (this.source)
        this.array.buffer !== this.source.image.data.buffer && (this.source.image.data = new Uint8Array(this.array.buffer));
      else {
        const { width: A, height: e, depth: g } = fA(this.capacity);
        this.source = new a.DataArrayTexture(
          this.array,
          A,
          e,
          g
        ), this.source.format = a.RGBAFormat, this.source.type = a.UnsignedByteType, this.source.internalFormat = "RGBA8", this.source.needsUpdate = !0;
      }
      this.source.needsUpdate = !0;
    }
    return this.source;
  }
  // Generate the RGBA8 values from a Rgba8Readback dyno program.
  render({
    reader: A,
    count: e,
    renderer: g
  }) {
    this.readback || (this.readback = new ne({ renderer: g })), this.readback.render({ reader: A, count: e, renderer: g }), this.capacity = this.readback.capacity, this.count = this.readback.count;
  }
  // Extract the RGBA8 values from a PackedSplats collection.
  fromPackedSplats({
    packedSplats: A,
    base: e,
    count: g,
    renderer: I
  }) {
    const { dynoSplats: s, dynoBase: Q, dynoCount: B, reader: i } = CA.makeDynos();
    return s.packedSplats = A, Q.value = e, B.value = g, this.render({ reader: i, count: g, renderer: I }), this;
  }
  // Read back the RGBA8 values from the readback buffer.
  async read() {
    if (!this.readback)
      throw new Error("No readback");
    return (!this.array || this.array.length < this.count * 4) && (this.array = new Uint8Array(this.capacity * 4)), (await this.readback.readback({ readback: this.array })).subarray(0, this.count * 4);
  }
  // Can be used where you need an uninitialized THREE.DataArrayTexture like
  // a uniform you will update with the result of this.getTexture() later.
  static getEmpty() {
    if (!CA.emptySource) {
      const A = new Uint8Array(4);
      CA.emptySource = new a.DataArrayTexture(A, 1, 1, 1), CA.emptySource.format = a.RGBAFormat, CA.emptySource.type = a.UnsignedByteType, CA.emptySource.internalFormat = "RGBA8", CA.emptySource.needsUpdate = !0;
    }
    return CA.emptySource;
  }
  // Create a dyno program that can extract RGBA8 values from a PackedSplats
  static makeDynos() {
    if (!CA.dynos) {
      const A = new gg(), e = new Kt({ value: 0 }), g = new Kt({ value: 0 }), I = SA(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index: s }) => {
          if (!s)
            throw new Error("index is undefined");
          s = pA(s, e);
          const Q = Jg(
            A,
            s,
            e,
            g
          );
          return { rgba8: at(Q).outputs.rgba };
        }
      );
      CA.dynos = { dynoSplats: A, dynoBase: e, dynoCount: g, reader: I };
    }
    return CA.dynos;
  }
};
CA.emptySource = null, CA.dynos = null;
let Te = CA;
const xB = { type: "RgbaArray" }, kB = oA(`
  struct RgbaArray {
    sampler2DArray texture;
    int count;
  };
`);
function _a(t, A) {
  return new Z({
    inTypes: { rgba: xB, index: "int" },
    outTypes: { rgba: "vec4" },
    inputs: { rgba: t, index: A },
    globals: () => [kB],
    statements: ({ inputs: g, outputs: I }) => UA(`
        if ((index >= 0) && (index < ${g.rgba}.count)) {
          ${I.rgba} = texelFetch(${g.rgba}.texture, splatTexCoord(index), 0);
        } else {
          ${I.rgba} = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `)
  }).outputs.rgba;
}
var Oa = /* @__PURE__ */ ((t) => (t.ALL = "all", t.PLANE = "plane", t.SPHERE = "sphere", t.BOX = "box", t.ELLIPSOID = "ellipsoid", t.CYLINDER = "cylinder", t.CAPSULE = "capsule", t.INFINITE_CONE = "infinite_cone", t))(Oa || {});
function Pa(t) {
  switch (t) {
    case "all":
      return 0;
    case "plane":
      return 1;
    case "sphere":
      return 2;
    case "box":
      return 3;
    case "ellipsoid":
      return 4;
    case "cylinder":
      return 5;
    case "capsule":
      return 6;
    case "infinite_cone":
      return 7;
    default:
      throw new Error(`Unknown SDF type: ${t}`);
  }
}
var $a = /* @__PURE__ */ ((t) => (t.MULTIPLY = "multiply", t.SET_RGB = "set_rgb", t.ADD_RGBA = "add_rgba", t))($a || {});
function Ao(t) {
  switch (t) {
    case "multiply":
      return 0;
    case "set_rgb":
      return 1;
    case "add_rgba":
      return 2;
    default:
      throw new Error(`Unknown blend mode: ${t}`);
  }
}
class to extends a.Object3D {
  constructor(A = {}) {
    super();
    const { type: e, invert: g, opacity: I, color: s, displace: Q, radius: B } = A;
    this.type = e ?? "sphere", this.invert = g ?? !1, this.opacity = I ?? 1, this.color = s ?? new a.Color(1, 1, 1), this.displace = Q ?? new a.Vector3(0, 0, 0), this.radius = B ?? 0;
  }
}
const ce = class ce extends a.Object3D {
  constructor(A = {}) {
    const {
      name: e,
      rgbaBlendMode: g = "multiply",
      sdfSmooth: I = 0,
      softEdge: s = 0,
      invert: Q = !1,
      sdfs: B = null
    } = A;
    super(), this.rgbaBlendMode = g, this.sdfSmooth = I, this.softEdge = s, this.invert = Q, this.sdfs = B, this.ordering = ce.nextOrdering++, this.name = e ?? `Edit ${this.ordering}`;
  }
  addSdf(A) {
    this.sdfs == null && (this.sdfs = []), this.sdfs.includes(A) || this.sdfs.push(A);
  }
  removeSdf(A) {
    this.sdfs != null && (this.sdfs = this.sdfs.filter((e) => e !== A));
  }
};
ce.nextOrdering = 1;
let Ce = ce;
class eo {
  constructor({ maxSdfs: A, maxEdits: e }) {
    this.maxSdfs = Math.max(16, A ?? 0), this.numSdfs = 0, this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4), this.sdfFloatData = new Float32Array(this.sdfData.buffer), this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs), this.dynoSdfArray = new k({
      key: "sdfArray",
      type: RB,
      globals: () => [UB],
      value: {
        numSdfs: 0,
        sdfTexture: this.sdfTexture
      },
      update: (g) => (g.numSdfs = this.numSdfs, g.sdfTexture = this.sdfTexture, g)
    }), this.maxEdits = Math.max(16, e ?? 0), this.numEdits = 0, this.editData = new Uint32Array(this.maxEdits * 4), this.editFloatData = new Float32Array(this.editData.buffer), this.dynoNumEdits = new Kt({ value: 0 }), this.dynoEdits = this.newEdits(this.editData, this.maxEdits);
  }
  newSdfTexture(A, e) {
    const g = new a.DataTexture(
      A,
      8,
      e,
      a.RGBAIntegerFormat,
      a.UnsignedIntType
    );
    return g.internalFormat = "RGBA32UI", g.needsUpdate = !0, g;
  }
  newEdits(A, e) {
    return new k({
      key: "edits",
      type: "uvec4",
      count: e,
      globals: () => [LB],
      value: A
    });
  }
  // Ensure our SDF texture and edits uniform array have enough capacity.
  // Reallocate if not.
  ensureCapacity({
    maxSdfs: A,
    maxEdits: e
  }) {
    let g = !1;
    return A > this.sdfTexture.image.height && (this.sdfTexture.dispose(), this.maxSdfs = Math.max(this.maxSdfs * 2, A), this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4), this.sdfFloatData = new Float32Array(this.sdfData.buffer), this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs)), e > (this.dynoEdits.count ?? 0) && (this.maxEdits = Math.max(this.maxEdits * 2, e), this.editData = new Uint32Array(this.maxEdits * 4), this.editFloatData = new Float32Array(this.editData.buffer), this.dynoEdits = this.newEdits(this.editData, this.maxEdits), g = !0), g;
  }
  updateEditData(A, e) {
    const g = this.editData[A] !== e;
    return this.editData[A] = e, g;
  }
  updateEditFloatData(A, e) {
    wt[0] = e;
    const g = this.editFloatData[A] !== wt[0];
    return g && (this.editFloatData[A] = wt[0]), g;
  }
  encodeEdit(A, {
    sdfFirst: e,
    sdfCount: g,
    invert: I,
    rgbaBlendMode: s,
    softEdge: Q,
    sdfSmooth: B
  }) {
    const i = A * 4;
    let C = !1;
    return C = this.updateEditData(i + 0, s | (I ? 256 : 0)) || C, C = this.updateEditData(i + 1, e | g << 16) || C, C = this.updateEditFloatData(i + 2, Q) || C, C = this.updateEditFloatData(i + 3, B) || C, C;
  }
  updateSdfData(A, e) {
    const g = this.sdfData[A] !== e;
    return this.sdfData[A] = e, g;
  }
  updateSdfFloatData(A, e) {
    wt[0] = e;
    const g = this.sdfFloatData[A] !== wt[0];
    return g && (this.sdfFloatData[A] = wt[0]), g;
  }
  encodeSdf(A, {
    sdfType: e,
    invert: g,
    center: I,
    quaternion: s,
    scale: Q,
    sizes: B
  }, i) {
    const C = A * 32, E = e | (g ? 256 : 0);
    let n = !1;
    n = this.updateSdfFloatData(C + 0, (I == null ? void 0 : I.x) ?? 0) || n, n = this.updateSdfFloatData(C + 1, (I == null ? void 0 : I.y) ?? 0) || n, n = this.updateSdfFloatData(C + 2, (I == null ? void 0 : I.z) ?? 0) || n, n = this.updateSdfData(C + 3, E) || n, n = this.updateSdfFloatData(C + 4, (s == null ? void 0 : s.x) ?? 0) || n, n = this.updateSdfFloatData(C + 5, (s == null ? void 0 : s.y) ?? 0) || n, n = this.updateSdfFloatData(C + 6, (s == null ? void 0 : s.z) ?? 0) || n, n = this.updateSdfFloatData(C + 7, (s == null ? void 0 : s.w) ?? 0) || n, n = this.updateSdfFloatData(C + 8, (Q == null ? void 0 : Q.x) ?? 0) || n, n = this.updateSdfFloatData(C + 9, (Q == null ? void 0 : Q.y) ?? 0) || n, n = this.updateSdfFloatData(C + 10, (Q == null ? void 0 : Q.z) ?? 0) || n, n = this.updateSdfData(C + 11, 0) || n, n = this.updateSdfFloatData(C + 12, (B == null ? void 0 : B.x) ?? 0) || n, n = this.updateSdfFloatData(C + 13, (B == null ? void 0 : B.y) ?? 0) || n, n = this.updateSdfFloatData(C + 14, (B == null ? void 0 : B.z) ?? 0) || n, n = this.updateSdfFloatData(C + 15, (B == null ? void 0 : B.w) ?? 0) || n;
    const o = Math.min(4, i.length);
    for (let r = 0; r < o; ++r) {
      const l = C + 16 + r * 4;
      n = this.updateSdfFloatData(l + 0, i[r].x) || n, n = this.updateSdfFloatData(l + 1, i[r].y) || n, n = this.updateSdfFloatData(l + 2, i[r].z) || n, n = this.updateSdfFloatData(l + 3, i[r].w) || n;
    }
    return n;
  }
  // Update the SDFs and edits from an array of SplatEdits and their
  // associated SplatEditSdfs, updating it for the dyno shader program.
  update(A) {
    const e = A.reduce((n, { sdfs: o }) => n + o.length, 0), g = this.ensureCapacity({
      maxEdits: A.length,
      maxSdfs: e
    }), I = [new a.Vector4(), new a.Vector4()], s = new a.Vector3(), Q = new a.Quaternion(), B = new a.Vector3(), i = new a.Vector4();
    let C = 0, E = g;
    A.length !== this.dynoNumEdits.value && (this.dynoNumEdits.value = A.length, this.numEdits = A.length, E = !0);
    for (const [n, { edit: o, sdfs: r }] of A.entries()) {
      E = this.encodeEdit(n, {
        sdfFirst: C,
        sdfCount: r.length,
        invert: o.invert,
        rgbaBlendMode: Ao(o.rgbaBlendMode),
        softEdge: o.softEdge,
        sdfSmooth: o.sdfSmooth
      }) || E;
      let l = !1;
      for (const c of r)
        i.set(c.scale.x, c.scale.y, c.scale.z, c.radius), c.scale.setScalar(1), c.updateMatrixWorld(), c.matrixWorld.clone().invert().decompose(s, Q, B), c.scale.set(i.x, i.y, i.z), c.updateMatrixWorld(), I[0].set(c.color.r, c.color.g, c.color.b, c.opacity), I[1].set(c.displace.x, c.displace.y, c.displace.z, 1), l = this.encodeSdf(
          C,
          {
            sdfType: Pa(c.type),
            invert: c.invert,
            center: s,
            quaternion: Q,
            scale: B,
            sizes: i
          },
          I
        ) || l, C += 1;
      this.numSdfs = C, l && (this.sdfTexture.needsUpdate = !0), E || (E = l);
    }
    return { updated: E, dynoUpdated: g };
  }
  // Modify a Gsplat in a dyno shader program using the current edits and SDFs.
  modify(A) {
    return go(
      A,
      this.dynoSdfArray,
      this.dynoNumEdits,
      this.dynoEdits
    );
  }
}
const RB = { type: "SdfArray" }, UB = oA(`
  struct SdfArray {
    int numSdfs;
    usampler2D sdfTexture;
  };

  void unpackSdfArray(
    usampler2D sdfTexture, int sdfIndex, out uint flags,
    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,
    int numValues, out vec4 values[4]
  ) {
    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);
    flags = temp.w;
    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);
    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);
    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);
    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    for (int i = 0; i < numValues; ++i) {
      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);
      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));
    }
  }

  const uint SDF_FLAG_TYPE = 0xFFu;
  const uint SDF_FLAG_INVERT = 1u << 8u;

  const uint SDF_TYPE_ALL = 0u;
  const uint SDF_TYPE_PLANE = 1u;
  const uint SDF_TYPE_SPHERE = 2u;
  const uint SDF_TYPE_BOX = 3u;
  const uint SDF_TYPE_ELLIPSOID = 4u;
  const uint SDF_TYPE_CYLINDER = 5u;
  const uint SDF_TYPE_CAPSULE = 6u;
  const uint SDF_TYPE_INFINITE_CONE = 7u;

  float evaluateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 outValues[4]
  ) {
    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;
    float maxExp = -1.0 / 0.0;
    for (int i = 0; i < numValues; ++i) {
        outValues[i] = vec4(0.0);
    }

    uint flags;
    vec3 center, scale;
    vec4 quaternion, sizes;
    vec4 values[4];

    int sdfLast = min(sdfFirst + sdfCount, numSdfs);
    for (int index = sdfFirst; index < sdfLast; ++index) {
      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);
      uint sdfType = flags & SDF_FLAG_TYPE;
      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;

      float distance;
      switch (sdfType) {
        case SDF_TYPE_ALL:
          distance = -1.0 / 0.0;
          break;
        case SDF_TYPE_PLANE: {
          distance = sdfPos.z;
          break;
        }
        case SDF_TYPE_SPHERE: {
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_BOX: {
          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;
          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;
          break;
        }
        case SDF_TYPE_ELLIPSOID: {
          vec3 sizes = sizes.xyz;
          float k0 = length(sdfPos / sizes);
          float k1 = length(sdfPos / dot(sizes, sizes));
          distance = k0 * (k0 - 1.0) / k1;
          break;
        }
        case SDF_TYPE_CYLINDER: {
          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;
          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
          break;
        }
        case SDF_TYPE_CAPSULE: {
          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_INFINITE_CONE: {
          float angle = 0.25 * PI * sizes.w;
          vec2 c = vec2(sin(angle), cos(angle));
          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);
          float d = length(q - c * max(dot(q, c), 0.0));
          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);
          break;
        }
      }

      if ((flags & SDF_FLAG_INVERT) != 0u) {
        distance = -distance;
      }

      if (smoothK == 0.0) {
        if (distance < distanceAccum) {
          distanceAccum = distance;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] = values[i];
          }
        }
      } else {
        float scaledDistance = -distance / smoothK;
        if (scaledDistance > maxExp) {
          float scale = exp(maxExp - scaledDistance);
          distanceAccum *= scale;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] *= scale;
          }
          maxExp = scaledDistance;
        }

        float weight = exp(scaledDistance - maxExp);
        distanceAccum += weight;
        for (int i = 0; i < numValues; ++i) {
          outValues[i] += weight * values[i];
        }
      }
    }

    if (smoothK == 0.0) {
      return distanceAccum;
    } else {
      // Very distant SDFs may result in 0 accumulation
      if (distanceAccum == 0.0) {
        return 1.0 / 0.0;
      }
      for (int i = 0; i < numValues; ++i) {
        outValues[i] /= distanceAccum;
      }
      return (-log(distanceAccum) - maxExp) * smoothK;
    }
  }

  float modulateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 values[4],
    float softEdge, bool invert
  ) {
    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);
    if (invert) {
      distance = -distance;
    }

    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)
      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);
  }
`), LB = oA(`
  const uint EDIT_FLAG_BLEND = 0xFFu;
  const uint EDIT_BLEND_MULTIPLY = 0u;
  const uint EDIT_BLEND_SET_RGB = 1u;
  const uint EDIT_BLEND_ADD_RGBA = 2u;
  const uint EDIT_FLAG_INVERT = 0x100u;

  void decodeEdit(
    uvec4 packedEdit, out int sdfFirst, out int sdfCount,
    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth
  ) {
    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;
    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;

    sdfFirst = int(packedEdit.y & 0xFFFFu);
    sdfCount = int(packedEdit.y >> 16u);

    softEdge = uintBitsToFloat(packedEdit.z);
    sdfSmooth = uintBitsToFloat(packedEdit.w);
  }

  void applyRgbaDisplaceEdit(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,
    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba
  ) {
    vec4 values[4];
    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);
    // On Android, moving values[0] is necessary to work around a compiler bug.
    vec4 sdfRgba = values[0];
    vec4 sdfDisplaceScale = values[1];

    vec4 target;
    switch (rgbaBlendMode) {
      case EDIT_BLEND_MULTIPLY:
        target = rgba * sdfRgba;
        break;
      case EDIT_BLEND_SET_RGB:
        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);
        break;
      case EDIT_BLEND_ADD_RGBA:
        target = rgba + sdfRgba;
        break;
      default:
        // Debug output if blend mode not set
        target = vec4(fract(pos), 1.0);
    }
    rgba = mix(rgba, target, modulate);
    pos += sdfDisplaceScale.xyz * modulate;
  }

  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {
    int sdfFirst, sdfCount;
    bool invert;
    uint rgbaBlendMode;
    float softEdge, sdfSmooth;
    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);
    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);
  }
`);
function go(t, A, e, g) {
  return new Z({
    inTypes: {
      gsplat: P,
      sdfArray: RB,
      numEdits: "int",
      rgbaDisplaceEdits: "uvec4"
    },
    outTypes: { gsplat: P },
    globals: () => [UB, LB],
    inputs: { gsplat: t, sdfArray: A, numEdits: e, rgbaDisplaceEdits: g },
    statements: ({ inputs: s, outputs: Q }) => {
      const { sdfArray: B, numEdits: i, rgbaDisplaceEdits: C } = s, { gsplat: E } = Q;
      return UA(`
        ${E} = ${s.gsplat};
        if (isGsplatActive(${E}.flags)) {
          for (int editIndex = 0; editIndex < ${i}; ++editIndex) {
            applyPackedRgbaDisplaceEdit(
              ${C}[editIndex], ${B}.sdfTexture, ${B}.numSdfs,
              ${E}.center, ${E}.rgba
            );
          }
        }
      `);
    }
  }).outputs.gsplat;
}
const wt = new Float32Array(1);
class Io {
  constructor(A) {
    this.modifier = A, this.cache = /* @__PURE__ */ new Map();
  }
  apply(A) {
    let e = this.cache.get(A);
    return e || (e = SA(
      { index: "int" },
      { gsplat: P },
      ({ index: g }) => {
        const { gsplat: I } = A.apply({ index: g });
        return this.modifier.apply({ gsplat: I });
      }
    ), this.cache.set(A, e)), e;
  }
}
class dt {
  // Create the dyno uniforms that parameterize the transform, setting them
  // to initial values that are different from any valid transform.
  constructor() {
    this.scale = new ot({ value: Number.NEGATIVE_INFINITY }), this.rotate = new Wt({
      value: new a.Quaternion(
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY
      )
    }), this.translate = new Ft({
      value: new a.Vector3(
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY
      )
    });
  }
  // Apply the transform to a Vec3 position in a dyno program.
  apply(A) {
    return QB(A, {
      scale: this.scale,
      rotate: this.rotate,
      translate: this.translate
    });
  }
  applyDir(A) {
    return BB(A, {
      rotate: this.rotate
    });
  }
  // Apply the transform to a Gsplat in a dyno program.
  applyGsplat(A) {
    return Xe(A, {
      scale: this.scale,
      rotate: this.rotate,
      translate: this.translate
    });
  }
  // Update the uniforms to match the given transform matrix.
  updateFromMatrix(A) {
    const e = new a.Vector3(), g = new a.Quaternion(), I = new a.Vector3();
    A.decompose(I, g, e);
    const s = (e.x + e.y + e.z) / 3;
    let Q = !1;
    return s !== this.scale.value && (this.scale.value = s, Q = !0), I.equals(this.translate.value) || (this.translate.value.copy(I), Q = !0), g.equals(this.rotate.value) || (this.rotate.value.copy(g), Q = !0), Q;
  }
  // Update this transform to match the object's to-world transform.
  update(A) {
    return A.updateMatrixWorld(), this.updateFromMatrix(A.matrixWorld);
  }
}
class qt extends a.Object3D {
  constructor({
    numSplats: A,
    generator: e,
    construct: g,
    update: I
  }) {
    if (super(), this.numSplats = A ?? 0, this.generator = e, this.frameUpdate = I, this.version = 0, g) {
      const s = g(this);
      Object.assign(this, s);
    }
  }
  updateVersion() {
    this.version += 1;
  }
  set needsUpdate(A) {
    A && this.updateVersion();
  }
}
const et = class et extends qt {
  constructor(A = {}) {
    const e = new dt(), g = new dt(), I = new dt(), s = new dt(), Q = new Wt({
      value: new a.Vector4(
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY
      )
    }), B = new ot({ value: 0 }), i = new ot({ value: 0 }), C = {
      transform: e,
      viewToWorld: g,
      worldToView: I,
      viewToObject: s,
      recolor: Q,
      time: B,
      deltaTime: i
    };
    if (super({
      update: ({ time: E, deltaTime: n, viewToWorld: o, globalEdits: r }) => this.update({ time: E, deltaTime: n, viewToWorld: o, globalEdits: r })
    }), this.isInitialized = !1, this.recolor = new a.Color(1, 1, 1), this.opacity = 1, this.enableViewToObject = !1, this.enableViewToWorld = !1, this.enableWorldToView = !1, this.skinning = null, this.edits = null, this.rgbaDisplaceEdits = null, this.splatRgba = null, this.maxSh = 3, this.packedSplats = A.packedSplats ?? new qA(), this.numSplats = this.packedSplats.numSplats, this.editable = A.editable ?? !0, this.onFrame = A.onFrame, this.context = C, this.objectModifier = A.objectModifier, this.worldModifier = A.worldModifier, this.updateGenerator(), A.url || A.fileBytes || A.constructSplats || A.packedSplats && !A.packedSplats.isInitialized)
      this.initialized = this.asyncInitialize(A).then(async () => {
        if (this.updateGenerator(), this.isInitialized = !0, A.onLoad) {
          const E = A.onLoad(this);
          E instanceof Promise && await E;
        }
        return this;
      });
    else if (this.isInitialized = !0, this.initialized = Promise.resolve(this), A.onLoad) {
      const E = A.onLoad(this);
      E instanceof Promise && (this.initialized = E.then(() => this));
    }
  }
  async asyncInitialize(A) {
    const { url: e, fileBytes: g, fileType: I, fileName: s, maxSplats: Q, constructSplats: B } = A;
    if (e || g || B) {
      const i = {
        url: e,
        fileBytes: g,
        fileType: I,
        fileName: s,
        maxSplats: Q,
        construct: B
      };
      this.packedSplats.reinitialize(i);
    }
    this.packedSplats && (await this.packedSplats.initialized, this.numSplats = this.packedSplats.numSplats, this.updateGenerator());
  }
  static async staticInitialize() {
    await Sg(), et.isStaticInitialized = !0;
  }
  // Creates a new Gsplat with the provided parameters (all values in "float" space,
  // i.e. 0-1 for opacity and color) and adds it to the end of the packedSplats,
  // increasing numSplats by 1. If necessary, reallocates the buffer with an exponential
  // doubling strategy to fit the new data, so it's fairly efficient to just
  // pushSplat(...) each Gsplat you want to create in a loop.
  pushSplat(A, e, g, I, s) {
    this.packedSplats.pushSplat(A, e, g, I, s);
  }
  // This method iterates over all Gsplats in this instance's packedSplats,
  // invoking the provided callback with index: number in 0..=(this.numSplats-1) and
  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,
  // opacity: number (0..1), and color: THREE.Color (rgb values in 0..1).
  // Note that the objects passed in as center etc. are the same for every callback
  // invocation: these objects are reused for efficiency. Changing these values has
  // no effect as they are decoded/unpacked copies of the underlying data. To update
  // the packedSplats, call .packedSplats.setSplat(index, center, scales,
  // quaternion, opacity, color).
  forEachSplat(A) {
    this.packedSplats.forEachSplat(A);
  }
  // Call this when you are finished with the SplatMesh and want to free
  // any buffers it holds (via packedSplats).
  dispose() {
    this.packedSplats.dispose();
  }
  constructGenerator(A) {
    const { transform: e, viewToObject: g, recolor: I } = A, s = SA(
      { index: "int" },
      { gsplat: P },
      ({ index: Q }) => {
        if (!Q)
          throw new Error("index is undefined");
        let B = mt(this.packedSplats.dyno, Q);
        if (this.maxSh >= 1) {
          const { sh1Texture: C, sh2Texture: E, sh3Texture: n } = this.ensureShTextures();
          if (C) {
            const o = g.translate, { center: r } = at(B).outputs, l = fQ(Gt(r, o));
            let c = io(B, C, l);
            this.maxSh >= 2 && E && (c = pA(c, no(B, E, l))), this.maxSh >= 3 && n && (c = pA(c, Co(B, n, l)));
            let { rgba: h } = at(B).outputs;
            h = pA(h, NQ(c, K("float", 0))), B = Qt({ gsplat: B, rgba: h });
          }
        }
        if (this.splatRgba) {
          const C = _a(this.splatRgba.dyno, Q);
          B = Qt({ gsplat: B, rgba: C });
        }
        this.skinning && (B = this.skinning.modify(B)), this.objectModifier && (B = this.objectModifier.apply({ gsplat: B }).gsplat), B = e.applyGsplat(B);
        const i = EA(I, at(B).outputs.rgba);
        return B = Qt({ gsplat: B, rgba: i }), this.rgbaDisplaceEdits && (B = this.rgbaDisplaceEdits.modify(B)), this.worldModifier && (B = this.worldModifier.apply({ gsplat: B }).gsplat), { gsplat: B };
      }
    );
    this.generator = s;
  }
  // Call this whenever something changes in the Gsplat processing pipeline,
  // for example changing maxSh or updating objectModifier or worldModifier.
  // Compiled generators are cached for efficiency and re-use when the same
  // pipeline structure emerges after successive changes.
  updateGenerator() {
    this.constructGenerator(this.context);
  }
  // This is called automatically by SparkRenderer and you should not have to
  // call it. It updates parameters for the generated pipeline and calls
  // updateGenerator() if the pipeline needs to change.
  update({
    time: A,
    viewToWorld: e,
    deltaTime: g,
    globalEdits: I
  }) {
    var h;
    this.numSplats = this.packedSplats.numSplats, this.context.time.value = A, this.context.deltaTime.value = g, et.dynoTime.value = A;
    const { transform: s, viewToObject: Q, recolor: B } = this.context;
    let i = s.update(this);
    this.context.viewToWorld.updateFromMatrix(e) && this.enableViewToWorld && (i = !0);
    const C = e.clone().invert();
    this.context.worldToView.updateFromMatrix(C) && this.enableWorldToView && (i = !0);
    const o = new a.Matrix4().compose(
      s.translate.value,
      s.rotate.value,
      new a.Vector3().setScalar(s.scale.value)
    ).invert().multiply(e);
    Q.updateFromMatrix(o) && (this.enableViewToObject || this.packedSplats.extra.sh1) && (i = !0);
    const r = new a.Vector4(
      this.recolor.r,
      this.recolor.g,
      this.recolor.b,
      this.opacity
    );
    r.equals(B.value) || (B.value.copy(r), i = !0);
    const l = this.editable ? (this.edits ?? []).concat(I) : [];
    this.editable && !this.edits && this.traverseVisible((u) => {
      u instanceof Ce && l.push(u);
    }), l.sort((u, y) => u.ordering - y.ordering);
    const c = l.map((u) => {
      if (u.sdfs != null)
        return { edit: u, sdfs: u.sdfs };
      const y = [];
      return u.traverseVisible((w) => {
        w instanceof to && y.push(w);
      }), { edit: u, sdfs: y };
    });
    if (c.length > 0 && !this.rgbaDisplaceEdits) {
      const u = c.length, y = c.reduce(
        (w, d) => w + d.sdfs.length,
        0
      );
      this.rgbaDisplaceEdits = new eo({
        maxEdits: u,
        maxSdfs: y
      }), this.updateGenerator();
    }
    if (this.rgbaDisplaceEdits) {
      const u = this.rgbaDisplaceEdits.update(c);
      i || (i = u.updated), u.dynoUpdated && this.updateGenerator();
    }
    i && this.updateVersion(), (h = this.onFrame) == null || h.call(this, { mesh: this, time: A, deltaTime: g });
  }
  // This method conforms to the standard THREE.Raycaster API, performing object-ray
  // intersections using this method to populate the provided intersects[] array
  // with each intersection point.
  raycast(A, e) {
    if (!this.packedSplats.packedArray || !this.packedSplats.numSplats)
      return;
    const { near: g, far: I, ray: s } = A, Q = this.matrixWorld.clone().invert(), B = new a.Matrix3().setFromMatrix4(Q), i = s.origin.clone().applyMatrix4(Q), C = s.direction.clone().applyMatrix3(B), E = new a.Vector3();
    Q.decompose(new a.Vector3(), new a.Quaternion(), E), (E.x * E.y * E.z) ** (1 / 3);
    const o = Yi(
      i.x,
      i.y,
      i.z,
      C.x,
      C.y,
      C.z,
      g,
      I,
      this.packedSplats.numSplats,
      this.packedSplats.packedArray,
      !0
    );
    for (const r of o) {
      const l = s.direction.clone().multiplyScalar(r).add(s.origin);
      e.push({
        distance: r,
        point: l,
        object: this
      });
    }
  }
  ensureShTextures() {
    if (!this.packedSplats.extra.sh1)
      return {};
    let A = this.packedSplats.extra.sh1Texture;
    if (!A) {
      let I = this.packedSplats.extra.sh1;
      const { width: s, height: Q, depth: B, maxSplats: i } = fA(
        I.length / 2
      );
      if (I.length < i * 2) {
        const E = new Uint32Array(i * 2);
        E.set(I), this.packedSplats.extra.sh1 = E, I = E;
      }
      const C = new a.DataArrayTexture(I, s, Q, B);
      C.format = a.RGIntegerFormat, C.type = a.UnsignedIntType, C.internalFormat = "RG32UI", C.needsUpdate = !0, A = new Ht({
        value: C,
        key: "sh1"
      }), this.packedSplats.extra.sh1Texture = A;
    }
    if (!this.packedSplats.extra.sh2)
      return { sh1Texture: A };
    let e = this.packedSplats.extra.sh2Texture;
    if (!e) {
      let I = this.packedSplats.extra.sh2;
      const { width: s, height: Q, depth: B, maxSplats: i } = fA(
        I.length / 4
      );
      if (I.length < i * 4) {
        const E = new Uint32Array(i * 4);
        E.set(I), this.packedSplats.extra.sh2 = E, I = E;
      }
      const C = new a.DataArrayTexture(I, s, Q, B);
      C.format = a.RGBAIntegerFormat, C.type = a.UnsignedIntType, C.internalFormat = "RGBA32UI", C.needsUpdate = !0, e = new Ht({
        value: C,
        key: "sh2"
      }), this.packedSplats.extra.sh2Texture = e;
    }
    if (!this.packedSplats.extra.sh3)
      return { sh1Texture: A, sh2Texture: e };
    let g = this.packedSplats.extra.sh3Texture;
    if (!g) {
      let I = this.packedSplats.extra.sh3;
      const { width: s, height: Q, depth: B, maxSplats: i } = fA(
        I.length / 4
      );
      if (I.length < i * 4) {
        const E = new Uint32Array(i * 4);
        E.set(I), this.packedSplats.extra.sh3 = E, I = E;
      }
      const C = new a.DataArrayTexture(I, s, Q, B);
      C.format = a.RGBAIntegerFormat, C.type = a.UnsignedIntType, C.internalFormat = "RGBA32UI", C.needsUpdate = !0, g = new Ht({
        value: C,
        key: "sh3"
      }), this.packedSplats.extra.sh3Texture = g;
    }
    return { sh1Texture: A, sh2Texture: e, sh3Texture: g };
  }
};
et.staticInitialized = et.staticInitialize(), et.isStaticInitialized = !1, et.dynoTime = new ot({ value: 0 });
let WA = et;
const so = oA(`
  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {
    // Extract sint7 values packed into 2 x uint32
    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;
    vec3 sh1_0 = vec3(ivec3(
      int(packed.x << 25u) >> 25,
      int(packed.x << 18u) >> 25,
      int(packed.x << 11u) >> 25
    )) / 63.0;
    vec3 sh1_1 = vec3(ivec3(
      int(packed.x << 4u) >> 25,
      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,
      int(packed.y << 22u) >> 25
    )) / 63.0;
    vec3 sh1_2 = vec3(ivec3(
      int(packed.y << 15u) >> 25,
      int(packed.y << 8u) >> 25,
      int(packed.y << 1u) >> 25
    )) / 63.0;

    return sh1_0 * (-0.4886025 * viewDir.y)
      + sh1_1 * (0.4886025 * viewDir.z)
      + sh1_2 * (-0.4886025 * viewDir.x);
  }
`), Qo = oA(`
  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {
    // Extract sint8 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);
    vec3 sh2_0 = vec3(ivec3(
      int(packed.x << 24u) >> 24,
      int(packed.x << 16u) >> 24,
      int(packed.x << 8u) >> 24
    )) / 127.0;
    vec3 sh2_1 = vec3(ivec3(
      int(packed.x) >> 24,
      int(packed.y << 24u) >> 24,
      int(packed.y << 16u) >> 24
    )) / 127.0;
    vec3 sh2_2 = vec3(ivec3(
      int(packed.y << 8u) >> 24,
      int(packed.y) >> 24,
      int(packed.z << 24u) >> 24
    )) / 127.0;
    vec3 sh2_3 = vec3(ivec3(
      int(packed.z << 16u) >> 24,
      int(packed.z << 8u) >> 24,
      int(packed.z) >> 24
    )) / 127.0;
    vec3 sh2_4 = vec3(ivec3(
      int(packed.w << 24u) >> 24,
      int(packed.w << 16u) >> 24,
      int(packed.w << 8u) >> 24
    )) / 127.0;

    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)
      + sh2_1 * (-1.0925484 * viewDir.y * viewDir.z)
      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))
      + sh2_3 * (-1.0925484 * viewDir.x * viewDir.z)
      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));
  }
`), Bo = oA(`
  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {
    // Extract sint6 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);
    vec3 sh3_0 = vec3(ivec3(
      int(packed.x << 26u) >> 26,
      int(packed.x << 20u) >> 26,
      int(packed.x << 14u) >> 26
    )) / 31.0;
    vec3 sh3_1 = vec3(ivec3(
      int(packed.x << 8u) >> 26,
      int(packed.x << 2u) >> 26,
      int((packed.x >> 4u) | (packed.y << 28u)) >> 26
    )) / 31.0;
    vec3 sh3_2 = vec3(ivec3(
      int(packed.y << 22u) >> 26,
      int(packed.y << 16u) >> 26,
      int(packed.y << 10u) >> 26
    )) / 31.0;
    vec3 sh3_3 = vec3(ivec3(
      int(packed.y << 4u) >> 26,
      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,
      int(packed.z << 24u) >> 26
    )) / 31.0;
    vec3 sh3_4 = vec3(ivec3(
      int(packed.z << 18u) >> 26,
      int(packed.z << 12u) >> 26,
      int(packed.z << 6u) >> 26
    )) / 31.0;
    vec3 sh3_5 = vec3(ivec3(
      int(packed.z) >> 26,
      int(packed.w << 26u) >> 26,
      int(packed.w << 20u) >> 26
    )) / 31.0;
    vec3 sh3_6 = vec3(ivec3(
      int(packed.w << 14u) >> 26,
      int(packed.w << 8u) >> 26,
      int(packed.w << 2u) >> 26
    )) / 31.0;

    float xx = viewDir.x * viewDir.x;
    float yy = viewDir.y * viewDir.y;
    float zz = viewDir.z * viewDir.z;
    float xy = viewDir.x * viewDir.y;
    float yz = viewDir.y * viewDir.z;
    float zx = viewDir.z * viewDir.x;

    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))
      + sh3_1 * (2.8906114 * xy * viewDir.z) +
      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))
      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))
      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))
      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))
      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));
  }
`);
function io(t, A, e) {
  return jt({
    inTypes: { gsplat: P, sh1: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat: t, sh1: A, viewDir: e },
    globals: () => [FA, so],
    statements: ({ inputs: g, outputs: I }) => UA(`
        if (isGsplatActive(${g.gsplat}.flags)) {
          ${I.rgb} = evaluateSH1(${g.gsplat}, ${g.sh1}, ${g.viewDir});
        } else {
          ${I.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
function no(t, A, e) {
  return jt({
    inTypes: { gsplat: P, sh2: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat: t, sh2: A, viewDir: e },
    globals: () => [FA, Qo],
    statements: ({ inputs: g, outputs: I }) => UA(`
        if (isGsplatActive(${g.gsplat}.flags)) {
          ${I.rgb} = evaluateSH2(${g.gsplat}, ${g.sh2}, ${g.viewDir});
        } else {
          ${I.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
function Co(t, A, e) {
  return jt({
    inTypes: { gsplat: P, sh3: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat: t, sh3: A, viewDir: e },
    globals: () => [FA, Bo],
    statements: ({ inputs: g, outputs: I }) => UA(`
        if (isGsplatActive(${g.gsplat}.flags)) {
          ${I.rgb} = evaluateSH3(${g.gsplat}, ${g.sh3}, ${g.viewDir});
        } else {
          ${I.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
const pt = class pt {
  // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet
  constructor({ fileBytes: A }) {
    this.header = "", this.littleEndian = !0, this.elements = {}, this.comments = [], this.data = null, this.numSplats = 0, this.fileBytes = A instanceof ArrayBuffer ? new Uint8Array(A) : A;
  }
  // Identify and parse the PLY text header (assumed to be <64KB in size).
  // this.elements will contain all the elements in the file, typically
  // "vertex" contains the Gsplat data.
  async parseHeader() {
    const e = new ReadableStream({
      start: (Q) => {
        Q.enqueue(this.fileBytes.slice(0, 65536)), Q.close();
      }
    }).pipeThrough(new TextDecoderStream()).getReader();
    this.header = "";
    const g = `end_header
`;
    for (; ; ) {
      const { value: Q, done: B } = await e.read();
      if (B)
        throw new Error("Failed to read header");
      this.header += Q;
      const i = this.header.indexOf(g);
      if (i >= 0) {
        this.header = this.header.slice(0, i + g.length);
        break;
      }
    }
    const I = new TextEncoder().encode(this.header).length;
    this.data = new DataView(this.fileBytes.buffer, I), this.elements = {};
    let s = null;
    this.comments = [], this.header.trim().split(`
`).forEach((Q, B) => {
      const i = Q.trim();
      if (B === 0) {
        if (i !== "ply")
          throw new Error("Invalid PLY header");
        return;
      }
      if (i.length === 0)
        return;
      const C = i.split(" ");
      switch (C[0]) {
        case "format":
          if (C[1] === "binary_little_endian")
            this.littleEndian = !0;
          else if (C[1] === "binary_big_endian")
            this.littleEndian = !1;
          else
            throw new Error(`Unsupported PLY format: ${C[1]}`);
          if (C[2] !== "1.0")
            throw new Error(`Unsupported PLY version: ${C[2]}`);
          break;
        case "end_header":
          break;
        case "comment":
          this.comments.push(i.slice(8));
          break;
        case "element": {
          const E = C[1];
          s = {
            name: E,
            count: Number.parseInt(C[2]),
            properties: {}
          }, this.elements[E] = s;
          break;
        }
        case "property":
          if (s == null)
            throw new Error("Property must be inside an element");
          C[1] === "list" ? s.properties[C[4]] = {
            isList: !0,
            type: C[3],
            countType: C[2]
          } : s.properties[C[2]] = {
            isList: !1,
            type: C[1]
          };
          break;
      }
    }), this.elements.vertex && (this.numSplats = this.elements.vertex.count);
  }
  parseData(A) {
    let e = 0;
    const g = this.data;
    if (g == null)
      throw new Error("No data to parse");
    for (const I in this.elements) {
      const s = this.elements[I], { count: Q, properties: B } = s, i = {}, C = [];
      for (const [n, o] of Object.entries(B))
        o.isList ? (i[n] = [], C.push(() => {
          const r = i[n];
          r.length = Ae[o.countType](
            g,
            e,
            this.littleEndian
          ), e += yt[o.countType];
          for (let l = 0; l < r.length; l++)
            r[l] = Ae[o.type](
              g,
              e,
              this.littleEndian
            ), e += yt[o.type];
        })) : (i[n] = 0, C.push(() => {
          i[n] = Ae[o.type](
            g,
            e,
            this.littleEndian
          ), e += yt[o.type];
        }));
      const E = A(s) ?? (() => {
      });
      for (let n = 0; n < Q; n++) {
        for (const o of C)
          o();
        E(n, i);
      }
    }
  }
  // Parse all the Gsplat data in the PLY file in go, invoking the given
  // callbacks for each Gsplat.
  parseSplats(A, e) {
    if (this.elements.vertex == null)
      throw new Error("No vertex element found");
    let g = !1;
    const I = [];
    let s = 0, Q = [], B = [], i = [], C, E, n;
    function o() {
      const u = ao[s];
      Q = new Array(3).fill(null).flatMap(
        (y, w) => [0, 1, 2].map((d, p) => `f_rest_${w + p * u / 3}`)
      ), B = new Array(5).fill(null).flatMap(
        (y, w) => [0, 1, 2].map((d, p) => `f_rest_${3 + w + p * u / 3}`)
      ), i = new Array(7).fill(null).flatMap(
        (y, w) => [0, 1, 2].map((d, p) => `f_rest_${8 + w + p * u / 3}`)
      ), C = s >= 1 ? new Float32Array(3 * 3) : void 0, E = s >= 2 ? new Float32Array(5 * 3) : void 0, n = s >= 3 ? new Float32Array(7 * 3) : void 0;
    }
    function r(u, y) {
      if (!C)
        throw new Error("Missing sh1");
      for (const [w, d] of Q.entries())
        C[w] = y[d] * 8 / 255 - 4;
      if (E)
        for (const [w, d] of B.entries())
          E[w] = y[d] * 8 / 255 - 4;
      if (n)
        for (const [w, d] of i.entries())
          n[w] = y[d] * 8 / 255 - 4;
      e == null || e(u, C, E, n);
    }
    function l(u) {
      const {
        min_x: y,
        min_y: w,
        min_z: d,
        max_x: p,
        max_y: m,
        max_z: N,
        min_scale_x: f,
        min_scale_y: D,
        min_scale_z: R,
        max_scale_x: S,
        max_scale_y: M,
        max_scale_z: L
      } = u.properties;
      if (!y || !w || !d || !p || !m || !N || !f || !D || !R || !S || !M || !L)
        throw new Error("Missing PLY chunk properties");
      return g = !0, (G, x) => {
        const {
          min_x: U,
          min_y: J,
          min_z: AA,
          max_x: z,
          max_y: eA,
          max_z: tA,
          min_scale_x: X,
          min_scale_y: b,
          min_scale_z: W,
          max_scale_x: j,
          max_scale_y: _,
          max_scale_z: Y,
          min_r: uA,
          min_g: nA,
          min_b: wA,
          max_r: yA,
          max_g: NA,
          max_b: rA
        } = x;
        I.push({
          min_x: U,
          min_y: J,
          min_z: AA,
          max_x: z,
          max_y: eA,
          max_z: tA,
          min_scale_x: X,
          min_scale_y: b,
          min_scale_z: W,
          max_scale_x: j,
          max_scale_y: _,
          max_scale_z: Y,
          min_r: uA,
          min_g: nA,
          min_b: wA,
          max_r: yA,
          max_g: NA,
          max_b: rA
        });
      };
    }
    function c(u) {
      if (e && u.name === "sh")
        return s = Eg(u.properties), o(), r;
      if (u.name !== "vertex")
        return null;
      const { packed_position: y, packed_rotation: w, packed_scale: d, packed_color: p } = u.properties;
      if (!y || !w || !d || !p)
        throw new Error(
          "Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color"
        );
      const m = Math.sqrt(2);
      return (N, f) => {
        const D = I[N >>> 8];
        if (D == null)
          throw new Error("Missing PLY chunk");
        const {
          min_x: R,
          min_y: S,
          min_z: M,
          max_x: L,
          max_y: G,
          max_z: x,
          min_scale_x: U,
          min_scale_y: J,
          min_scale_z: AA,
          max_scale_x: z,
          max_scale_y: eA,
          max_scale_z: tA,
          min_r: X,
          min_g: b,
          min_b: W,
          max_r: j,
          max_g: _,
          max_b: Y
        } = D, { packed_position: uA, packed_rotation: nA, packed_scale: wA, packed_color: yA } = f, NA = (uA >>> 21 & 2047) / 2047 * (L - R) + R, rA = (uA >>> 11 & 1023) / 1023 * (G - S) + S, LA = (uA & 2047) / 2047 * (x - M) + M, MA = ((nA >>> 20 & 1023) / 1023 - 0.5) * m, _A = ((nA >>> 10 & 1023) / 1023 - 0.5) * m, OA = ((nA & 1023) / 1023 - 0.5) * m, v = Math.sqrt(Math.max(0, 1 - MA * MA - _A * _A - OA * OA)), lA = nA >>> 30, VA = lA === 0 ? MA : lA === 1 ? v : _A, Ut = lA <= 1 ? _A : lA === 2 ? v : OA, Ot = lA <= 2 ? OA : v, mA = lA === 0 ? v : MA, H = Math.exp(
          (wA >>> 21 & 2047) / 2047 * (z - U) + U
        ), ZA = Math.exp(
          (wA >>> 11 & 1023) / 1023 * (eA - J) + J
        ), we = Math.exp(
          (wA & 2047) / 2047 * (tA - AA) + AA
        ), ye = (yA >>> 24 & 255) / 255 * ((j ?? 1) - (X ?? 0)) + (X ?? 0), De = (yA >>> 16 & 255) / 255 * ((_ ?? 1) - (b ?? 0)) + (b ?? 0), de = (yA >>> 8 & 255) / 255 * ((Y ?? 1) - (W ?? 0)) + (W ?? 0), pe = (yA & 255) / 255;
        A(
          N,
          NA,
          rA,
          LA,
          H,
          ZA,
          we,
          VA,
          Ut,
          Ot,
          mA,
          pe,
          ye,
          De,
          de
        );
      };
    }
    const h = (u) => {
      if (u.name === "chunk")
        return l(u);
      if (g)
        return c(u);
      if (u.name !== "vertex")
        return null;
      const {
        x: y,
        y: w,
        z: d,
        scale_0: p,
        scale_1: m,
        scale_2: N,
        rot_0: f,
        rot_1: D,
        rot_2: R,
        rot_3: S,
        opacity: M,
        f_dc_0: L,
        f_dc_1: G,
        f_dc_2: x,
        red: U,
        green: J,
        blue: AA,
        alpha: z
      } = u.properties;
      if (!y || !w || !d)
        throw new Error("Missing PLY properties: x, y, z");
      const eA = p && m && N, tA = f && D && R && S, X = z != null ? te[z.type] : 1, b = U != null ? te[U.type] : 1, W = J != null ? te[J.type] : 1, j = AA != null ? te[AA.type] : 1;
      return s = Eg(u.properties), o(), (_, Y) => {
        const uA = eA ? Math.exp(Y.scale_0) : pt.defaultPointScale, nA = eA ? Math.exp(Y.scale_1) : pt.defaultPointScale, wA = eA ? Math.exp(Y.scale_2) : pt.defaultPointScale, yA = tA ? Y.rot_1 : 0, NA = tA ? Y.rot_2 : 0, rA = tA ? Y.rot_3 : 0, LA = tA ? Y.rot_0 : 1, MA = M != null ? 1 / (1 + Math.exp(-Y.opacity)) : z != null ? Y.alpha / X : 1, _A = L != null ? Y.f_dc_0 * $t + 0.5 : U != null ? Y.red / b : 1, OA = G != null ? Y.f_dc_1 * $t + 0.5 : J != null ? Y.green / W : 1, v = x != null ? Y.f_dc_2 * $t + 0.5 : AA != null ? Y.blue / j : 1;
        if (A(
          _,
          Y.x,
          Y.y,
          Y.z,
          uA,
          nA,
          wA,
          yA,
          NA,
          rA,
          LA,
          MA,
          _A,
          OA,
          v
        ), e && C) {
          if (C)
            for (const [lA, VA] of Q.entries())
              C[lA] = Y[VA];
          if (E)
            for (const [lA, VA] of B.entries())
              E[lA] = Y[VA];
          if (n)
            for (const [lA, VA] of i.entries())
              n[lA] = Y[VA];
          e(_, C, E, n);
        }
      };
    };
    this.parseData(h);
  }
  // Inject RGBA values into original PLY file, which can be used to modify
  // the color/opacity of the Gsplats and write out the modified PLY file.
  injectRgba(A) {
    let e = 0;
    const g = this.data;
    if (g == null)
      throw new Error("No parsed data");
    if (A.length !== this.numSplats * 4)
      throw new Error("Invalid RGBA array length");
    for (const I in this.elements) {
      const s = this.elements[I], { count: Q, properties: B } = s, i = [];
      let C = 0;
      const E = I === "vertex";
      if (E) {
        for (const n of ["opacity", "f_dc_0", "f_dc_1", "f_dc_2"])
          if (!B[n] || B[n].type !== "float")
            throw new Error(`Can't injectRgba due to property: ${n}`);
      }
      for (const [n, o] of Object.entries(B))
        if (o.isList)
          i.push(() => {
            const r = Ae[o.countType](
              g,
              e,
              this.littleEndian
            );
            e += yt[o.countType], e += r * yt[o.type];
          });
        else {
          if (E)
            if (n === "f_dc_0" || n === "f_dc_1" || n === "f_dc_2") {
              const r = Number.parseInt(
                n.slice(5)
              );
              i.push(() => {
                const l = (A[C + r] / 255 - 0.5) / $t;
                Cg[o.type](
                  g,
                  e,
                  this.littleEndian,
                  l
                );
              });
            } else n === "opacity" && i.push(() => {
              const r = Math.max(
                -100,
                Math.min(
                  100,
                  -Math.log(1 / (A[C + 3] / 255) - 1)
                )
              );
              Cg[o.type](
                g,
                e,
                this.littleEndian,
                r
              );
            });
          i.push(() => {
            e += yt[o.type];
          });
        }
      for (let n = 0; n < Q; n++) {
        for (const o of i)
          o();
        E && (C += 4);
      }
    }
  }
};
pt.defaultPointScale = 1e-3;
let Ee = pt;
const $t = 0.28209479177387814, Ae = {
  char: (t, A, e) => t.getInt8(A),
  uchar: (t, A, e) => t.getUint8(A),
  short: (t, A, e) => t.getInt16(A, e),
  ushort: (t, A, e) => t.getUint16(A, e),
  int: (t, A, e) => t.getInt32(A, e),
  uint: (t, A, e) => t.getUint32(A, e),
  float: (t, A, e) => t.getFloat32(A, e),
  double: (t, A, e) => t.getFloat64(A, e)
}, Cg = {
  char: (t, A, e, g) => {
    t.setInt8(A, g);
  },
  uchar: (t, A, e, g) => {
    t.setUint8(A, g);
  },
  short: (t, A, e, g) => {
    t.setInt16(A, g, e);
  },
  ushort: (t, A, e, g) => {
    t.setUint16(A, g, e);
  },
  int: (t, A, e, g) => {
    t.setInt32(A, g, e);
  },
  uint: (t, A, e, g) => {
    t.setUint32(A, g, e);
  },
  float: (t, A, e, g) => {
    t.setFloat32(A, g, e);
  },
  double: (t, A, e, g) => {
    t.setFloat64(A, g, e);
  }
}, yt = {
  char: 1,
  uchar: 1,
  short: 2,
  ushort: 2,
  int: 4,
  uint: 4,
  float: 4,
  double: 8
}, te = {
  char: 127,
  uchar: 255,
  short: 32767,
  ushort: 65535,
  int: 2147483647,
  uint: 4294967295,
  float: 1,
  double: 1
}, Eo = {
  0: 0,
  9: 1,
  24: 2,
  45: 3
}, ao = {
  0: 0,
  1: 9,
  2: 24,
  3: 45
};
function Eg(t) {
  let A = 0;
  for (; t[`f_rest_${A}`]; )
    A += 1;
  const e = Eo[A];
  if (e == null)
    throw new Error(`Unsupported number of SH coefficients: ${A}`);
  return e;
}
const YB = '(function(){"use strict";let MA;const Bg=typeof TextDecoder<"u"?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{decode:()=>{throw Error("TextDecoder not available")}};typeof TextDecoder<"u"&&Bg.decode();let PA=null;function Vg(){return(PA===null||PA.byteLength===0)&&(PA=new Uint8Array(MA.memory.buffer)),PA}function Og(Q,A){return Q=Q>>>0,Bg.decode(Vg().subarray(Q,Q+A))}function Pg(Q,A,I){return MA.sort_splats(Q,A,I)>>>0}function $g(Q,A,I){return MA.sort32_splats(Q,A,I)>>>0}async function AQ(Q,A){if(typeof Response=="function"&&Q instanceof Response){if(typeof WebAssembly.instantiateStreaming=="function")try{return await WebAssembly.instantiateStreaming(Q,A)}catch(g){if(Q.headers.get("Content-Type")!="application/wasm")console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n",g);else throw g}const I=await Q.arrayBuffer();return await WebAssembly.instantiate(I,A)}else{const I=await WebAssembly.instantiate(Q,A);return I instanceof WebAssembly.Instance?{instance:I,module:Q}:I}}function IQ(){const Q={};return Q.wbg={},Q.wbg.__wbg_buffer_609cc3eee51ed158=function(A){return A.buffer},Q.wbg.__wbg_length_3b4f022188ae8db6=function(A){return A.length},Q.wbg.__wbg_length_6ca527665d89694d=function(A){return A.length},Q.wbg.__wbg_length_8cfd2c6409af88ad=function(A){return A.length},Q.wbg.__wbg_new_9fee97a409b32b68=function(A){return new Uint16Array(A)},Q.wbg.__wbg_new_e3b321dcfef89fc7=function(A){return new Uint32Array(A)},Q.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354=function(A,I,g){return new Float32Array(A,I>>>0,g>>>0)},Q.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212=function(A,I,g){return new Uint32Array(A,I>>>0,g>>>0)},Q.wbg.__wbg_newwithlength_5a5efe313cfd59f1=function(A){return new Float32Array(A>>>0)},Q.wbg.__wbg_set_10bad9bee0e9c58b=function(A,I,g){A.set(I,g>>>0)},Q.wbg.__wbg_set_d23661d19148b229=function(A,I,g){A.set(I,g>>>0)},Q.wbg.__wbg_set_f4f1f0daa30696fc=function(A,I,g){A.set(I,g>>>0)},Q.wbg.__wbg_subarray_3aaeec89bb2544f0=function(A,I,g){return A.subarray(I>>>0,g>>>0)},Q.wbg.__wbg_subarray_769e1e0f81bb259b=function(A,I,g){return A.subarray(I>>>0,g>>>0)},Q.wbg.__wbindgen_init_externref_table=function(){const A=MA.__wbindgen_export_0,I=A.grow(4);A.set(0,void 0),A.set(I+0,void 0),A.set(I+1,null),A.set(I+2,!0),A.set(I+3,!1)},Q.wbg.__wbindgen_memory=function(){return MA.memory},Q.wbg.__wbindgen_throw=function(A,I){throw new Error(Og(A,I))},Q}function gQ(Q,A){return MA=Q.exports,Cg.__wbindgen_wasm_module=A,PA=null,MA.__wbindgen_start(),MA}async function Cg(Q){if(MA!==void 0)return MA;typeof Q<"u"&&(Object.getPrototypeOf(Q)===Object.prototype?{module_or_path:Q}=Q:console.warn("using deprecated parameters for the initialization function; pass a single object instead")),typeof Q>"u"&&(Q=new URL("data:application/wasm;base64,AGFzbQEAAAAB8gEjYAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AX9gAX8AYAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAR/f39/AGABbwFvYANvb38AYAFvAX9gAAF/YAAAYAd/f39/f39/AX9gAX0BfWAGf39/f39/AGAEf39/fwF/YAN/b28Bf2ABfwFvYAABb2AHf39/f39/fwBgAn9+AX9gA39+fgBgC319fX19fX19f29/AW9gBn9/f39/fwF/YAV/f31/fwBgBH99f38AYAV/f35/fwBgBH9+f38AYAV/f3x/fwBgBH98f38AYAN/fn4Bf2ACfX0BfQLyBBEDd2JnHV9fd2JnX2J1ZmZlcl82MDljYzNlZWU1MWVkMTU4AAoDd2JnGl9fd2JnX25ld185ZmVlOTdhNDA5YjMyYjY4AAoDd2JnGl9fd2JnX3NldF9mNGYxZjBkYWEzMDY5NmZjAAsDd2JnHV9fd2JnX2xlbmd0aF84Y2ZkMmM2NDA5YWY4OGFkAAwDd2JnMV9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoX2YxZGVhZDQ0ZDFmYzcyMTIABwN3YmcaX193YmdfbmV3X2UzYjMyMWRjZmVmODlmYzcACgN3YmcaX193Ymdfc2V0X2QyMzY2MWQxOTE0OGIyMjkACwN3YmcdX193YmdfbGVuZ3RoXzZjYTUyNzY2NWQ4OTY5NGQADAN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZTZiN2U2OWFjZDRjNzM1NAAHA3diZxpfX3diZ19zZXRfMTBiYWQ5YmVlMGU5YzU4YgALA3diZx1fX3diZ19sZW5ndGhfM2I0ZjAyMjE4OGFlOGRiNgAMA3diZx9fX3diZ19zdWJhcnJheV83NjllMWUwZjgxYmIyNTliAAcDd2JnH19fd2JnX3N1YmFycmF5XzNhYWVlYzg5YmIyNTQ0ZjAABwN3YmckX193YmdfbmV3d2l0aGxlbmd0aF81YTVlZmUzMTNjZmQ1OWYxABQDd2JnEF9fd2JpbmRnZW5fdGhyb3cAAgN3YmcRX193YmluZGdlbl9tZW1vcnkAFQN3YmcfX193YmluZGdlbl9pbml0X2V4dGVybnJlZl90YWJsZQAOA8ABvgEEAAAGAAQCBAEADwQE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gP4HcgwDCyADQRB0IQMgAkUNASACQQ10QYCAgPwAcSABQQ10ckGAgIDAA2ogA3IMAgtBAkECQeiJwAAQaQALIAEgAWdBEGsiAUH//wNxQQhqdEH///8DcSADQYCAgNgDciABQRd0a3ILNgIIIAAgBDYCBCAAIAU2AgALlgQBBH8jAEGAAWsiBCQAAkACQAJAIAEoAggiAkGAgIAQcUUEQCACQYCAgCBxDQFBASECIAAoAgAgARAxRQ0CDAMLIAAoAgAhAgNAIAMgBGpB/wBqIAJBD3EiBUEwciAFQdcAaiAFQQpJGzoAACADQQFrIQMgAkEQSSACQQR2IQJFDQALQQEhAiABQc++wABBAiADIARqQYABakEAIANrECBFDQEMAgsgACgCACECA0AgAyAEakH/AGogAkEPcSIFQTByIAVBN2ogBUEKSRs6AAAgA0EBayEDIAJBD0sgAkEEdiECDQALQQEhAiABQc++wABBAiADIARqQYABakEAIANrECANAQsgASgCAEG7u8AAQQIgASgCBCgCDBEBAA0AAkAgASgCCCICQYCAgBBxRQRAIAJBgICAIHENASAAKAIEIAEQMSECDAILIAAoAgQhAkEAIQMDQCADIARqQf8AaiACQQ9xIgBBMHIgAEHXAGogAEEKSRs6AAAgA0EBayEDIAJBD0sgAkEEdiECDQALIAFBz77AAEECIAMgBGpBgAFqQQAgA2sQICECDAELIAAoAgQhAkEAIQMDQCADIARqQf8AaiACQQ9xIgBBMHIgAEE3aiAAQQpJGzoAACADQQFrIQMgAkEPSyACQQR2IQINAAsgAUHPvsAAQQIgAyAEakGAAWpBACADaxAgIQILIARBgAFqJAAgAgu6BAEIfyMAQRBrIgMkACADIAE2AgQgAyAANgIAIANCoICAgA43AggCfwJAAkACQCACKAIQIgkEQCACKAIUIgANAQwCCyACKAIMIgBFDQEgAigCCCIBIABBA3RqIQQgAEEBa0H/////AXFBAWohBiACKAIAIQADQAJAIABBBGooAgAiBUUNACADKAIAIAAoAgAgBSADKAIEKAIMEQEARQ0AQQEMBQtBASABKAIAIAMgAUEEaigCABEAAA0EGiAAQQhqIQAgBCABQQhqIgFHDQALDAILIABBGGwhCiAAQQFrQf////8BcUEBaiEGIAIoAggh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EGokAAuCAwEEfyAAKAIMIQICQAJAAkAgAUGAAk8EQCAAKAIYIQMCQAJAIAAgAkYEQCAAQRRBECAAKAIUIgIbaigCACIBDQFBACECDAILIAAoAggiASACNgIMIAIgATYCCAwBCyAAQRRqIABBEGogAhshBANAIAQhBSABIgJBFGogAkEQaiACKAIUIgEbIQQgAkEUQRAgARtqKAIAIgENAAsgBUEANgIACyADRQ0CAkAgACgCHEECdEG41sAAaiIBKAIAIABHBEAgAygCECAARg0BIAMgAjYCFCACDQMMBAsgASACNgIAIAJFDQQMAgsgAyACNgIQIAINAQwCCyAAKAIIIgAgAkcEQCAAIAI2AgwgAiAANgIIDwtB0NnAAEHQ2cAAKAIAQX4gAUEDdndxNgIADwsgAiADNgIYIAAoAhAiAQRAIAIgATYCECABIAI2AhgLIAAoAhQiAEUNACACIAA2AhQgACACNgIYDwsPC0HU2cAAQdTZwAAoAgBBfiAAKAIcd3E2AgAL+QICBH8BfiMAQSBrIgIkAAJAAkACQCAAKAIAIgNFDQAgACgCCCIBIAAoAgRPDQACQAJAAkAgASADaiIDLQAAQcIARgRAIAAgAUEBajYCCCACIAAQXiACKAIADQEgACgCECIBRQ0CQZyswABBjKzAACACLQAEQQFxIgMbQRlBECADGyABEMcBRQ0CQQIhAQwGCyADLQAAQckARw0DIAAgAUEBajYCCEECIQEgAEEAEBJFDQQMBQsgACgCEEUNASAAKQIAIQUgACACKQIANwIAIAJBGGoiAyAAQQhqIgEpAgA3AwAgASACQQhqKQIANwIAIAIgBTcDECAAEDMgASADKQMANwIAIAAgAikDEDcCAEH/AXEhAQwECyAAIAIpAgA3AgAgAEEIaiACQQhqKQIANwIAC0EAIQEMAgtBAkEAIABBABASGyEBDAELIAAoAhAiAwRAQcCmwABBASADEMcBDQELQQJBASAAEDlBAXEbIQELIAJBIGokACABC/MCAgd/A34jAEEQayIEJAAgASgCACEGAkACQCABKAIIIgIgASgCBCIHSQRAIAIgBmotAABB3wBGDQELIAIgByACIAdLGyEIAkADQAJAIAIgB0kEQCACIAZqLQAAQd8ARg0DCyACIAhGDQACQCACIAZqLQAAIgVBMGsiA0H/AXFB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OgABDAILIAAgAy0AAToAAQwBC0EAIQILIAAgAjoAACADQRBqJAALqwEBAn8jAEEgayIBJAACQCAAKAIEIgJBA0YgAkECSXINAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGkiMAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGIicAAEIABAAsgAEEIahBLIAAoAggiAkUNACAAKAIMIAJBDGxBBBCsAQsgACgCHCICBEAgACgCICACQQEQrAELIABBKEEEEKwBIAFBIGokAAuiAQICfwF+IwBBEGsiAiQAIAEoAgghAyACIAEQNAJAIAItAABBAUYEQCACLQABIQEgAEEANgIAIAAgAToABAwBCyACKQMIIgQgA0EBa61UBEAgASgCDEEBaiIDQfQDTQRAIAAgAzYCDCAAIAQ+AgggACABKQIANwIADAILIABBADYCACAAQQE6AAQMAQsgAEEANgIAIABBADoABAsgAkEQaiQAC5sBAgR/AW8jAEEgayIDJAAgACgCACIGEMsBIQAgAyACNgIEIAMgADYCACAAIAJGBEAQmgEiBBCSASIFJQEgASACEAQhBxBWIgAgByYBIARBhAFPBEAgBBBVCyAFQYQBTwRAIAUQVQsgBiAAQQAQqwEgAEGEAU8EQCAAEFULIANBIGokAA8LIANBADYCCCADIANBBGogA0EIahB8AAuUAQEDfyMAQRBrIgIkAAJ/QQEgASgCACIDQScgASgCBCIEKAIQIgERAAANABogAkEEaiAAKAIAQYECEB8CQCACLQAEQYABRgRAIAMgAigCCCABEQAARQ0BQQEMAgsgAyACLQAOIgAgAkEEamogAi0ADyAAayAEKAIMEQEARQ0AQQEMAQsgA0EnIAERAAALIAJBEGokAAuiAQECfyMAQSBrIgEkAAJAIAAoAgQiAkEDRiACQQJJcg0AAkACQCAALQAYQQFrDgICAAELIAFBATYCCCABQaSIwAA2AgQgAUIANwIQIAEgAUEcajYCDCABQQRqQYiJwAAQgAEACyAAQQhqEEsgACgCCCICRQ0AIAAoAgwgAkEMbEEEEKwBCyAAKAIcIgIEQCAAKAIgIAJBARCsAQsgAUEgaiQAC5UBAQN/An8CQAJAIAEoAgAiA0UEQAwBCwNAAkAgASgCCCIEIAEoAgRPDQAgAyAEai0AAEHFAEcNACABIARBAWo2AggMAgsCQCACRQ0AIAEoAhAiA0UNAEG9rMAAQQIgAxDHAQ0DCyABEBYNAiACQQFqIQIgASgCACIDDQALC0EADAELQQELIQEgACACNgIEIAAgATYCAAuVAQECfyMAQSBrIgMkAAJAIAAoAgQiBEEDRiAEQQJJcg0AAkACQCAALQAYQQFrDgICAAELIANBATYCCCADQaSIwAA2AgQgA0IANwIQIAMgA0EcajYCDCADQQRqQYiJwAAQgAEACyAAQQhqEEsgACgCCCIERQ0AIAAoAgwgBEEMbEEEEKwBCyAAQShBBBCsASADQSBqJAALhAEBA38CfwJAIAAoAgAiAUUNAANAAkAgACgCCCIDIAAoAgRPDQAgASADai0AAEHFAEcNACAAIANBAWo2AggMAgsCQCACRQ0AIAAoAhAiAUUNAEG9rMAAQQIgARDHAUUNAEEBDwtBASAAQQEQEw0CGiACQQFrIQIgACgCACIBDQALC0EACwt6AQF/IwBBIGsiAiQAAn8gACgCAEGAgICAeEcEQCABIAAoAgQgACgCCBCWAQwBCyACQRBqIAAoAgwoAgAiAEEIaikCADcDACACQRhqIABBEGopAgA3AwAgAiAAKQIANwMIIAEoAgAgASgCBCACQQhqECYLIAJBIGokAAt8AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQQI2AhwgBUGUvsAANgIYIAVCAjcCJCAFIAVBEGqtQoCAgIDAC4Q3AzggBSAFQQhqrUKAgICA0AuENwMwIAUgBUEwajYCICAFQRhqIAQQgAEAC3gBA38CQCAAKAIAIgFBgICAgHhHBEAgAUUNASAAKAIEIAFBARCsAQ8LIAAtAARBA0cNACAAKAIIIgAoAgAhASAAQQRqKAIAIgMoAgAiAgRAIAEgAhEFAAsgAygCBCICBEAgASACIAMoAggQrAELIABBDEEEEKwBCwtuAQF/IwBBEGsiACQAIAACfyACKAIABEBBxJzAACEDQQkMAQsgAEEEaiACKAIEIAIoAggQIUHEnMAAIAAoAgggACgCBCICGyEDQQkgACgCDCACGws2AgggACADNgIEIABBBGogARBaIABBEGokAAtpAgF/AX4jAEEwayIDJAAgAyABNgIEIAMgADYCACADQQI2Agwg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A3FBAXQiBEHSvsAAai0AADoAACACQQJrIARB0b7AAGotAAA6AAAgAEEEayEAIAhC/6ziBFYgByEIDQALCyAHQglWBEAgACADakELaiAHpyICIAJB//8DcUHkAG4iAkHkAGxrQf//A3FBAXQiBEHSvsAAai0AADoAACAAQQJrIgAgA0EMamogBEHRvsAAai0AADoAACACrSEHCyAJUEUgB1BxRQRAIABBAWsiACADQQxqaiAHp0EBdEEecUHSvsAAai0AADoAAAsgAUEBQQAgA0EMaiAAakEUIABrECAgA0EgaiQACw0AIABB5IrAACABECYLCgAgACABIAIQJgsOACABQfCMwABBBRCWAQvCAwIGfwF+IAAoAgAhACMAQdAAayICJAAgAkEgaiAAIAAoAgAoAgQRAgAgAiACQcgAaq1CgICAgMADhDcDKEEBIQMgAkEBNgI0IAJB1I7AADYCMCACQgE3AjwgAiACKQMgNwJIIAIgAkEoajYCOAJAIAEoAgAiBiABKAIEIgcgAkEwahAmDQAgAS0ACkGAAXFFBEBBACEDDAELIAJBGGogACAAKAIAKAIEEQIAIAJBEGogAigCGCACKAIcKAIYEQIAIAIoAhAiBEUEQEEAIQMMAQsgAkEIaiAEIAIoAhQiBSgCGBECACACKAIMIQEgAigCCCEAIAIgBTYCLCACIAQ2AiggAkEBNgI0IAJB4I7AADYCMCACQgE3AjwgAiACQShqrUKAgICAwAOEIgg3A0ggAiACQcgAajYCOCAGIAcgAkEwahC1AQ0AA0AgAEUEQEEAIQMMAgsgAiAAIAEoAhgRAgAgAigCBCACKAIAIAIgATYCLCACIAA2AiggAkEBNgI0IAJB4I7AADYCMCACQgE3AjwgAiAINwNIIAIgAkHIAGo2AjghACEBIAYgByACQTBqELUBRQ0ACwsgAkHQAGokACADCw0AIABBmJLAACABECYLCQAgACABEA4ACykAAn8gACgCAC0AAEUEQCABQbTAwABBBRAjDAELIAFBucDAAEEEECMLCw0AIABB9JfAACABECYLygECA38BfiAAKAIAIQIjAEGAAWsiBCQAAkAgASkCCCIFpyIAQYCAgARxRQ0AIABBgICAwABxBEAgAEGAgIAIciEADAELIAFBCjsBDCAAQYCAgMgAciEACyABIABBgICABHI2AghBACEAA0AgACAEakH/AGogAkEPcSIDQTByIANB1wBqIANBCkkbOgAAIABBAWshACACQQ9LIAJBBHYhAg0ACyABQc++wABBAiAAIARqQYABakEAIABrECAgASAFNwIIIARBgAFqJAALDAAgACABKQIANwMAC8IYAhN/AX4gACgCACEAIwBBIGsiECQAAn8gACgCAEUEQCAQQQA2AhwgECABNgIYIBBCADcCECAQIAApAgQ3AgggEEEIakEBEBIMAQsgASEKIwBBEGsiDSQAIAAoAgghEiAAKAIEIQ8gACgCACEIAkACQAJAA0AgFCIGIBJJIRMgBiASTw0CIAghAQJAAkAgD0UNACAGQQFqIgsgBiATGyEUIA9BAWshCCABLQAAIQRBACEDAkACQANAAkACQCAEwEEASARAIARBH3EhByABIANqIgJBAWotAABBP3EhBSAEQf8BcSIAQd8BSw0BIAdBBnQgBXIhAgwCCyAEQf8BcSECDAELIAJBAmotAABBP3EgBUEGdHIhBSAAQfABSQRAIAUgB0EMdHIhAgwBCyAHQRJ0QYCA8ABxIAJBA2otAABBP3EgBUEGdHJyIgJBgIDEAEYNBAsgAkEwa0EKSQRAIAMgCEYNBCABIANqIgBBAWosAAAiBEG/f0wNAiADQQFqIQMMAQsLIAMNAUEAIQAMBQsgACAPIANrIgBBASAAQYSlwAAQmQEACyABIANqIgksAABBv39KDQEgASAPQQAgA0GUpcAAEJkBAAtB9KTAABCyAQALIAEtAAAhCAJAAkACQAJAIANBAUYEQEEBIQAgASECIAhBK2sOAwYBBgELIAhBK0YEQCADQQFrIQAgAUEBaiECIANBCkkNAQwCCyABIQIgAyEAIANBCU8NAQtBACEFA0AgAi0AAEEwayIIQQlLDQIgAkEBaiECIAggBUEKbGohBSAAQQFrIgANAAsMAgtBACEFIAAhCANAIAhFDQIgAi0AAEEwayIOQQlLDQFBAiEAIAWtQgp+IhVCIIinDQQgAkEBaiECIAhBAWshCCAOIBWnIgdqIgUgB08NAAsMAwtBASEADAILIA8gBWshBwJAAkACQAJAIAVFDQAgDyADayIIIAVNBEAgAyAHRg0BDAQLIAEgBWogA2oiACwAAEFASA0DIAAsAABBv39MDQELIAEgBWogA2ohCCALIBJH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bGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5L3J1c3RjLzZiMDBiYzM4ODAxOTg2MDAxMzBlMWNmNjJiOGY4YTkzNDk0NDg4Y2MvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAAATBhAASwAAAPAKAAAOAAAARXJyb3Jhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbikAAAATBhAASwAAALUFAAANAAAAAAAAABAAAAAEAAAAGQAAABoAAAAbAAAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYW55aG93LTEuMC45OC9zcmMvZXJyb3IucnPoBhAAXAAAAGcEAAAOAAAAAQAAAAAAAAA6IAAAXAcQAAIAAAAKCkNhdXNlZCBieToKAAAAdAcQAAEAAAAKCnN0YWNrIGJhY2t0cmFjZTpTdGFjayBiYWNrdHJhY2U6CgCSBxAAEQAAAFMvcnVzdGMvNmIwMGJjMzg4MDE5ODYwMDEzMGUxY2Y2MmI4ZjhhOTM0OTQ0ODhjYy9saWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjL21vZC5ycwAAAK0HEABQAAAALgIAABEAAAAvcnVzdGMvNmIwMGJjMzg4MDE5ODYwMDEzMGUxY2Y2MmI4ZjhhOTM0OTQ0ODhjYy9saWJyYXJ5L2NvcmUvc3JjL3NsaWNlL2luZGV4LnJzABAIEABPAAAATAMAADQAAAAQCBAATwAAAFMDAAAyAAAAYXNzZXJ0aW9uIGZhaWxlZDogc2VsZi5pc19jaGFyX2JvdW5kYXJ5KG4pL3J1c3RjLzZiMDBiYzM4ODAxOTg2MDAxMzBlMWNmNjJiOGY4YTkzNDk0NDg4Y2MvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAAAAqggQAEsAAAAMCAAAHQAAAKoIEABLAAAAFAgAAB0AAAAjAAAADAAAAAQAAAAkAAAAJQAAACEAAAAvcnVzdGMvNmIwMGJjMzg4MDE5ODYwMDEzMGUxY2Y2MmI4ZjhhOTM0OTQ0ODhjYy9saWJyYXJ5L2NvcmUvc3JjL2l0ZXIvdHJhaXRzL2l0ZXJhdG9yLnJzMAkQAFgAAADRBwAACQAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2pzLXN5cy0wLjMuNzcvc3JjL2xpYi5ycwAAmAkQAFoAAAD7GAAAAQAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3dhc20tYmluZGdlbi0wLjIuMTAwL3NyYy9jb252ZXJ0L3NsaWNlcy5ycwQKEABsAAAAJAEAAA4AAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZExhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZLIKEAAqAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvb25jZV9jZWxsLTEuMjEuMy9zcmMvbGliLnJzAAAA5AoQAF0AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AABUCxAADgAAAOQKEABdAAAAegIAAA0AAAA6IAAAAAAAAAQAAAAEAAAANwAAAC9ydXN0Yy82YjAwYmMzODgwMTk4NjAwMTMwZTFjZjYyYjhmOGE5MzQ5NDQ4OGNjL2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMvbW9kLnJzkAsQAFAAAAAuAgAAEQAAADoAAAA4AAAADAAAAAQAAAA5AAAAOgAAADsAAAAvcnVzdC9kZXBzL2RsbWFsbG9jLTAuMi44L3NyYy9kbG1hbGxvYy5yc2Fzc2VydGlvbiBmYWlsZWQ6IHBzaXplID49IHNpemUgKyBtaW5fb3ZlcmhlYWQADAwQACkAAACsBAAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IHBzaXplIDw9IHNpemUgKyBtYXhfb3ZlcmhlYWQAAAwMEAApAAAAsgQAAA0AAABsaWJyYXJ5L3N0ZC9zcmMvc3luYy9sYXp5X2xvY2sucnMAAAC0DBAAIQAAANEAAAATAAAAbGlicmFyeS9z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",self.location.href));const A=IQ();(typeof Q=="string"||typeof Request=="function"&&Q instanceof Request||typeof URL=="function"&&Q instanceof URL)&&(Q=fetch(Q));const{instance:I,module:g}=await AQ(await Q,A);return gQ(I,g)}var Eg={},QQ=function(Q,A,I,g,B){var C=new Worker(Eg[A]||(Eg[A]=URL.createObjectURL(new Blob([Q+\';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})\'],{type:"text/javascript"}))));return C.onmessage=function(t){var E=t.data,i=E.$e$;if(i){var s=new Error(i[0]);s.code=i[1],s.stack=i[2],B(s,null)}else B(null,E)},C.postMessage(I,g),C},W=Uint8Array,LA=Uint16Array,tg=Int32Array,RI=new W([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),UI=new W([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),ig=new W([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),sg=function(Q,A){for(var I=new LA(31),g=0;g<31;++g)I[g]=A+=1<<Q[g-1];for(var B=new tg(I[30]),g=1;g<30;++g)for(var C=I[g];C<I[g+1];++C)B[C]=C-I[g]<<5|g;return{b:I,r:B}},eg=sg(RI,2),JI=eg.b,BQ=eg.r;JI[28]=258,BQ[258]=28;for(var CQ=sg(UI,0),ng=CQ.b,iI=new LA(32768),v=0;v<32768;++v){var SA=(v&43690)>>1|(v&21845)<<1;SA=(SA&52428)>>2|(SA&13107)<<2,SA=(SA&61680)>>4|(SA&3855)<<4,iI[v]=((SA&65280)>>8|(SA&255)<<8)>>1}for(var bA=function(Q,A,I){for(var g=Q.length,B=0,C=new LA(A);B<g;++B)Q[B]&&++C[Q[B]-1];var t=new LA(A);for(B=1;B<A;++B)t[B]=t[B-1]+C[B-1]<<1;var E;if(I){E=new LA(1<<A);var i=15-A;for(B=0;B<g;++B)if(Q[B])for(var s=B<<4|Q[B],n=A-Q[B],e=t[Q[B]-1]++<<n,a=e|(1<<n)-1;e<=a;++e)E[iI[e]>>i]=s}else for(E=new LA(g),B=0;B<g;++B)Q[B]&&(E[B]=iI[t[Q[B]-1]++]>>15-Q[B]);return E},$A=new W(288),v=0;v<144;++v)$A[v]=8;for(var v=144;v<256;++v)$A[v]=9;for(var v=256;v<280;++v)$A[v]=7;for(var v=280;v<288;++v)$A[v]=8;for(var og=new W(32),v=0;v<32;++v)og[v]=5;var ag=bA($A,9,1),rg=bA(og,5,1),sI=function(Q){for(var A=Q[0],I=1;I<Q.length;++I)Q[I]>A&&(A=Q[I]);return A},oA=function(Q,A,I){var g=A/8|0;return(Q[g]|Q[g+1]<<8)>>(A&7)&I},eI=function(Q,A){var I=A/8|0;return(Q[I]|Q[I+1]<<8|Q[I+2]<<16)>>(A&7)},YI=function(Q){return(Q+7)/8|0},kA=function(Q,A,I){return(A==null||A<0)&&(A=0),(I==null||I>Q.length)&&(I=Q.length),new W(Q.subarray(A,I))},hg=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],O=function(Q,A,I){var g=new Error(A||hg[Q]);if(g.code=Q,Error.captureStackTrace&&Error.captureStackTrace(g,O),!I)throw g;return g},xI=function(Q,A,I,g){var B=Q.length,C=g?g.length:0;if(!B||A.f&&!A.l)return I||new W(0);var t=!I,E=t||A.i!=2,i=A.i;t&&(I=new W(B*3));var s=function(EA){var iA=I.length;if(EA>iA){var sA=new W(Math.max(iA*2,EA));sA.set(I),I=sA}},n=A.f||0,e=A.p||0,a=A.b||0,o=A.l,r=A.d,c=A.m,N=A.n,h=B*8;do{if(!o){n=oA(Q,e,1);var w=oA(Q,e+1,3);if(e+=3,w)if(w==1)o=ag,r=rg,c=9,N=5;else if(w==2){var R=oA(Q,e,31)+257,d=oA(Q,e+10,15)+4,G=R+oA(Q,e+5,31)+1;e+=14;for(var l=new W(G),k=new W(19),F=0;F<d;++F)k[ig[F]]=oA(Q,e+F*3,7);e+=d*3;for(var y=sI(k),U=(1<<y)-1,H=bA(k,y,1),F=0;F<G;){var K=H[oA(Q,e,U)];e+=K&15;var D=K>>4;if(D<16)l[F++]=D;else{var x=0,z=0;for(D==16?(z=3+oA(Q,e,3),e+=2,x=l[F-1]):D==17?(z=3+oA(Q,e,7),e+=3):D==18&&(z=11+oA(Q,e,127),e+=7);z--;)l[F++]=x}}var j=l.subarray(0,R),Z=l.subarray(R);c=sI(j),N=sI(Z),o=bA(j,c,1),r=bA(Z,N,1)}else O(1);else{var D=YI(e)+4,M=Q[D-4]|Q[D-3]<<8,u=D+M;if(u>B){i&&O(0);break}E&&s(a+M),I.set(Q.subarray(D,u),a),A.b=a+=M,A.p=e=u*8,A.f=n;continue}if(e>h){i&&O(0);break}}E&&s(a+131072);for(var P=(1<<c)-1,V=(1<<N)-1,_=e;;_=e){var x=o[eI(Q,e)&P],q=x>>4;if(e+=x&15,e>h){i&&O(0);break}if(x||O(2),q<256)I[a++]=q;else if(q==256){_=e,o=null;break}else{var b=q-254;if(q>264){var F=q-257,J=RI[F];b=oA(Q,e,(1<<J)-1)+JI[F],e+=J}var T=r[eI(Q,e)&V],f=T>>4;T||O(3),e+=T&15;var Z=ng[f];if(f>3){var J=UI[f];Z+=eI(Q,e)&(1<<J)-1,e+=J}if(e>h){i&&O(0);break}E&&s(a+131072);var CA=a+b;if(a<Z){var BA=C-Z,nA=Math.min(Z,CA);for(BA+a<0&&O(3);a<nA;++a)I[a]=g[BA+a]}for(;a<CA;++a)I[a]=I[a-Z]}}A.l=o,A.p=_,A.b=a,A.f=n,o&&(n=1,A.m=c,A.d=r,A.n=N)}while(!n);return a!=I.length&&t?kA(I,0,a):I.subarray(0,a)},EQ=new W(0),tQ=function(Q,A){var I={};for(var g in Q)I[g]=Q[g];for(var g in A)I[g]=A[g];return I},cg=function(Q,A,I){for(var g=Q(),B=Q.toString(),C=B.slice(B.indexOf("[")+1,B.lastIndexOf("]")).replace(/\\s+/g,"").split(","),t=0;t<g.length;++t){var E=g[t],i=C[t];if(typeof E=="function"){A+=";"+i+"=";var s=E.toString();if(E.prototype)if(s.indexOf("[native code]")!=-1){var n=s.indexOf(" ",8)+1;A+=s.slice(n,s.indexOf("(",n))}else{A+=s;for(var e in E.prototype)A+=";"+i+".prototype."+e+"="+E.prototype[e].toString()}else A+=s}else I[i]=E}return A},nI=[],iQ=function(Q){var A=[];for(var I in Q)Q[I].buffer&&A.push((Q[I]=new Q[I].constructor(Q[I])).buffer);return A},sQ=function(Q,A,I,g){if(!nI[I]){for(var B="",C={},t=Q.length-1,E=0;E<t;++E)B=cg(Q[E],B,C);nI[I]={c:cg(Q[t],B,C),e:C}}var i=tQ({},nI[I].e);return QQ(nI[I].c+";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage="+A.toString()+"}",I,i,iQ(i),g)},eQ=function(){return[W,LA,tg,RI,UI,ig,JI,ng,ag,rg,iI,hg,bA,sI,oA,eI,YI,kA,O,xI,oI,Dg,wg]},Dg=function(Q){return postMessage(Q,[Q.buffer])},wg=function(Q){return Q&&{out:Q.size&&new W(Q.size),dictionary:Q.dictionary}},nQ=function(Q,A,I,g,B,C){var t=sQ(I,g,B,function(E,i){t.terminate(),C(E,i)});return t.postMessage([Q,A],A.consume?[Q.buffer]:[]),function(){t.terminate()}},cA=function(Q,A){return Q[A]|Q[A+1]<<8},gA=function(Q,A){return(Q[A]|Q[A+1]<<8|Q[A+2]<<16|Q[A+3]<<24)>>>0},mI=function(Q,A){return gA(Q,A)+gA(Q,A+4)*4294967296},oQ=function(Q){(Q[0]!=31||Q[1]!=139||Q[2]!=8)&&O(6,"invalid gzip data");var A=Q[3],I=10;A&4&&(I+=(Q[10]|Q[11]<<8)+2);for(var g=(A>>3&1)+(A>>4&1);g>0;g-=!Q[I++]);return I+(A&2)},LI=function(){function Q(A,I){typeof A=="function"&&(I=A,A={}),this.ondata=I;var g=A&&A.dictionary&&A.dictionary.subarray(-32768);this.s={i:0,b:g?g.length:0},this.o=new W(32768),this.p=new W(0),g&&this.o.set(g)}return Q.prototype.e=function(A){if(this.ondata||O(5),this.d&&O(4),!this.p.length)this.p=A;else if(A.length){var I=new W(this.p.length+A.length);I.set(this.p),I.set(A,this.p.length),this.p=I}},Q.prototype.c=function(A){this.s.i=+(this.d=A||!1);var I=this.s.b,g=xI(this.p,this.s,this.o);this.ondata(kA(g,I,this.s.b),this.d),this.o=kA(g,this.s.b-32768),this.s.b=this.o.length,this.p=kA(this.p,this.s.p/8|0),this.s.p&=7},Q.prototype.push=function(A,I){this.e(A),this.c(I)},Q}();function aQ(Q,A,I){return I||(I=A,A={}),typeof I!="function"&&O(7),nQ(Q,A,[eQ],function(g){return Dg(oI(g.data[0],wg(g.data[1])))},1,I)}function oI(Q,A){return xI(Q,{i:2},A&&A.out,A&&A.dictionary)}var yg=function(){function Q(A,I){this.v=1,this.r=0,LI.call(this,A,I)}return Q.prototype.push=function(A,I){if(LI.prototype.e.call(this,A),this.r+=A.length,this.v){var g=this.p.subarray(this.v-1),B=g.length>3?oQ(g):4;if(B>g.length){if(!I)return}else this.v>1&&this.onmember&&this.onmember(this.r-g.length);this.p=g.subarray(B),this.v=0}LI.prototype.c.call(this,I),this.s.f&&!this.s.l&&!I&&(this.v=YI(this.s.p)+9,this.s={i:0},this.o=new W(0),this.push(new W(0),I))},Q}(),dI=typeof TextDecoder<"u"&&new TextDecoder;try{dI.decode(EQ,{stream:!0})}catch{}var rQ=function(Q){for(var A="",I=0;;){var g=Q[I++],B=(g>127)+(g>223)+(g>239);if(I+B>Q.length)return{s:A,r:kA(Q,I-1)};B?B==3?(g=((g&15)<<18|(Q[I++]&63)<<12|(Q[I++]&63)<<6|Q[I++]&63)-65536,A+=String.fromCharCode(55296|g>>10,56320|g&1023)):B&1?A+=String.fromCharCode((g&31)<<6|Q[I++]&63):A+=String.fromCharCode((g&15)<<12|(Q[I++]&63)<<6|Q[I++]&63):A+=String.fromCharCode(g)}};function hQ(Q,A){if(A){for(var I="",g=0;g<Q.length;g+=16384)I+=String.fromCharCode.apply(null,Q.subarray(g,g+16384));return I}else{if(dI)return dI.decode(Q);var B=rQ(Q),C=B.s,I=B.r;return I.length&&O(8),C}}var lg=function(Q,A){return A+30+cA(Q,A+26)+cA(Q,A+28)},Ng=function(Q,A,I){var g=cA(Q,A+28),B=hQ(Q.subarray(A+46,A+46+g),!(cA(Q,A+8)&2048)),C=A+46+g,t=gA(Q,A+20),E=I&&t==4294967295?cQ(Q,C):[t,gA(Q,A+24),gA(Q,A+42)],i=E[0],s=E[1],n=E[2];return[cA(Q,A+10),i,s,B,C+cA(Q,A+30)+cA(Q,A+32),n]},cQ=function(Q,A){for(;cA(Q,A)!=1;A+=4+cA(Q,A+2));return[mI(Q,A+12),mI(Q,A+4),mI(Q,A+20)]},Mg=typeof queueMicrotask=="function"?queueMicrotask:typeof setTimeout=="function"?setTimeout:function(Q){Q()};function DQ(Q,A,I){I||(I=A,A={}),typeof I!="function"&&O(7);var g=[],B=function(){for(var N=0;N<g.length;++N)g[N]()},C={},t=function(N,h){Mg(function(){I(N,h)})};Mg(function(){t=I});for(var E=Q.length-22;gA(Q,E)!=101010256;--E)if(!E||Q.length-E>65558)return t(O(13,0,1),null),B;var i=cA(Q,E+8);if(i){var s=i,n=gA(Q,E+16),e=n==4294967295||s==65535;if(e){var a=gA(Q,E-12);e=gA(Q,a)==101075792,e&&(s=i=gA(Q,a+32),n=gA(Q,a+48))}for(var o=A&&A.filter,r=function(N){var h=Ng(Q,n,e),w=h[0],D=h[1],M=h[2],u=h[3],R=h[4],d=h[5],G=lg(Q,d);n=R;var l=function(F,y){F?(B(),t(F,null)):(y&&(C[u]=y),--i||t(null,C))};if(!o||o({name:u,size:D,originalSize:M,compression:w}))if(!w)l(null,kA(Q,G,G+D));else if(w==8){var k=Q.subarray(G,G+D);if(M<524288||D>.8*M)try{l(null,oI(k,{out:new W(M)}))}catch(F){l(F,null)}else g.push(aQ(k,{size:M},l))}else l(O(14,"unknown compression type "+w,1),null);else l(null,null)},c=0;c<s;++c)r(c)}else t(null,{});return B}function wQ(Q,A){for(var I={},g=Q.length-22;gA(Q,g)!=101010256;--g)(!g||Q.length-g>65558)&&O(13);var B=cA(Q,g+8);if(!B)return{};var C=gA(Q,g+16),t=C==4294967295||B==65535;if(t){var E=gA(Q,g-12);t=gA(Q,E)==101075792,t&&(B=gA(Q,E+32),C=gA(Q,E+48))}for(var i=A&&A.filter,s=0;s<B;++s){var n=Ng(Q,C,t),e=n[0],a=n[1],o=n[2],r=n[3],c=n[4],N=n[5],h=lg(Q,N);C=c,(!i||i({name:r,size:a,originalSize:o,compression:e}))&&(e?e==8?I[r]=oI(Q.subarray(h,h+a),{out:new W(o)}):O(14,"unknown compression type "+e):I[r]=kA(Q,h,h+a))}return I}/**\n * @license\n * Copyright 2010-2024 Three.js Authors\n * SPDX-License-Identifier: MIT\n */const Fg="172",yQ="",DA="srgb",Gg="srgb-linear",ug="linear",pI="srgb";function tA(Q,A,I){return Math.max(A,Math.min(I,Q))}function lQ(Q,A){return(Q%A+A)%A}function HI(Q,A,I){return(1-I)*Q+I*A}class AI{constructor(A,I,g,B,C,t,E,i,s){AI.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],A!==void 0&&this.set(A,I,g,B,C,t,E,i,s)}set(A,I,g,B,C,t,E,i,s){const n=this.elements;return n[0]=A,n[1]=B,n[2]=E,n[3]=I,n[4]=C,n[5]=i,n[6]=g,n[7]=t,n[8]=s,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(A){const I=this.elements,g=A.elements;return I[0]=g[0],I[1]=g[1],I[2]=g[2],I[3]=g[3],I[4]=g[4],I[5]=g[5],I[6]=g[6],I[7]=g[7],I[8]=g[8],this}extractBasis(A,I,g){return A.setFromMatrix3Column(this,0),I.setFromMatrix3Column(this,1),g.setFromMatrix3Column(this,2),this}setFromMatrix4(A){const I=A.elements;return this.set(I[0],I[4],I[8],I[1],I[5],I[9],I[2],I[6],I[10]),this}multiply(A){return this.multiplyMatrices(this,A)}premultiply(A){return this.multiplyMatrices(A,this)}multiplyMatrices(A,I){const g=A.elements,B=I.elements,C=this.elements,t=g[0],E=g[3],i=g[6],s=g[1],n=g[4],e=g[7],a=g[2],o=g[5],r=g[8],c=B[0],N=B[3],h=B[6],w=B[1],D=B[4],M=B[7],u=B[2],R=B[5],d=B[8];return C[0]=t*c+E*w+i*u,C[3]=t*N+E*D+i*R,C[6]=t*h+E*M+i*d,C[1]=s*c+n*w+e*u,C[4]=s*N+n*D+e*R,C[7]=s*h+n*M+e*d,C[2]=a*c+o*w+r*u,C[5]=a*N+o*D+r*R,C[8]=a*h+o*M+r*d,this}multiplyScalar(A){const I=this.elements;return I[0]*=A,I[3]*=A,I[6]*=A,I[1]*=A,I[4]*=A,I[7]*=A,I[2]*=A,I[5]*=A,I[8]*=A,this}determinant(){const A=this.elements,I=A[0],g=A[1],B=A[2],C=A[3],t=A[4],E=A[5],i=A[6],s=A[7],n=A[8];return I*t*n-I*E*s-g*C*n+g*E*i+B*C*s-B*t*i}invert(){const A=this.elements,I=A[0],g=A[1],B=A[2],C=A[3],t=A[4],E=A[5],i=A[6],s=A[7],n=A[8],e=n*t-E*s,a=E*i-n*C,o=s*C-t*i,r=I*e+g*a+B*o;if(r===0)return this.set(0,0,0,0,0,0,0,0,0);const c=1/r;return A[0]=e*c,A[1]=(B*s-n*g)*c,A[2]=(E*g-B*t)*c,A[3]=a*c,A[4]=(n*I-B*i)*c,A[5]=(B*C-E*I)*c,A[6]=o*c,A[7]=(g*i-s*I)*c,A[8]=(t*I-g*C)*c,this}transpose(){let A;const I=this.elements;return A=I[1],I[1]=I[3],I[3]=A,A=I[2],I[2]=I[6],I[6]=A,A=I[5],I[5]=I[7],I[7]=A,this}getNormalMatrix(A){return this.setFromMatrix4(A).invert().transpose()}transposeIntoArray(A){const I=this.elements;return A[0]=I[0],A[1]=I[3],A[2]=I[6],A[3]=I[1],A[4]=I[4],A[5]=I[7],A[6]=I[2],A[7]=I[5],A[8]=I[8],this}setUvTransform(A,I,g,B,C,t,E){const i=Math.cos(C),s=Math.sin(C);return this.set(g*i,g*s,-g*(i*t+s*E)+t+A,-B*s,B*i,-B*(-s*t+i*E)+E+I,0,0,1),this}scale(A,I){return this.premultiply(KI.makeScale(A,I)),this}rotate(A){return this.premultiply(KI.makeRotation(-A)),this}translate(A,I){return this.premultiply(KI.makeTranslation(A,I)),this}makeTranslation(A,I){return A.isVector2?this.set(1,0,A.x,0,1,A.y,0,0,1):this.set(1,0,A,0,1,I,0,0,1),this}makeRotation(A){const I=Math.cos(A),g=Math.sin(A);return this.set(I,-g,0,g,I,0,0,0,1),this}makeScale(A,I){return this.set(A,0,0,0,I,0,0,0,1),this}equals(A){const I=this.elements,g=A.elements;for(let B=0;B<9;B++)if(I[B]!==g[B])return!1;return!0}fromArray(A,I=0){for(let g=0;g<9;g++)this.elements[g]=A[g+I];return this}toArray(A=[],I=0){const g=this.elements;return A[I]=g[0],A[I+1]=g[1],A[I+2]=g[2],A[I+3]=g[3],A[I+4]=g[4],A[I+5]=g[5],A[I+6]=g[6],A[I+7]=g[7],A[I+8]=g[8],A}clone(){return new this.constructor().fromArray(this.elements)}}const KI=new AI,fg=new AI().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),Sg=new AI().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function NQ(){const Q={enabled:!0,workingColorSpace:Gg,spaces:{},convert:function(B,C,t){return this.enabled===!1||C===t||!C||!t||(this.spaces[C].transfer===pI&&(B.r=qA(B.r),B.g=qA(B.g),B.b=qA(B.b)),this.spaces[C].primaries!==this.spaces[t].primaries&&(B.applyMatrix3(this.spaces[C].toXYZ),B.applyMatrix3(this.spaces[t].fromXYZ)),this.spaces[t].transfer===pI&&(B.r=zA(B.r),B.g=zA(B.g),B.b=zA(B.b))),B},fromWorkingColorSpace:function(B,C){return this.convert(B,this.workingColorSpace,C)},toWorkingColorSpace:function(B,C){return this.convert(B,C,this.workingColorSpace)},getPrimaries:function(B){return this.spaces[B].primaries},getTransfer:function(B){return B===yQ?ug:this.spaces[B].transfer},getLuminanceCoefficients:function(B,C=this.workingColorSpace){return B.fromArray(this.spaces[C].luminanceCoefficients)},define:function(B){Object.assign(this.spaces,B)},_getMatrix:function(B,C,t){return B.copy(this.spaces[C].toXYZ).multiply(this.spaces[t].fromXYZ)},_getDrawingBufferColorSpace:function(B){return this.spaces[B].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(B=this.workingColorSpace){return this.spaces[B].workingColorSpaceConfig.unpackColorSpace}},A=[.64,.33,.3,.6,.15,.06],I=[.2126,.7152,.0722],g=[.3127,.329];return Q.define({[Gg]:{primaries:A,whitePoint:g,transfer:ug,toXYZ:fg,fromXYZ:Sg,luminanceCoefficients:I,workingColorSpaceConfig:{unpackColorSpace:DA},outputColorSpaceConfig:{drawingBufferColorSpace:DA}},[DA]:{primaries:A,whitePoint:g,transfer:pI,toXYZ:fg,fromXYZ:Sg,luminanceCoefficients:I,outputColorSpaceConfig:{drawingBufferColorSpace:DA}}}),Q}const wA=NQ();function qA(Q){return Q<.04045?Q*.0773993808:Math.pow(Q*.9478672986+.0521327014,2.4)}function zA(Q){return Q<.0031308?Q*12.92:1.055*Math.pow(Q,.41666)-.055}class RA{constructor(A=0,I=0,g=0,B=1){this.isQuaternion=!0,this._x=A,this._y=I,this._z=g,this._w=B}static slerpFlat(A,I,g,B,C,t,E){let i=g[B+0],s=g[B+1],n=g[B+2],e=g[B+3];const a=C[t+0],o=C[t+1],r=C[t+2],c=C[t+3];if(E===0){A[I+0]=i,A[I+1]=s,A[I+2]=n,A[I+3]=e;return}if(E===1){A[I+0]=a,A[I+1]=o,A[I+2]=r,A[I+3]=c;return}if(e!==c||i!==a||s!==o||n!==r){let N=1-E;const h=i*a+s*o+n*r+e*c,w=h>=0?1:-1,D=1-h*h;if(D>Number.EPSILON){const u=Math.sqrt(D),R=Math.atan2(u,h*w);N=Math.sin(N*R)/u,E=Math.sin(E*R)/u}const M=E*w;if(i=i*N+a*M,s=s*N+o*M,n=n*N+r*M,e=e*N+c*M,N===1-E){const u=1/Math.sqrt(i*i+s*s+n*n+e*e);i*=u,s*=u,n*=u,e*=u}}A[I]=i,A[I+1]=s,A[I+2]=n,A[I+3]=e}static multiplyQuaternionsFlat(A,I,g,B,C,t){const E=g[B],i=g[B+1],s=g[B+2],n=g[B+3],e=C[t],a=C[t+1],o=C[t+2],r=C[t+3];return A[I]=E*r+n*e+i*o-s*a,A[I+1]=i*r+n*a+s*e-E*o,A[I+2]=s*r+n*o+E*a-i*e,A[I+3]=n*r-E*e-i*a-s*o,A}get x(){return this._x}set x(A){this._x=A,this._onChangeCallback()}get y(){return this._y}set y(A){this._y=A,this._onChangeCallback()}get z(){return this._z}set z(A){this._z=A,this._onChangeCallback()}get w(){return this._w}set w(A){this._w=A,this._onChangeCallback()}set(A,I,g,B){return this._x=A,this._y=I,this._z=g,this._w=B,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(A){return this._x=A.x,this._y=A.y,this._z=A.z,this._w=A.w,this._onChangeCallback(),this}setFromEuler(A,I=!0){const g=A._x,B=A._y,C=A._z,t=A._order,E=Math.cos,i=Math.sin,s=E(g/2),n=E(B/2),e=E(C/2),a=i(g/2),o=i(B/2),r=i(C/2);switch(t){case"XYZ":this._x=a*n*e+s*o*r,this._y=s*o*e-a*n*r,this._z=s*n*r+a*o*e,this._w=s*n*e-a*o*r;break;case"YXZ":this._x=a*n*e+s*o*r,this._y=s*o*e-a*n*r,this._z=s*n*r-a*o*e,this._w=s*n*e+a*o*r;break;case"ZXY":this._x=a*n*e-s*o*r,this._y=s*o*e+a*n*r,this._z=s*n*r+a*o*e,this._w=s*n*e-a*o*r;break;case"ZYX":this._x=a*n*e-s*o*r,this._y=s*o*e+a*n*r,this._z=s*n*r-a*o*e,this._w=s*n*e+a*o*r;break;case"YZX":this._x=a*n*e+s*o*r,this._y=s*o*e+a*n*r,this._z=s*n*r-a*o*e,this._w=s*n*e-a*o*r;break;case"XZY":this._x=a*n*e-s*o*r,this._y=s*o*e-a*n*r,this._z=s*n*r+a*o*e,this._w=s*n*e+a*o*r;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+t)}return I===!0&&this._onChangeCallback(),this}setFromAxisAngle(A,I){const g=I/2,B=Math.sin(g);return this._x=A.x*B,this._y=A.y*B,this._z=A.z*B,this._w=Math.cos(g),this._onChangeCallback(),this}setFromRotationMatrix(A){const I=A.elements,g=I[0],B=I[4],C=I[8],t=I[1],E=I[5],i=I[9],s=I[2],n=I[6],e=I[10],a=g+E+e;if(a>0){const o=.5/Math.sqrt(a+1);this._w=.25/o,this._x=(n-i)*o,this._y=(C-s)*o,this._z=(t-B)*o}else if(g>E&&g>e){const o=2*Math.sqrt(1+g-E-e);this._w=(n-i)/o,this._x=.25*o,this._y=(B+t)/o,this._z=(C+s)/o}else if(E>e){const o=2*Math.sqrt(1+E-g-e);this._w=(C-s)/o,this._x=(B+t)/o,this._y=.25*o,this._z=(i+n)/o}else{const o=2*Math.sqrt(1+e-g-E);this._w=(t-B)/o,this._x=(C+s)/o,this._y=(i+n)/o,this._z=.25*o}return this._onChangeCallback(),this}setFromUnitVectors(A,I){let g=A.dot(I)+1;return g<Number.EPSILON?(g=0,Math.abs(A.x)>Math.abs(A.z)?(this._x=-A.y,this._y=A.x,this._z=0,this._w=g):(this._x=0,this._y=-A.z,this._z=A.y,this._w=g)):(this._x=A.y*I.z-A.z*I.y,this._y=A.z*I.x-A.x*I.z,this._z=A.x*I.y-A.y*I.x,this._w=g),this.normalize()}angleTo(A){return 2*Math.acos(Math.abs(tA(this.dot(A),-1,1)))}rotateTowards(A,I){const g=this.angleTo(A);if(g===0)return this;const B=Math.min(1,I/g);return this.slerp(A,B),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(A){return this._x*A._x+this._y*A._y+this._z*A._z+this._w*A._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let A=this.length();return A===0?(this._x=0,this._y=0,this._z=0,this._w=1):(A=1/A,this._x=this._x*A,this._y=this._y*A,this._z=this._z*A,this._w=this._w*A),this._onChangeCallback(),this}multiply(A){return this.multiplyQuaternions(this,A)}premultiply(A){return this.multiplyQuaternions(A,this)}multiplyQuaternions(A,I){const g=A._x,B=A._y,C=A._z,t=A._w,E=I._x,i=I._y,s=I._z,n=I._w;return this._x=g*n+t*E+B*s-C*i,this._y=B*n+t*i+C*E-g*s,this._z=C*n+t*s+g*i-B*E,this._w=t*n-g*E-B*i-C*s,this._onChangeCallback(),this}slerp(A,I){if(I===0)return this;if(I===1)return this.copy(A);const g=this._x,B=this._y,C=this._z,t=this._w;let E=t*A._w+g*A._x+B*A._y+C*A._z;if(E<0?(this._w=-A._w,this._x=-A._x,this._y=-A._y,this._z=-A._z,E=-E):this.copy(A),E>=1)return this._w=t,this._x=g,this._y=B,this._z=C,this;const i=1-E*E;if(i<=Number.EPSILON){const o=1-I;return this._w=o*t+I*this._w,this._x=o*g+I*this._x,this._y=o*B+I*this._y,this._z=o*C+I*this._z,this.normalize(),this}const s=Math.sqrt(i),n=Math.atan2(s,E),e=Math.sin((1-I)*n)/s,a=Math.sin(I*n)/s;return this._w=t*e+this._w*a,this._x=g*e+this._x*a,this._y=B*e+this._y*a,this._z=C*e+this._z*a,this._onChangeCallback(),this}slerpQuaternions(A,I,g){return this.copy(A).slerp(I,g)}random(){const A=2*Math.PI*Math.random(),I=2*Math.PI*Math.random(),g=Math.random(),B=Math.sqrt(1-g),C=Math.sqrt(g);return this.set(B*Math.sin(A),B*Math.cos(A),C*Math.sin(I),C*Math.cos(I))}equals(A){return A._x===this._x&&A._y===this._y&&A._z===this._z&&A._w===this._w}fromArray(A,I=0){return this._x=A[I],this._y=A[I+1],this._z=A[I+2],this._w=A[I+3],this._onChangeCallback(),this}toArray(A=[],I=0){return A[I]=this._x,A[I+1]=this._y,A[I+2]=this._z,A[I+3]=this._w,A}fromBufferAttribute(A,I){return this._x=A.getX(I),this._y=A.getY(I),this._z=A.getZ(I),this._w=A.getW(I),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(A){return this._onChangeCallback=A,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class S{constructor(A=0,I=0,g=0){S.prototype.isVector3=!0,this.x=A,this.y=I,this.z=g}set(A,I,g){return g===void 0&&(g=this.z),this.x=A,this.y=I,this.z=g,this}setScalar(A){return this.x=A,this.y=A,this.z=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setZ(A){return this.z=A,this}setComponent(A,I){switch(A){case 0:this.x=I;break;case 1:this.y=I;break;case 2:this.z=I;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(A){return this.x=A.x,this.y=A.y,this.z=A.z,this}add(A){return this.x+=A.x,this.y+=A.y,this.z+=A.z,this}addScalar(A){return this.x+=A,this.y+=A,this.z+=A,this}addVectors(A,I){return this.x=A.x+I.x,this.y=A.y+I.y,this.z=A.z+I.z,this}addScaledVector(A,I){return this.x+=A.x*I,this.y+=A.y*I,this.z+=A.z*I,this}sub(A){return this.x-=A.x,this.y-=A.y,this.z-=A.z,this}subScalar(A){return this.x-=A,this.y-=A,this.z-=A,this}subVectors(A,I){return this.x=A.x-I.x,this.y=A.y-I.y,this.z=A.z-I.z,this}multiply(A){return this.x*=A.x,this.y*=A.y,this.z*=A.z,this}multiplyScalar(A){return this.x*=A,this.y*=A,this.z*=A,this}multiplyVectors(A,I){return this.x=A.x*I.x,this.y=A.y*I.y,this.z=A.z*I.z,this}applyEuler(A){return this.applyQuaternion(kg.setFromEuler(A))}applyAxisAngle(A,I){return this.applyQuaternion(kg.setFromAxisAngle(A,I))}applyMatrix3(A){const I=this.x,g=this.y,B=this.z,C=A.elements;return this.x=C[0]*I+C[3]*g+C[6]*B,this.y=C[1]*I+C[4]*g+C[7]*B,this.z=C[2]*I+C[5]*g+C[8]*B,this}applyNormalMatrix(A){return this.applyMatrix3(A).normalize()}applyMatrix4(A){const I=this.x,g=this.y,B=this.z,C=A.elements,t=1/(C[3]*I+C[7]*g+C[11]*B+C[15]);return this.x=(C[0]*I+C[4]*g+C[8]*B+C[12])*t,this.y=(C[1]*I+C[5]*g+C[9]*B+C[13])*t,this.z=(C[2]*I+C[6]*g+C[10]*B+C[14])*t,this}applyQuaternion(A){const I=this.x,g=this.y,B=this.z,C=A.x,t=A.y,E=A.z,i=A.w,s=2*(t*B-E*g),n=2*(E*I-C*B),e=2*(C*g-t*I);return this.x=I+i*s+t*e-E*n,this.y=g+i*n+E*s-C*e,this.z=B+i*e+C*n-t*s,this}project(A){return this.applyMatrix4(A.matrixWorldInverse).applyMatrix4(A.projectionMatrix)}unproject(A){return this.applyMatrix4(A.projectionMatrixInverse).applyMatrix4(A.matrixWorld)}transformDirection(A){const I=this.x,g=this.y,B=this.z,C=A.elements;return this.x=C[0]*I+C[4]*g+C[8]*B,this.y=C[1]*I+C[5]*g+C[9]*B,this.z=C[2]*I+C[6]*g+C[10]*B,this.normalize()}divide(A){return this.x/=A.x,this.y/=A.y,this.z/=A.z,this}divideScalar(A){return this.multiplyScalar(1/A)}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this.z=Math.min(this.z,A.z),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this.z=Math.max(this.z,A.z),this}clamp(A,I){return this.x=tA(this.x,A.x,I.x),this.y=tA(this.y,A.y,I.y),this.z=tA(this.z,A.z,I.z),this}clampScalar(A,I){return this.x=tA(this.x,A,I),this.y=tA(this.y,A,I),this.z=tA(this.z,A,I),this}clampLength(A,I){const g=this.length();return this.divideScalar(g||1).multiplyScalar(tA(g,A,I))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(A){return this.x*A.x+this.y*A.y+this.z*A.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,I){return this.x+=(A.x-this.x)*I,this.y+=(A.y-this.y)*I,this.z+=(A.z-this.z)*I,this}lerpVectors(A,I,g){return this.x=A.x+(I.x-A.x)*g,this.y=A.y+(I.y-A.y)*g,this.z=A.z+(I.z-A.z)*g,this}cross(A){return this.crossVectors(this,A)}crossVectors(A,I){const g=A.x,B=A.y,C=A.z,t=I.x,E=I.y,i=I.z;return this.x=B*i-C*E,this.y=C*t-g*i,this.z=g*E-B*t,this}projectOnVector(A){const I=A.lengthSq();if(I===0)return this.set(0,0,0);const g=A.dot(this)/I;return this.copy(A).multiplyScalar(g)}projectOnPlane(A){return bI.copy(this).projectOnVector(A),this.sub(bI)}reflect(A){return this.sub(bI.copy(A).multiplyScalar(2*this.dot(A)))}angleTo(A){const I=Math.sqrt(this.lengthSq()*A.lengthSq());if(I===0)return Math.PI/2;const g=this.dot(A)/I;return Math.acos(tA(g,-1,1))}distanceTo(A){return Math.sqrt(this.distanceToSquared(A))}distanceToSquared(A){const I=this.x-A.x,g=this.y-A.y,B=this.z-A.z;return I*I+g*g+B*B}manhattanDistanceTo(A){return Math.abs(this.x-A.x)+Math.abs(this.y-A.y)+Math.abs(this.z-A.z)}setFromSpherical(A){return this.setFromSphericalCoords(A.radius,A.phi,A.theta)}setFromSphericalCoords(A,I,g){const B=Math.sin(I)*A;return this.x=B*Math.sin(g),this.y=Math.cos(I)*A,this.z=B*Math.cos(g),this}setFromCylindrical(A){return this.setFromCylindricalCoords(A.radius,A.theta,A.y)}setFromCylindricalCoords(A,I,g){return this.x=A*Math.sin(I),this.y=g,this.z=A*Math.cos(I),this}setFromMatrixPosition(A){const I=A.elements;return this.x=I[12],this.y=I[13],this.z=I[14],this}setFromMatrixScale(A){const I=this.setFromMatrixColumn(A,0).length(),g=this.setFromMatrixColumn(A,1).length(),B=this.setFromMatrixColumn(A,2).length();return this.x=I,this.y=g,this.z=B,this}setFromMatrixColumn(A,I){return this.fromArray(A.elements,I*4)}setFromMatrix3Column(A,I){return this.fromArray(A.elements,I*3)}setFromEuler(A){return this.x=A._x,this.y=A._y,this.z=A._z,this}setFromColor(A){return this.x=A.r,this.y=A.g,this.z=A.b,this}equals(A){return A.x===this.x&&A.y===this.y&&A.z===this.z}fromArray(A,I=0){return this.x=A[I],this.y=A[I+1],this.z=A[I+2],this}toArray(A=[],I=0){return A[I]=this.x,A[I+1]=this.y,A[I+2]=this.z,A}fromBufferAttribute(A,I){return this.x=A.getX(I),this.y=A.getY(I),this.z=A.getZ(I),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const A=Math.random()*Math.PI*2,I=Math.random()*2-1,g=Math.sqrt(1-I*I);return this.x=g*Math.cos(A),this.y=I,this.z=g*Math.sin(A),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const bI=new S,kg=new RA;class Rg{constructor(A=new S(1/0,1/0,1/0),I=new S(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=A,this.max=I}set(A,I){return this.min.copy(A),this.max.copy(I),this}setFromArray(A){this.makeEmpty();for(let I=0,g=A.length;I<g;I+=3)this.expandByPoint(yA.fromArray(A,I));return this}setFromBufferAttribute(A){this.makeEmpty();for(let I=0,g=A.count;I<g;I++)this.expandByPoint(yA.fromBufferAttribute(A,I));return this}setFromPoints(A){this.makeEmpty();for(let I=0,g=A.length;I<g;I++)this.expandByPoint(A[I]);return this}setFromCenterAndSize(A,I){const g=yA.copy(I).multiplyScalar(.5);return this.min.copy(A).sub(g),this.max.copy(A).add(g),this}setFromObject(A,I=!1){return this.makeEmpty(),this.expandByObject(A,I)}clone(){return new this.constructor().copy(this)}copy(A){return this.min.copy(A.min),this.max.copy(A.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(A){return this.isEmpty()?A.set(0,0,0):A.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(A){return this.isEmpty()?A.set(0,0,0):A.subVectors(this.max,this.min)}expandByPoint(A){return this.min.min(A),this.max.max(A),this}expandByVector(A){return this.min.sub(A),this.max.add(A),this}expandByScalar(A){return this.min.addScalar(-A),this.max.addScalar(A),this}expandByObject(A,I=!1){A.updateWorldMatrix(!1,!1);const g=A.geometry;if(g!==void 0){const C=g.getAttribute("position");if(I===!0&&C!==void 0&&A.isInstancedMesh!==!0)for(let t=0,E=C.count;t<E;t++)A.isMesh===!0?A.getVertexPosition(t,yA):yA.fromBufferAttribute(C,t),yA.applyMatrix4(A.matrixWorld),this.expandByPoint(yA);else A.boundingBox!==void 0?(A.boundingBox===null&&A.computeBoundingBox(),aI.copy(A.boundingBox)):(g.boundingBox===null&&g.computeBoundingBox(),aI.copy(g.boundingBox)),aI.applyMatrix4(A.matrixWorld),this.union(aI)}const B=A.children;for(let C=0,t=B.length;C<t;C++)this.expandByObject(B[C],I);return this}containsPoint(A){return A.x>=this.min.x&&A.x<=this.max.x&&A.y>=this.min.y&&A.y<=this.max.y&&A.z>=this.min.z&&A.z<=this.max.z}containsBox(A){return this.min.x<=A.min.x&&A.max.x<=this.max.x&&this.min.y<=A.min.y&&A.max.y<=this.max.y&&this.min.z<=A.min.z&&A.max.z<=this.max.z}getParameter(A,I){return I.set((A.x-this.min.x)/(this.max.x-this.min.x),(A.y-this.min.y)/(this.max.y-this.min.y),(A.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(A){return A.max.x>=this.min.x&&A.min.x<=this.max.x&&A.max.y>=this.min.y&&A.min.y<=this.max.y&&A.max.z>=this.min.z&&A.min.z<=this.max.z}intersectsSphere(A){return this.clampPoint(A.center,yA),yA.distanceToSquared(A.center)<=A.radius*A.radius}intersectsPlane(A){let I,g;return A.normal.x>0?(I=A.normal.x*this.min.x,g=A.normal.x*this.max.x):(I=A.normal.x*this.max.x,g=A.normal.x*this.min.x),A.normal.y>0?(I+=A.normal.y*this.min.y,g+=A.normal.y*this.max.y):(I+=A.normal.y*this.max.y,g+=A.normal.y*this.min.y),A.normal.z>0?(I+=A.normal.z*this.min.z,g+=A.normal.z*this.max.z):(I+=A.normal.z*this.max.z,g+=A.normal.z*this.min.z),I<=-A.constant&&g>=-A.constant}intersectsTriangle(A){if(this.isEmpty())return!1;this.getCenter(II),rI.subVectors(this.max,II),TA.subVectors(A.a,II),ZA.subVectors(A.b,II),vA.subVectors(A.c,II),UA.subVectors(ZA,TA),JA.subVectors(vA,ZA),dA.subVectors(TA,vA);let I=[0,-UA.z,UA.y,0,-JA.z,JA.y,0,-dA.z,dA.y,UA.z,0,-UA.x,JA.z,0,-JA.x,dA.z,0,-dA.x,-UA.y,UA.x,0,-JA.y,JA.x,0,-dA.y,dA.x,0];return!qI(I,TA,ZA,vA,rI)||(I=[1,0,0,0,1,0,0,0,1],!qI(I,TA,ZA,vA,rI))?!1:(hI.crossVectors(UA,JA),I=[hI.x,hI.y,hI.z],qI(I,TA,ZA,vA,rI))}clampPoint(A,I){return I.copy(A).clamp(this.min,this.max)}distanceToPoint(A){return this.clampPoint(A,yA).distanceTo(A)}getBoundingSphere(A){return this.isEmpty()?A.makeEmpty():(this.getCenter(A.center),A.radius=this.getSize(yA).length()*.5),A}intersect(A){return this.min.max(A.min),this.max.min(A.max),this.isEmpty()&&this.makeEmpty(),this}union(A){return this.min.min(A.min),this.max.max(A.max),this}applyMatrix4(A){return this.isEmpty()?this:(uA[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(A),uA[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(A),uA[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(A),uA[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(A),uA[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(A),uA[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(A),uA[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(A),uA[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(A),this.setFromPoints(uA),this)}translate(A){return this.min.add(A),this.max.add(A),this}equals(A){return A.min.equals(this.min)&&A.max.equals(this.max)}}const uA=[new S,new S,new S,new S,new S,new S,new S,new S],yA=new S,aI=new Rg,TA=new S,ZA=new S,vA=new S,UA=new S,JA=new S,dA=new S,II=new S,rI=new S,hI=new S,pA=new S;function qI(Q,A,I,g,B){for(let C=0,t=Q.length-3;C<=t;C+=3){pA.fromArray(Q,C);const E=B.x*Math.abs(pA.x)+B.y*Math.abs(pA.y)+B.z*Math.abs(pA.z),i=A.dot(pA),s=I.dot(pA),n=g.dot(pA);if(Math.max(-Math.max(i,s,n),Math.min(i,s,n))>E)return!1}return!0}const Ug={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},YA={h:0,s:0,l:0},cI={h:0,s:0,l:0};function zI(Q,A,I){return I<0&&(I+=1),I>1&&(I-=1),I<1/6?Q+(A-Q)*6*I:I<1/2?A:I<2/3?Q+(A-Q)*6*(2/3-I):Q}class TI{constructor(A,I,g){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(A,I,g)}set(A,I,g){if(I===void 0&&g===void 0){const B=A;B&&B.isColor?this.copy(B):typeof B=="number"?this.setHex(B):typeof B=="string"&&this.setStyle(B)}else this.setRGB(A,I,g);return this}setScalar(A){return this.r=A,this.g=A,this.b=A,this}setHex(A,I=DA){return A=Math.floor(A),this.r=(A>>16&255)/255,this.g=(A>>8&255)/255,this.b=(A&255)/255,wA.toWorkingColorSpace(this,I),this}setRGB(A,I,g,B=wA.workingColorSpace){return this.r=A,this.g=I,this.b=g,wA.toWorkingColorSpace(this,B),this}setHSL(A,I,g,B=wA.workingColorSpace){if(A=lQ(A,1),I=tA(I,0,1),g=tA(g,0,1),I===0)this.r=this.g=this.b=g;else{const C=g<=.5?g*(1+I):g+I-g*I,t=2*g-C;this.r=zI(t,C,A+1/3),this.g=zI(t,C,A),this.b=zI(t,C,A-1/3)}return wA.toWorkingColorSpace(this,B),this}setStyle(A,I=DA){function g(C){C!==void 0&&parseFloat(C)<1&&console.warn("THREE.Color: Alpha component of "+A+" will be ignored.")}let B;if(B=/^(\\w+)\\(([^\\)]*)\\)/.exec(A)){let C;const t=B[1],E=B[2];switch(t){case"rgb":case"rgba":if(C=/^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(E))return g(C[4]),this.setRGB(Math.min(255,parseInt(C[1],10))/255,Math.min(255,parseInt(C[2],10))/255,Math.min(255,parseInt(C[3],10))/255,I);if(C=/^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(E))return g(C[4]),this.setRGB(Math.min(100,parseInt(C[1],10))/100,Math.min(100,parseInt(C[2],10))/100,Math.min(100,parseInt(C[3],10))/100,I);break;case"hsl":case"hsla":if(C=/^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(E))return g(C[4]),this.setHSL(parseFloat(C[1])/360,parseFloat(C[2])/100,parseFloat(C[3])/100,I);break;default:console.warn("THREE.Color: Unknown color model "+A)}}else if(B=/^\\#([A-Fa-f\\d]+)$/.exec(A)){const C=B[1],t=C.length;if(t===3)return this.setRGB(parseInt(C.charAt(0),16)/15,parseInt(C.charAt(1),16)/15,parseInt(C.charAt(2),16)/15,I);if(t===6)return this.setHex(parseInt(C,16),I);console.warn("THREE.Color: Invalid hex color "+A)}else if(A&&A.length>0)return this.setColorName(A,I);return this}setColorName(A,I=DA){const g=Ug[A.toLowerCase()];return g!==void 0?this.setHex(g,I):console.warn("THREE.Color: Unknown color "+A),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(A){return this.r=A.r,this.g=A.g,this.b=A.b,this}copySRGBToLinear(A){return this.r=qA(A.r),this.g=qA(A.g),this.b=qA(A.b),this}copyLinearToSRGB(A){return this.r=zA(A.r),this.g=zA(A.g),this.b=zA(A.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(A=DA){return wA.fromWorkingColorSpace(QA.copy(this),A),Math.round(tA(QA.r*255,0,255))*65536+Math.round(tA(QA.g*255,0,255))*256+Math.round(tA(QA.b*255,0,255))}getHexString(A=DA){return("000000"+this.getHex(A).toString(16)).slice(-6)}getHSL(A,I=wA.workingColorSpace){wA.fromWorkingColorSpace(QA.copy(this),I);const g=QA.r,B=QA.g,C=QA.b,t=Math.max(g,B,C),E=Math.min(g,B,C);let i,s;const n=(E+t)/2;if(E===t)i=0,s=0;else{const e=t-E;switch(s=n<=.5?e/(t+E):e/(2-t-E),t){case g:i=(B-C)/e+(B<C?6:0);break;case B:i=(C-g)/e+2;break;case C:i=(g-B)/e+4;break}i/=6}return A.h=i,A.s=s,A.l=n,A}getRGB(A,I=wA.workingColorSpace){return wA.fromWorkingColorSpace(QA.copy(this),I),A.r=QA.r,A.g=QA.g,A.b=QA.b,A}getStyle(A=DA){wA.fromWorkingColorSpace(QA.copy(this),A);const I=QA.r,g=QA.g,B=QA.b;return A!==DA?`color(${A} ${I.toFixed(3)} ${g.toFixed(3)} ${B.toFixed(3)})`:`rgb(${Math.round(I*255)},${Math.round(g*255)},${Math.round(B*255)})`}offsetHSL(A,I,g){return this.getHSL(YA),this.setHSL(YA.h+A,YA.s+I,YA.l+g)}add(A){return this.r+=A.r,this.g+=A.g,this.b+=A.b,this}addColors(A,I){return this.r=A.r+I.r,this.g=A.g+I.g,this.b=A.b+I.b,this}addScalar(A){return this.r+=A,this.g+=A,this.b+=A,this}sub(A){return this.r=Math.max(0,this.r-A.r),this.g=Math.max(0,this.g-A.g),this.b=Math.max(0,this.b-A.b),this}multiply(A){return this.r*=A.r,this.g*=A.g,this.b*=A.b,this}multiplyScalar(A){return this.r*=A,this.g*=A,this.b*=A,this}lerp(A,I){return this.r+=(A.r-this.r)*I,this.g+=(A.g-this.g)*I,this.b+=(A.b-this.b)*I,this}lerpColors(A,I,g){return this.r=A.r+(I.r-A.r)*g,this.g=A.g+(I.g-A.g)*g,this.b=A.b+(I.b-A.b)*g,this}lerpHSL(A,I){this.getHSL(YA),A.getHSL(cI);const g=HI(YA.h,cI.h,I),B=HI(YA.s,cI.s,I),C=HI(YA.l,cI.l,I);return this.setHSL(g,B,C),this}setFromVector3(A){return this.r=A.x,this.g=A.y,this.b=A.z,this}applyMatrix3(A){const I=this.r,g=this.g,B=this.b,C=A.elements;return this.r=C[0]*I+C[3]*g+C[6]*B,this.g=C[1]*I+C[4]*g+C[7]*B,this.b=C[2]*I+C[5]*g+C[8]*B,this}equals(A){return A.r===this.r&&A.g===this.g&&A.b===this.b}fromArray(A,I=0){return this.r=A[I],this.g=A[I+1],this.b=A[I+2],this}toArray(A=[],I=0){return A[I]=this.r,A[I+1]=this.g,A[I+2]=this.b,A}fromBufferAttribute(A,I){return this.r=A.getX(I),this.g=A.getY(I),this.b=A.getZ(I),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const QA=new TI;TI.NAMES=Ug,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Fg}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Fg);const HA=-12,_A=(9-HA)/254,XA=Math.exp(-30),MQ=11,FQ=11,Jg=1<<MQ,Yg=1<<FQ,xg=1;function GQ(Q){var C;let A=!1;const I=Q.split(`\n`).map(t=>{const E=t.trimEnd();return A?E:E.length>0?(A=!0,E):null}).filter(t=>t!=null);for(;I.length>0&&I[I.length-1].length===0;)I.pop();if(I.length===0)return[];const g=(C=I[0].match(/^\\s*/))==null?void 0:C[0];if(!g)return I;const B=new RegExp(`^${g}`);return I.map(t=>t.replace(B,""))}function uQ(Q){return GQ(Q).join(`\n`)}const ZI=new Float32Array(1),mg=new Uint32Array(ZI.buffer);function WA(Q){ZI[0]=Q;const A=mg[0],I=A>>31&1,g=A>>23&255,B=A&8388607,C=I<<15;if(g===255)return B!==0?C|32767:C|31744;const t=g-127+15;if(t>=31)return C|31744;if(t<=0){if(t<-10)return C;const i=(B|8388608)>>1-t+13;return C|i}const E=B>>13;return C|t<<10|E}function $(Q){const A=Q>>15&1,I=Q>>10&31,g=Q&1023;let B;if(I===0)if(g===0)B=A<<31;else{let C=g,t=-14;for(;(C&1024)===0;)C<<=1,t--;C&=1023;const E=t+127,i=C<<13;B=A<<31|E<<23|i}else if(I===31)g===0?B=A<<31|2139095040:B=A<<31|2143289344;else{const C=I-15+127,t=g<<13;B=A<<31|C<<23|t}return mg[0]=B,ZI[0]}function aA(Q){return Math.max(0,Math.min(255,Math.round(Q*255)))}function fQ(Q){const A=[],I=new Set;function g(B){B&&typeof B=="object"&&!I.has(B)&&(I.add(B),B instanceof ArrayBuffer?A.push(B):ArrayBuffer.isView(B)?A.push(B.buffer):Array.isArray(B)?B.forEach(g):Object.values(B).forEach(g))}return g(Q),A}function vI(Q,A,I,g,B,C,t,E,i,s,n,e,a,o,r,c){const N=aA(o),h=aA(r),w=aA(c),D=aA(a),M=Hg(new RA(i,s,n,e)),u=M&255,R=M>>>8&255,d=M>>>16&255,G=C<XA?0:Math.min(255,Math.max(1,Math.round((Math.log(C)-HA)/_A)+1)),l=t<XA?0:Math.min(255,Math.max(1,Math.round((Math.log(t)-HA)/_A)+1)),k=E<XA?0:Math.min(255,Math.max(1,Math.round((Math.log(E)-HA)/_A)+1)),F=WA(I),y=WA(g),U=WA(B),H=A*4;Q[H]=N|h<<8|w<<16|D<<24,Q[H+1]=F|y<<16,Q[H+2]=U|u<<16|R<<24,Q[H+3]=G|l<<8|k<<16|d<<24}function Lg(Q,A,I,g,B){const C=WA(I),t=WA(g),E=WA(B),i=A*4;Q[i+1]=C|t<<16,Q[i+2]=E|Q[i+2]&4294901760}function dg(Q,A,I,g,B){const C=I<XA?0:Math.min(255,Math.max(1,Math.round((Math.log(I)-HA)/_A)+1)),t=g<XA?0:Math.min(255,Math.max(1,Math.round((Math.log(g)-HA)/_A)+1)),E=B<XA?0:Math.min(255,Math.max(1,Math.round((Math.log(B)-HA)/_A)+1)),i=A*4;Q[i+3]=C|t<<8|E<<16|Q[i+3]&4278190080}function pg(Q,A,I,g,B,C){const t=Hg(new RA(I,g,B,C)),E=t&255,i=t>>>8&255,s=t>>>16&255,n=A*4;Q[n+2]=Q[n+2]&65535|E<<16|i<<24,Q[n+3]=Q[n+3]&16777215|s<<24}function SQ(Q,A,I,g,B,C){const t=aA(I),E=aA(g),i=aA(B),s=aA(C),n=A*4;Q[n]=t|E<<8|i<<16|s<<24}function kQ(Q,A,I,g,B){const C=aA(I),t=aA(g),E=aA(B),i=A*4;Q[i]=C|t<<8|E<<16|Q[i]&4278190080}function RQ(Q,A,I){const g=aA(I),B=A*4;Q[B]=Q[B]&16777215|g<<24}new S,new S,new TI;function UQ(Q){const A=Jg,I=Math.max(xg,Math.min(Yg,Math.ceil(Q/A))),g=Math.ceil(Q/(A*I)),B=A*I*g;return{width:A,height:I,depth:g,maxSplats:B}}function DI(Q){const A=Jg,I=Math.max(xg,Math.min(Yg,Math.ceil(Q/A))),g=Math.ceil(Q/(A*I));return A*I*g}uQ(`\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n`);function Hg(Q){const A=Q.clone().normalize();A.w<0&&A.set(-A.x,-A.y,-A.z,-A.w);const I=2*Math.acos(A.w),g=Math.sqrt(A.x*A.x+A.y*A.y+A.z*A.z),B=g<1e-6?new S(1,0,0):new S(A.x,A.y,A.z).divideScalar(g),C=Math.abs(B.x)+Math.abs(B.y)+Math.abs(B.z);let t=B.x/C,E=B.y/C;if(B.z<0){const o=t;t=(1-Math.abs(E))*(t>=0?1:-1),E=(1-Math.abs(o))*(E>=0?1:-1)}const i=t*.5+.5,s=E*.5+.5,n=Math.round(i*255),e=Math.round(s*255);return Math.round(I*(255/Math.PI))<<16|e<<8|n}function wI(Q,A,I,g){const B=Math.max(-127,Math.min(127,Q*127)),C=Math.max(-127,Math.min(127,A*127)),t=Math.max(-127,Math.min(127,I*127)),E=Math.max(-127,Math.min(127,g*127));return B&255|(C&255)<<8|(t&255)<<16|(E&255)<<24}function yI(Q,A,I){const g=A*2;for(let B=0;B<9;++B){const C=Math.max(-63,Math.min(63,I[B]*63))&127,t=B*7,E=t+7,i=Math.floor(t/32),s=t-i*32,n=C<<s&4294967295;if(Q[g+i]|=n,E>i*32+32){const e=C>>>32-s&4294967295;Q[g+i+1]|=e}}}function lI(Q,A,I){Q[A*4+0]=wI(I[0],I[1],I[2],I[3]),Q[A*4+1]=wI(I[4],I[5],I[6],I[7]),Q[A*4+2]=wI(I[8],I[9],I[10],I[11]),Q[A*4+3]=wI(I[12],I[13],I[14],0)}function NI(Q,A,I){const g=A*4;for(let B=0;B<21;++B){const C=Math.max(-31,Math.min(31,I[B]*31))&63,t=B*6,E=t+6,i=Math.floor(t/32),s=t-i*32,n=C<<s&4294967295;if(Q[g+i]|=n,E>i*32+32){const e=C>>>32-s&4294967295;Q[g+i+1]|=e}}}function JQ(Q,A){const I=[];let g=0,B=null;const C=new yg((i,s)=>{if(I.push(i),g+=i.length,s||g>=A){const n=new Uint8Array(g);let e=0;for(const a of I)n.set(a,e),e+=a.length;B=n.slice(0,A)}}),t=1024;let E=0;for(;B==null&&E<Q.length;){const i=Q.slice(E,E+t);C.push(i,!1),E+=t}if(B==null&&(C.push(new Uint8Array,!0),B==null))throw new Error("Failed to decompress partial gzip");return B}class YQ{constructor({fileBytes:A,chunkBytes:I=64*1024}){this.fileBytes=A,this.chunkBytes=I,this.offset=0,this.chunks=[],this.totalBytes=0,this.gunzip=new yg((g,B)=>{this.chunks.push(g),this.totalBytes+=g.length})}read(A){for(;this.totalBytes<A&&this.offset<this.fileBytes.length;){const C=Math.min(this.offset+this.chunkBytes,this.fileBytes.length);this.gunzip.push(this.fileBytes.subarray(this.offset,C),!1),this.offset=C}if(this.totalBytes<A&&this.offset>=this.fileBytes.length&&this.gunzip.push(new Uint8Array(0),!0),this.totalBytes<A)throw new Error(`Unexpected EOF: needed ${A}, got ${this.totalBytes}`);const I=new Uint8Array(this.totalBytes);let g=0;for(const C of this.chunks)I.set(C,g),g+=C.length;const B=I.subarray(0,A);return this.chunks=[I.subarray(A)],this.totalBytes-=A,B}}function Kg(Q,A,I){const g=Math.floor(Q.length/32);if(g*32!==Q.length)throw new Error("Invalid .splat file size");A(g);const B=new Float32Array(Q.buffer);for(let C=0;C<g;++C){const t=C*32,E=C*8,i=B[E+0],s=B[E+1],n=B[E+2],e=B[E+3],a=B[E+4],o=B[E+5],r=Q[t+24]/255,c=Q[t+25]/255,N=Q[t+26]/255,h=Q[t+27]/255,w=(Q[t+28]-128)/128,D=(Q[t+29]-128)/128,M=(Q[t+30]-128)/128,u=(Q[t+31]-128)/128;I(C,i,s,n,e,a,o,D,M,u,w,h,r,c,N)}}function xQ(Q){let A=0,I=0,g=new Uint32Array(0);return Kg(Q,B=>{A=B,I=DI(A),g=new Uint32Array(I*4)},(B,C,t,E,i,s,n,e,a,o,r,c,N,h,w)=>{vI(g,B,C,t,E,i,s,n,e,a,o,r,c,N,h,w)}),{packedArray:g,numSplats:A}}const MI={0:{bytesPerCenter:12,bytesPerScale:12,bytesPerRotation:16,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:4,scaleOffsetBytes:12,rotationOffsetBytes:24,colorOffsetBytes:40,sphericalHarmonicsOffsetBytes:44,scaleRange:1},1:{bytesPerCenter:6,bytesPerScale:6,bytesPerRotation:8,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:2,scaleOffsetBytes:6,rotationOffsetBytes:12,colorOffsetBytes:20,sphericalHarmonicsOffsetBytes:24,scaleRange:32767},2:{bytesPerCenter:6,bytesPerScale:6,bytesPerRotation:8,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:1,scaleOffsetBytes:6,rotationOffsetBytes:12,colorOffsetBytes:20,sphericalHarmonicsOffsetBytes:24,scaleRange:32767}},bg={0:0,1:9,2:24,3:45};function mQ(Q,A,I,g){var c;let t=0;const E=new DataView(Q.buffer,t,4096);t+=4096;const i=E.getUint8(0),s=E.getUint8(1);if(i!==0||s<1)throw new Error(`Unsupported .ksplat version: ${i}.${s}`);const n=E.getUint32(4,!0);E.getUint32(16,!0);const e=E.getUint16(20,!0);if(e<0||e>2)throw new Error(`Invalid .ksplat compression level: ${e}`);const a=E.getFloat32(36,!0)||-1.5,o=E.getFloat32(40,!0)||1.5;let r=4096+n*1024;for(let N=0;N<n;++N){let h=function(IA,L){if(e===0)return m.getFloat32(IA+J+L*4,!0);if(e===1)return $(m.getUint16(IA+J+L*2,!0));const X=m.getUint8(IA+J+L)/255;return a+X*(o-a)};const w=new DataView(Q.buffer,t,1024);t+=1024;const D=w.getUint32(0,!0),M=w.getUint32(4,!0),u=w.getUint32(8,!0),R=w.getUint32(12,!0),d=w.getFloat32(16,!0),G=w.getUint16(20,!0),l=(w.getUint32(24,!0)||((c=MI[e])==null?void 0:c.scaleRange))??1,k=w.getUint32(32,!0),F=k*u,y=w.getUint32(36,!0),U=y*4,H=G*R+U,K=w.getUint16(40,!0),x=bg[K],{bytesPerCenter:z,bytesPerScale:j,bytesPerRotation:Z,bytesPerColor:P,bytesPerSphericalHarmonicsComponent:V,scaleOffsetBytes:_,rotationOffsetBytes:q,colorOffsetBytes:b,sphericalHarmonicsOffsetBytes:J}=MI[e],T=z+j+Z+P+x*V,f=T*M,CA=f+H,BA=[0,3,6,1,4,7,2,5,8],nA=[9,14,19,10,15,20,11,16,21,12,17,22,13,18,23],EA=[24,31,38,25,32,39,26,33,40,27,34,41,28,35,42,29,36,43,30,37,44],iA=K>=1?new Float32Array(3*3):void 0,sA=K>=2?new Float32Array(5*3):void 0,lA=K>=3?new Float32Array(7*3):void 0,eA=d/2/l,rA=r+U,hA=r+H,m=new DataView(Q.buffer,hA,f),AA=new Float32Array(Q.buffer,rA,R*3),Y=new Uint32Array(Q.buffer,r,y);let fA=k,OA=F;for(let IA=0;IA<D;++IA){const L=IA*T;let X;if(IA<F)X=Math.floor(IA/u);else{const GA=Y[fA-k];IA>=OA+GA&&(fA+=1,OA+=GA),X=fA}const p=e===0?m.getFloat32(L+0,!0):(m.getUint16(L+0,!0)-l)*eA+AA[3*X+0],NA=e===0?m.getFloat32(L+4,!0):(m.getUint16(L+2,!0)-l)*eA+AA[3*X+1],BI=e===0?m.getFloat32(L+8,!0):(m.getUint16(L+4,!0)-l)*eA+AA[3*X+2],CI=e===0?m.getFloat32(L+_+0,!0):$(m.getUint16(L+_+0,!0)),EI=e===0?m.getFloat32(L+_+4,!0):$(m.getUint16(L+_+2,!0)),jI=e===0?m.getFloat32(L+_+8,!0):$(m.getUint16(L+_+4,!0)),VI=e===0?m.getFloat32(L+q+0,!0):$(m.getUint16(L+q+0,!0)),OI=e===0?m.getFloat32(L+q+4,!0):$(m.getUint16(L+q+2,!0)),PI=e===0?m.getFloat32(L+q+8,!0):$(m.getUint16(L+q+4,!0)),$I=e===0?m.getFloat32(L+q+12,!0):$(m.getUint16(L+q+6,!0)),Ag=m.getUint8(L+b+0)/255,Ig=m.getUint8(L+b+1)/255,gg=m.getUint8(L+b+2)/255,Qg=m.getUint8(L+b+3)/255;if(I(IA,p,NA,BI,CI,EI,jI,OI,PI,$I,VI,Qg,Ag,Ig,gg),K>=1&&iA){for(const[GA,KA]of BA.entries())iA[GA]=h(L,KA);if(sA)for(const[GA,KA]of nA.entries())sA[GA]=h(L,KA);if(lA)for(const[GA,KA]of EA.entries())lA[GA]=h(L,KA);g==null||g(IA,iA,sA,lA)}}r+=CA}}function LQ(Q){var h;let g=0;const B=new DataView(Q.buffer,g,4096);g+=4096;const C=B.getUint8(0),t=B.getUint8(1);if(C!==0||t<1)throw new Error(`Unsupported .ksplat version: ${C}.${t}`);const E=B.getUint32(4,!0),i=B.getUint32(16,!0),s=B.getUint16(20,!0);if(s<0||s>2)throw new Error(`Invalid .ksplat compression level: ${s}`);const n=B.getFloat32(36,!0)||-1.5,e=B.getFloat32(40,!0)||1.5,a=i,o=DI(a),r=new Uint32Array(o*4),c={};let N=4096+E*1024;for(let w=0;w<E;++w){let D=function(X,p){if(s===0)return Y.getFloat32(X+f+p*4,!0);if(s===1)return $(Y.getUint16(X+f+p*2,!0));const NA=Y.getUint8(X+f+p)/255;return n+NA*(e-n)};const M=new DataView(Q.buffer,g,1024);g+=1024;const u=M.getUint32(0,!0),R=M.getUint32(4,!0),d=M.getUint32(8,!0),G=M.getUint32(12,!0),l=M.getFloat32(16,!0),k=M.getUint16(20,!0),F=(M.getUint32(24,!0)||((h=MI[s])==null?void 0:h.scaleRange))??1,y=M.getUint32(32,!0),U=y*d,H=M.getUint32(36,!0),K=H*4,x=k*G+K,z=M.getUint16(40,!0),j=bg[z],{bytesPerCenter:Z,bytesPerScale:P,bytesPerRotation:V,bytesPerColor:_,bytesPerSphericalHarmonicsComponent:q,scaleOffsetBytes:b,rotationOffsetBytes:J,colorOffsetBytes:T,sphericalHarmonicsOffsetBytes:f}=MI[s],CA=Z+P+V+_+j*q,BA=CA*R,nA=BA+x,EA=[0,3,6,1,4,7,2,5,8],iA=[9,14,19,10,15,20,11,16,21,12,17,22,13,18,23],sA=[24,31,38,25,32,39,26,33,40,27,34,41,28,35,42,29,36,43,30,37,44],lA=z>=1?new Float32Array(3*3):void 0,eA=z>=2?new Float32Array(5*3):void 0,rA=z>=3?new Float32Array(7*3):void 0,hA=l/2/F,m=N+K,AA=N+x,Y=new DataView(Q.buffer,AA,BA),fA=new Float32Array(Q.buffer,m,G*3),OA=new Uint32Array(Q.buffer,N,H);let IA=y,L=U;for(let X=0;X<u;++X){const p=X*CA;let NA;if(X<U)NA=Math.floor(X/d);else{const mA=OA[IA-y];X>=L+mA&&(IA+=1,L+=mA),NA=IA}const BI=s===0?Y.getFloat32(p+0,!0):(Y.getUint16(p+0,!0)-F)*hA+fA[3*NA+0],CI=s===0?Y.getFloat32(p+4,!0):(Y.getUint16(p+2,!0)-F)*hA+fA[3*NA+1],EI=s===0?Y.getFloat32(p+8,!0):(Y.getUint16(p+4,!0)-F)*hA+fA[3*NA+2],jI=s===0?Y.getFloat32(p+b+0,!0):$(Y.getUint16(p+b+0,!0)),VI=s===0?Y.getFloat32(p+b+4,!0):$(Y.getUint16(p+b+2,!0)),OI=s===0?Y.getFloat32(p+b+8,!0):$(Y.getUint16(p+b+4,!0)),PI=s===0?Y.getFloat32(p+J+0,!0):$(Y.getUint16(p+J+0,!0)),$I=s===0?Y.getFloat32(p+J+4,!0):$(Y.getUint16(p+J+2,!0)),Ag=s===0?Y.getFloat32(p+J+8,!0):$(Y.getUint16(p+J+4,!0)),Ig=s===0?Y.getFloat32(p+J+12,!0):$(Y.getUint16(p+J+6,!0)),gg=Y.getUint8(p+T+0)/255,Qg=Y.getUint8(p+T+1)/255,GA=Y.getUint8(p+T+2)/255,KA=Y.getUint8(p+T+3)/255;if(vI(r,X,BI,CI,EI,jI,VI,OI,$I,Ag,Ig,PI,KA,gg,Qg,GA),z>=1){if(lA){c.sh1||(c.sh1=new Uint32Array(a*2));for(const[mA,tI]of EA.entries())lA[mA]=D(p,tI);yI(c.sh1,X,lA)}if(eA){c.sh2||(c.sh2=new Uint32Array(a*4));for(const[mA,tI]of iA.entries())eA[mA]=D(p,tI);lI(c.sh2,X,eA)}if(rA){c.sh3||(c.sh3=new Uint32Array(a*4));for(const[mA,tI]of sA.entries())rA[mA]=D(p,tI);NI(c.sh3,X,rA)}}}N+=nA}return{packedArray:r,numSplats:a,extra:c}}const VA=class VA{constructor({fileBytes:A}){this.header="",this.littleEndian=!0,this.elements={},this.comments=[],this.data=null,this.numSplats=0,this.fileBytes=A instanceof ArrayBuffer?new Uint8Array(A):A}async parseHeader(){const I=new ReadableStream({start:t=>{t.enqueue(this.fileBytes.slice(0,65536)),t.close()}}).pipeThrough(new TextDecoderStream).getReader();this.header="";const g=`end_header\n`;for(;;){const{value:t,done:E}=await I.read();if(E)throw new Error("Failed to read header");this.header+=t;const i=this.header.indexOf(g);if(i>=0){this.header=this.header.slice(0,i+g.length);break}}const B=new TextEncoder().encode(this.header).length;this.data=new DataView(this.fileBytes.buffer,B),this.elements={};let C=null;this.comments=[],this.header.trim().split(`\n`).forEach((t,E)=>{const i=t.trim();if(E===0){if(i!=="ply")throw new Error("Invalid PLY header");return}if(i.length===0)return;const s=i.split(" ");switch(s[0]){case"format":if(s[1]==="binary_little_endian")this.littleEndian=!0;else if(s[1]==="binary_big_endian")this.littleEndian=!1;else throw new Error(`Unsupported PLY format: ${s[1]}`);if(s[2]!=="1.0")throw new Error(`Unsupported PLY version: ${s[2]}`);break;case"end_header":break;case"comment":this.comments.push(i.slice(8));break;case"element":{const n=s[1];C={name:n,count:Number.parseInt(s[2]),properties:{}},this.elements[n]=C;break}case"property":if(C==null)throw new Error("Property must be inside an element");s[1]==="list"?C.properties[s[4]]={isList:!0,type:s[3],countType:s[2]}:C.properties[s[2]]={isList:!1,type:s[1]};break}}),this.elements.vertex&&(this.numSplats=this.elements.vertex.count)}parseData(A){let I=0;const g=this.data;if(g==null)throw new Error("No data to parse");for(const B in this.elements){const C=this.elements[B],{count:t,properties:E}=C,i={},s=[];for(const[e,a]of Object.entries(E))a.isList?(i[e]=[],s.push(()=>{const o=i[e];o.length=uI[a.countType](g,I,this.littleEndian),I+=jA[a.countType];for(let r=0;r<o.length;r++)o[r]=uI[a.type](g,I,this.littleEndian),I+=jA[a.type]})):(i[e]=0,s.push(()=>{i[e]=uI[a.type](g,I,this.littleEndian),I+=jA[a.type]}));const n=A(C)??(()=>{});for(let e=0;e<t;e++){for(const a of s)a();n(e,i)}}}parseSplats(A,I){if(this.elements.vertex==null)throw new Error("No vertex element found");let g=!1;const B=[];let C=0,t=[],E=[],i=[],s,n,e;function a(){const h=pQ[C];t=new Array(3).fill(null).flatMap((w,D)=>[0,1,2].map((M,u)=>`f_rest_${D+u*h/3}`)),E=new Array(5).fill(null).flatMap((w,D)=>[0,1,2].map((M,u)=>`f_rest_${3+D+u*h/3}`)),i=new Array(7).fill(null).flatMap((w,D)=>[0,1,2].map((M,u)=>`f_rest_${8+D+u*h/3}`)),s=C>=1?new Float32Array(3*3):void 0,n=C>=2?new Float32Array(5*3):void 0,e=C>=3?new Float32Array(7*3):void 0}function o(h,w){if(!s)throw new Error("Missing sh1");for(const[D,M]of t.entries())s[D]=w[M]*8/255-4;if(n)for(const[D,M]of E.entries())n[D]=w[M]*8/255-4;if(e)for(const[D,M]of i.entries())e[D]=w[M]*8/255-4;I==null||I(h,s,n,e)}function r(h){const{min_x:w,min_y:D,min_z:M,max_x:u,max_y:R,max_z:d,min_scale_x:G,min_scale_y:l,min_scale_z:k,max_scale_x:F,max_scale_y:y,max_scale_z:U}=h.properties;if(!w||!D||!M||!u||!R||!d||!G||!l||!k||!F||!y||!U)throw new Error("Missing PLY chunk properties");return g=!0,(H,K)=>{const{min_x:x,min_y:z,min_z:j,max_x:Z,max_y:P,max_z:V,min_scale_x:_,min_scale_y:q,min_scale_z:b,max_scale_x:J,max_scale_y:T,max_scale_z:f,min_r:CA,min_g:BA,min_b:nA,max_r:EA,max_g:iA,max_b:sA}=K;B.push({min_x:x,min_y:z,min_z:j,max_x:Z,max_y:P,max_z:V,min_scale_x:_,min_scale_y:q,min_scale_z:b,max_scale_x:J,max_scale_y:T,max_scale_z:f,min_r:CA,min_g:BA,min_b:nA,max_r:EA,max_g:iA,max_b:sA})}}function c(h){if(I&&h.name==="sh")return C=zg(h.properties),a(),o;if(h.name!=="vertex")return null;const{packed_position:w,packed_rotation:D,packed_scale:M,packed_color:u}=h.properties;if(!w||!D||!M||!u)throw new Error("Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color");const R=Math.sqrt(2);return(d,G)=>{const l=B[d>>>8];if(l==null)throw new Error("Missing PLY chunk");const{min_x:k,min_y:F,min_z:y,max_x:U,max_y:H,max_z:K,min_scale_x:x,min_scale_y:z,min_scale_z:j,max_scale_x:Z,max_scale_y:P,max_scale_z:V,min_r:_,min_g:q,min_b:b,max_r:J,max_g:T,max_b:f}=l,{packed_position:CA,packed_rotation:BA,packed_scale:nA,packed_color:EA}=G,iA=(CA>>>21&2047)/2047*(U-k)+k,sA=(CA>>>11&1023)/1023*(H-F)+F,lA=(CA&2047)/2047*(K-y)+y,eA=((BA>>>20&1023)/1023-.5)*R,rA=((BA>>>10&1023)/1023-.5)*R,hA=((BA&1023)/1023-.5)*R,m=Math.sqrt(Math.max(0,1-eA*eA-rA*rA-hA*hA)),AA=BA>>>30,Y=AA===0?eA:AA===1?m:rA,fA=AA<=1?rA:AA===2?m:hA,OA=AA<=2?hA:m,IA=AA===0?m:eA,L=Math.exp((nA>>>21&2047)/2047*(Z-x)+x),X=Math.exp((nA>>>11&1023)/1023*(P-z)+z),p=Math.exp((nA&2047)/2047*(V-j)+j),NA=(EA>>>24&255)/255*((J??1)-(_??0))+(_??0),BI=(EA>>>16&255)/255*((T??1)-(q??0))+(q??0),CI=(EA>>>8&255)/255*((f??1)-(b??0))+(b??0),EI=(EA&255)/255;A(d,iA,sA,lA,L,X,p,Y,fA,OA,IA,EI,NA,BI,CI)}}const N=h=>{if(h.name==="chunk")return r(h);if(g)return c(h);if(h.name!=="vertex")return null;const{x:w,y:D,z:M,scale_0:u,scale_1:R,scale_2:d,rot_0:G,rot_1:l,rot_2:k,rot_3:F,opacity:y,f_dc_0:U,f_dc_1:H,f_dc_2:K,red:x,green:z,blue:j,alpha:Z}=h.properties;if(!w||!D||!M)throw new Error("Missing PLY properties: x, y, z");const P=u&&R&&d,V=G&&l&&k&&F,_=Z!=null?fI[Z.type]:1,q=x!=null?fI[x.type]:1,b=z!=null?fI[z.type]:1,J=j!=null?fI[j.type]:1;return C=zg(h.properties),a(),(T,f)=>{const CA=P?Math.exp(f.scale_0):VA.defaultPointScale,BA=P?Math.exp(f.scale_1):VA.defaultPointScale,nA=P?Math.exp(f.scale_2):VA.defaultPointScale,EA=V?f.rot_1:0,iA=V?f.rot_2:0,sA=V?f.rot_3:0,lA=V?f.rot_0:1,eA=y!=null?1/(1+Math.exp(-f.opacity)):Z!=null?f.alpha/_:1,rA=U!=null?f.f_dc_0*GI+.5:x!=null?f.red/q:1,hA=H!=null?f.f_dc_1*GI+.5:z!=null?f.green/b:1,m=K!=null?f.f_dc_2*GI+.5:j!=null?f.blue/J:1;if(A(T,f.x,f.y,f.z,CA,BA,nA,EA,iA,sA,lA,eA,rA,hA,m),I&&s){if(s)for(const[AA,Y]of t.entries())s[AA]=f[Y];if(n)for(const[AA,Y]of E.entries())n[AA]=f[Y];if(e)for(const[AA,Y]of i.entries())e[AA]=f[Y];I(T,s,n,e)}}};this.parseData(N)}injectRgba(A){let I=0;const g=this.data;if(g==null)throw new Error("No parsed data");if(A.length!==this.numSplats*4)throw new Error("Invalid RGBA array length");for(const B in this.elements){const C=this.elements[B],{count:t,properties:E}=C,i=[];let s=0;const n=B==="vertex";if(n){for(const e of["opacity","f_dc_0","f_dc_1","f_dc_2"])if(!E[e]||E[e].type!=="float")throw new Error(`Can\'t injectRgba due to property: ${e}`)}for(const[e,a]of Object.entries(E))if(a.isList)i.push(()=>{const o=uI[a.countType](g,I,this.littleEndian);I+=jA[a.countType],I+=o*jA[a.type]});else{if(n)if(e==="f_dc_0"||e==="f_dc_1"||e==="f_dc_2"){const o=Number.parseInt(e.slice(5));i.push(()=>{const r=(A[s+o]/255-.5)/GI;qg[a.type](g,I,this.littleEndian,r)})}else e==="opacity"&&i.push(()=>{const o=Math.max(-100,Math.min(100,-Math.log(1/(A[s+3]/255)-1)));qg[a.type](g,I,this.littleEndian,o)});i.push(()=>{I+=jA[a.type]})}for(let e=0;e<t;e++){for(const a of i)a();n&&(s+=4)}}}};VA.defaultPointScale=.001;let FI=VA;const GI=.28209479177387814,uI={char:(Q,A,I)=>Q.getInt8(A),uchar:(Q,A,I)=>Q.getUint8(A),short:(Q,A,I)=>Q.getInt16(A,I),ushort:(Q,A,I)=>Q.getUint16(A,I),int:(Q,A,I)=>Q.getInt32(A,I),uint:(Q,A,I)=>Q.getUint32(A,I),float:(Q,A,I)=>Q.getFloat32(A,I),double:(Q,A,I)=>Q.getFloat64(A,I)},qg={char:(Q,A,I,g)=>{Q.setInt8(A,g)},uchar:(Q,A,I,g)=>{Q.setUint8(A,g)},short:(Q,A,I,g)=>{Q.setInt16(A,g,I)},ushort:(Q,A,I,g)=>{Q.setUint16(A,g,I)},int:(Q,A,I,g)=>{Q.setInt32(A,g,I)},uint:(Q,A,I,g)=>{Q.setUint32(A,g,I)},float:(Q,A,I,g)=>{Q.setFloat32(A,g,I)},double:(Q,A,I,g)=>{Q.setFloat64(A,g,I)}},jA={char:1,uchar:1,short:2,ushort:2,int:4,uint:4,float:4,double:8},fI={char:127,uchar:255,short:32767,ushort:65535,int:2147483647,uint:4294967295,float:1,double:1},dQ={0:0,9:1,24:2,45:3},pQ={0:0,1:9,2:24,3:45};function zg(Q){let A=0;for(;Q[`f_rest_${A}`];)A+=1;const I=dQ[A];if(I==null)throw new Error(`Unsupported number of SH coefficients: ${A}`);return I}var gI=(Q=>(Q.PLY="ply",Q.SPZ="spz",Q.SPLAT="splat",Q.KSPLAT="ksplat",Q.PCSOGS="pcsogs",Q.PCSOGSZIP="pcsogszip",Q))(gI||{});function HQ(Q){const A=new DataView(Q.buffer);if((A.getUint32(0,!0)&16777215)===7957616)return"ply";if((A.getUint32(0,!0)&16777215)===559903){const I=JQ(Q,4);return new DataView(I.buffer).getUint32(0,!0)===1347635022?"spz":void 0}if(A.getUint32(0,!0)===67324752)return Tg(Q)?"pcsogszip":void 0}function KQ(Q){const A=Q.split(/[?#]/,1)[0],I=Math.max(A.lastIndexOf("/"),A.lastIndexOf("\\\\")),g=A.slice(I+1),B=g.lastIndexOf(".");return B<=0||B===g.length-1?"":g.slice(B+1).toLowerCase()}function bQ(Q){const A=KQ(Q);if(A==="ply")return"ply";if(A==="spz")return"spz";if(A==="splat")return"splat";if(A==="ksplat")return"ksplat"}function qQ(Q){try{let A;if(typeof Q=="string")A=Q;else{const g=Q instanceof ArrayBuffer?new Uint8Array(Q):Q;if(g.length>65536)return;A=new TextDecoder().decode(g)}const I=JSON.parse(A);if(!I||typeof I!="object"||Array.isArray(I))return;for(const g of["means","scales","quats","sh0"])if(!I[g]||typeof I[g]!="object"||Array.isArray(I[g])||!I[g].shape||!I[g].files||g!=="quats"&&(!I[g].mins||!I[g].maxs))return;return I}catch{return}}function Tg(Q){try{const A=Q instanceof ArrayBuffer?new Uint8Array(Q):Q;let I=null;const g=wQ(A,{filter:({name:C})=>C.split(/[\\\\/]/).pop()==="meta.json"?(I=C,!0):!1});if(!I)return;const B=qQ(g[I]);return B?{name:I,json:B}:void 0}catch{return}}class zQ{constructor({maxSplats:A=1}={}){this.numSplats=0,this.maxSplats=UQ(A).maxSplats,this.centers=new Float32Array(this.maxSplats*3),this.scales=new Float32Array(this.maxSplats*3),this.quaternions=new Float32Array(this.maxSplats*4),this.opacities=new Float32Array(this.maxSplats),this.colors=new Float32Array(this.maxSplats*3)}pushSplat(){const A=this.numSplats;return this.ensureIndex(A),this.numSplats+=1,A}unpushSplat(A){if(A===this.numSplats-1)this.numSplats-=1;else throw new Error("Cannot unpush splat from non-last position")}ensureCapacity(A){if(A>this.maxSplats){const I=Math.max(A,this.maxSplats*2),g=new Float32Array(I*3),B=new Float32Array(I*3),C=new Float32Array(I*4),t=new Float32Array(I),E=new Float32Array(I*3);if(g.set(this.centers),B.set(this.scales),C.set(this.quaternions),t.set(this.opacities),E.set(this.colors),this.centers=g,this.scales=B,this.quaternions=C,this.opacities=t,this.colors=E,this.sh1){const i=new Float32Array(I*9);i.set(this.sh1),this.sh1=i}if(this.sh2){const i=new Float32Array(I*15);i.set(this.sh2),this.sh2=i}if(this.sh3){const i=new Float32Array(I*21);i.set(this.sh3),this.sh3=i}this.maxSplats=I}}ensureIndex(A){this.ensureCapacity(A+1)}setCenter(A,I,g,B){this.centers[A*3]=I,this.centers[A*3+1]=g,this.centers[A*3+2]=B}setScale(A,I,g,B){this.scales[A*3]=I,this.scales[A*3+1]=g,this.scales[A*3+2]=B}setQuaternion(A,I,g,B,C){this.quaternions[A*4]=I,this.quaternions[A*4+1]=g,this.quaternions[A*4+2]=B,this.quaternions[A*4+3]=C}setOpacity(A,I){this.opacities[A]=I}setColor(A,I,g,B){this.colors[A*3]=I,this.colors[A*3+1]=g,this.colors[A*3+2]=B}setSh1(A,I){this.sh1||(this.sh1=new Float32Array(this.maxSplats*9));for(let g=0;g<9;++g)this.sh1[A*9+g]=I[g]}setSh2(A,I){this.sh2||(this.sh2=new Float32Array(this.maxSplats*15));for(let g=0;g<15;++g)this.sh2[A*15+g]=I[g]}setSh3(A,I){this.sh3||(this.sh3=new Float32Array(this.maxSplats*21));for(let g=0;g<21;++g)this.sh3[A*21+g]=I[g]}}async function Zg(Q,A){if(Q.quats.encoding!=="quaternion_packed")throw new Error("Unsupported quaternion encoding");const I=Q.means.shape[0],g=DI(I),B=new Uint32Array(g*4),C={},t=Promise.all([QI(A[Q.means.files[0]]),QI(A[Q.means.files[1]])]).then(e=>{for(let a=0;a<I;++a){const o=a*4,r=(e[0][o+0]+(e[1][o+0]<<8))/65535,c=(e[0][o+1]+(e[1][o+1]<<8))/65535,N=(e[0][o+2]+(e[1][o+2]<<8))/65535;let h=Q.means.mins[0]+(Q.means.maxs[0]-Q.means.mins[0])*r,w=Q.means.mins[1]+(Q.means.maxs[1]-Q.means.mins[1])*c,D=Q.means.mins[2]+(Q.means.maxs[2]-Q.means.mins[2])*N;h=Math.sign(h)*(Math.exp(Math.abs(h))-1),w=Math.sign(w)*(Math.exp(Math.abs(w))-1),D=Math.sign(D)*(Math.exp(Math.abs(D))-1),Lg(B,a,h,w,D)}}),E=QI(A[Q.scales.files[0]]).then(e=>{for(let a=0;a<I;++a){const o=a*4,r=e[o+0]/255,c=e[o+1]/255,N=e[o+2]/255,h=Q.scales.mins[0]+(Q.scales.maxs[0]-Q.scales.mins[0])*r,w=Q.scales.mins[1]+(Q.scales.maxs[1]-Q.scales.mins[1])*c,D=Q.scales.mins[2]+(Q.scales.maxs[2]-Q.scales.mins[2])*N;dg(B,a,Math.exp(h),Math.exp(w),Math.exp(D))}}),i=QI(A[Q.quats.files[0]]).then(e=>{const a=Math.sqrt(2);for(let o=0;o<I;++o){const r=o*4,c=(e[r+0]/255-.5)*a,N=(e[r+1]/255-.5)*a,h=(e[r+2]/255-.5)*a,w=Math.sqrt(Math.max(0,1-c*c-N*N-h*h)),D=e[r+3]-252,M=D===0?c:D===1?w:N,u=D<=1?N:D===2?w:h,R=D<=2?h:w;pg(B,o,M,u,R,D===0?w:c)}}),s=QI(A[Q.sh0.files[0]]).then(e=>{const a=.28209479177387814;for(let o=0;o<I;++o){const r=o*4,c=e[r+0]/255,N=e[r+1]/255,h=e[r+2]/255,w=e[r+3]/255,D=Q.sh0.mins[0]+(Q.sh0.maxs[0]-Q.sh0.mins[0])*c,M=Q.sh0.mins[1]+(Q.sh0.maxs[1]-Q.sh0.mins[1])*N,u=Q.sh0.mins[2]+(Q.sh0.maxs[2]-Q.sh0.mins[2])*h,R=Q.sh0.mins[3]+(Q.sh0.maxs[3]-Q.sh0.mins[3])*w,d=a*D+.5,G=a*M+.5,l=a*u+.5,k=1/(1+Math.exp(-R));SQ(B,o,d,G,l,k)}}),n=[t,E,i,s];if(Q.shN){const e=Q.shN.shape[1]>=45,a=Q.shN.shape[1]>=24,o=Q.shN.shape[1]>=9;o&&(C.sh1=new Uint32Array(I*2)),a&&(C.sh2=new Uint32Array(I*4)),e&&(C.sh3=new Uint32Array(I*4));const r=new Float32Array(9),c=new Float32Array(15),N=new Float32Array(21),h=Q.shN,w=Promise.all([_I(A[Q.shN.files[0]]),_I(A[Q.shN.files[1]])]).then(([D,M])=>{for(let u=0;u<I;++u){const R=u*4,d=M.rgba[R+0]+(M.rgba[R+1]<<8),G=(d&63)*15,k=(d>>>6)*D.width+G;for(let F=0;F<3;++F){if(o)for(let y=0;y<3;++y)r[y*3+F]=h.mins+(h.maxs-h.mins)*D.rgba[(k+y)*4+F]/255;if(a)for(let y=0;y<5;++y)c[y*3+F]=h.mins+(h.maxs-h.mins)*D.rgba[(k+3+y)*4+F]/255;if(e)for(let y=0;y<7;++y)N[y*3+F]=h.mins+(h.maxs-h.mins)*D.rgba[(k+8+y)*4+F]/255}o&&yI(C.sh1,u,r),a&&lI(C.sh2,u,c),e&&NI(C.sh3,u,N)}});n.push(w)}return await Promise.all(n),{packedArray:B,numSplats:I,extra:C}}let SI=null;async function _I(Q){if(!SI&&(SI=new OffscreenCanvas(1,1).getContext("webgl2"),!SI))throw new Error("Failed to create WebGL2 context");const A=new Blob([Q]),I=await createImageBitmap(A,{premultiplyAlpha:"none"}),g=SI,B=g.createTexture();g.bindTexture(g.TEXTURE_2D,B),g.pixelStorei(g.UNPACK_FLIP_Y_WEBGL,!0),g.texImage2D(g.TEXTURE_2D,0,g.RGBA,g.RGBA,g.UNSIGNED_BYTE,I),g.texParameteri(g.TEXTURE_2D,g.TEXTURE_MAG_FILTER,g.NEAREST),g.texParameteri(g.TEXTURE_2D,g.TEXTURE_MIN_FILTER,g.NEAREST);const C=g.createFramebuffer();g.bindFramebuffer(g.FRAMEBUFFER,C),g.framebufferTexture2D(g.FRAMEBUFFER,g.COLOR_ATTACHMENT0,g.TEXTURE_2D,B,0);const t=new Uint8Array(I.width*I.height*4);return g.readPixels(0,0,I.width,I.height,g.RGBA,g.UNSIGNED_BYTE,t),g.deleteTexture(B),g.deleteFramebuffer(C),{rgba:t,width:I.width,height:I.height}}async function QI(Q){const{rgba:A}=await _I(Q);return A}async function TQ(Q){var e;const A=Tg(Q);if(!A)throw new Error("Invalid PC SOGS zip file");const{name:I,json:g}=A,B=I.lastIndexOf("/"),C=I.lastIndexOf("\\\\"),t=I.slice(0,Math.max(B,C)+1),E=new Map,i=[...g.means.files,...g.scales.files,...g.quats.files,...g.sh0.files,...((e=g.shN)==null?void 0:e.files)??[]];for(const a of i)E.set(t+a,a);const s=await new Promise((a,o)=>{DQ(Q,{filter:({name:r})=>E.has(r)},(r,c)=>{r?o(r):a(c)})}),n={};for(const[a,o]of E.entries())n[o]=s[a];return await Zg(g,n)}class vg{constructor({fileBytes:A}){this.fileBytes=A instanceof ArrayBuffer?new Uint8Array(A):A,this.reader=new YQ({fileBytes:this.fileBytes});const I=new DataView(this.reader.read(16).buffer);if(I.getUint32(0,!0)!==1347635022)throw new Error("Invalid SPZ file");if(this.version=I.getUint32(4,!0),this.version<1||this.version>2)throw new Error(`Unsupported SPZ version: ${this.version}`);this.numSplats=I.getUint32(8,!0),this.shDegree=I.getUint8(12),this.fractionalBits=I.getUint8(13),this.flags=I.getUint8(14),this.flagAntiAlias=(this.flags&1)!==0,this.reserved=I.getUint8(15),this.parsed=!1}parseSplats(A,I,g,B,C,t){if(this.parsed)throw new Error("SPZ file already parsed");if(this.parsed=!0,this.version===1){const E=this.reader.read(this.numSplats*3*2),i=new Uint16Array(E.buffer);for(let s=0;s<this.numSplats;s++){const n=s*3,e=$(i[n]),a=$(i[n+1]),o=$(i[n+2]);A==null||A(s,e,a,o)}}else if(this.version===2){const E=1<<this.fractionalBits,i=this.reader.read(this.numSplats*3*3);for(let s=0;s<this.numSplats;s++){const n=s*9,e=((i[n+2]<<24|i[n+1]<<16|i[n]<<8)>>8)/E,a=((i[n+5]<<24|i[n+4]<<16|i[n+3]<<8)>>8)/E,o=((i[n+8]<<24|i[n+7]<<16|i[n+6]<<8)>>8)/E;A==null||A(s,e,a,o)}}else throw new Error("Unreachable");{const E=this.reader.read(this.numSplats);for(let i=0;i<this.numSplats;i++)I==null||I(i,E[i]/255)}{const E=this.reader.read(this.numSplats*3),i=Xg/.15;for(let s=0;s<this.numSplats;s++){const n=s*3,e=(E[n]/255-.5)*i+.5,a=(E[n+1]/255-.5)*i+.5,o=(E[n+2]/255-.5)*i+.5;g==null||g(s,e,a,o)}}{const E=this.reader.read(this.numSplats*3);for(let i=0;i<this.numSplats;i++){const s=i*3,n=Math.exp(E[s]/16-10),e=Math.exp(E[s+1]/16-10),a=Math.exp(E[s+2]/16-10);B==null||B(i,n,e,a)}}{const E=this.reader.read(this.numSplats*3);for(let i=0;i<this.numSplats;i++){const s=i*3,n=E[s]/127.5-1,e=E[s+1]/127.5-1,a=E[s+2]/127.5-1,o=Math.sqrt(Math.max(0,1-n*n-e*e-a*a));C==null||C(i,n,e,a,o)}}if(t&&this.shDegree>=1){const E=new Float32Array(9),i=this.shDegree>=2?new Float32Array(5*3):void 0,s=this.shDegree>=3?new Float32Array(7*3):void 0,n=this.reader.read(this.numSplats*_g[this.shDegree]*3);let e=0;for(let a=0;a<this.numSplats;a++){for(let o=0;o<9;++o)E[o]=(n[e+o]-128)/128;if(e+=9,i){for(let o=0;o<15;++o)i[o]=(n[e+o]-128)/128;e+=15}if(s){for(let o=0;o<21;++o)s[o]=(n[e+o]-128)/128;e+=21}t==null||t(a,E,i,s)}}}}const _g={1:3,2:8,3:15},Xg=.28209479177387814,ZQ=1347635022,vQ=2,_Q=1;class xA{constructor({numSplats:A,shDegree:I,fractionalBits:g=12,flagAntiAlias:B=!0}){this.clippedCount=0;const C=19+(I>=1?9:0)+(I>=2?15:0)+(I>=3?21:0),t=16+A*C;this.buffer=new ArrayBuffer(t),this.view=new DataView(this.buffer),this.view.setUint32(0,ZQ,!0),this.view.setUint32(4,vQ,!0),this.view.setUint32(8,A,!0),this.view.setUint8(12,I),this.view.setUint8(13,g),this.view.setUint8(14,B?_Q:0),this.view.setUint8(15,0),this.numSplats=A,this.shDegree=I,this.fractionalBits=g,this.fraction=1<<g,this.flagAntiAlias=B}setCenter(A,I,g,B){const C=Math.round(I*this.fraction),t=Math.max(-8388607,Math.min(8388607,C)),E=Math.round(g*this.fraction),i=Math.max(-8388607,Math.min(8388607,E)),s=Math.round(B*this.fraction),n=Math.max(-8388607,Math.min(8388607,s));(C!==t||E!==i||s!==n)&&(this.clippedCount+=1);const o=16+A*9;this.view.setUint8(o,t&255),this.view.setUint8(o+1,t>>8&255),this.view.setUint8(o+2,t>>16&255),this.view.setUint8(o+3,i&255),this.view.setUint8(o+4,i>>8&255),this.view.setUint8(o+5,i>>16&255),this.view.setUint8(o+6,n&255),this.view.setUint8(o+7,n>>8&255),this.view.setUint8(o+8,n>>16&255)}setAlpha(A,I){const g=16+this.numSplats*9+A;this.view.setUint8(g,Math.max(0,Math.min(255,Math.round(I*255))))}static scaleRgb(A){const I=((A-.5)/(Xg/.15)+.5)*255;return Math.max(0,Math.min(255,Math.round(I)))}setRgb(A,I,g,B){const C=16+this.numSplats*10+A*3;this.view.setUint8(C,xA.scaleRgb(I)),this.view.setUint8(C+1,xA.scaleRgb(g)),this.view.setUint8(C+2,xA.scaleRgb(B))}setScale(A,I,g,B){const C=16+this.numSplats*13+A*3;this.view.setUint8(C,Math.max(0,Math.min(255,Math.round((Math.log(I)+10)*16)))),this.view.setUint8(C+1,Math.max(0,Math.min(255,Math.round((Math.log(g)+10)*16)))),this.view.setUint8(C+2,Math.max(0,Math.min(255,Math.round((Math.log(B)+10)*16))))}setQuat(A,I,g,B,C){const t=16+this.numSplats*16+A*3,E=C<0;this.view.setUint8(t,Math.max(0,Math.min(255,Math.round(((E?-I:I)+1)*127.5)))),this.view.setUint8(t+1,Math.max(0,Math.min(255,Math.round(((E?-g:g)+1)*127.5)))),this.view.setUint8(t+2,Math.max(0,Math.min(255,Math.round(((E?-B:B)+1)*127.5))))}static quantizeSh(A,I){const g=Math.round(A*128)+128,B=1<<8-I,C=Math.floor((g+B/2)/B)*B;return Math.max(0,Math.min(255,C))}setSh(A,I,g,B){const C=_g[this.shDegree]||0,t=16+this.numSplats*19+A*C*3;for(let E=0;E<9;++E)this.view.setUint8(t+E,xA.quantizeSh(I[E],5));if(g){const E=t+9;for(let i=0;i<15;++i)this.view.setUint8(E+i,xA.quantizeSh(g[i],4));if(B){const i=E+15;for(let s=0;s<21;++s)this.view.setUint8(i+s,xA.quantizeSh(B[s],4))}}}async finalize(){const A=new Uint8Array(this.buffer),g=new ReadableStream({async start(t){t.enqueue(A),t.close()}}).pipeThrough(new CompressionStream("gzip")),C=await new Response(g).arrayBuffer();return console.log("Compressed",A.length,"bytes to",C.byteLength,"bytes"),new Uint8Array(C)}}async function XQ(Q){var n,e,a;const A=new zQ,{inputs:I,clipXyz:g,maxSh:B,fractionalBits:C=12,opacityThreshold:t}=Q;for(const o of I){let r=function(G){return G.multiplyScalar(D),G.applyQuaternion(M),G.add(u),G},c=function(G){return G.multiplyScalar(D),G},N=function(G){return G.premultiply(M),G},h=function(G){return!R||R.containsPoint(G)},w=function(G){return t!==void 0?G>=t:!0};const D=((n=o.transform)==null?void 0:n.scale)??1,M=new RA().fromArray(((e=o.transform)==null?void 0:e.quaternion)??[0,0,0,1]),u=new S().fromArray(((a=o.transform)==null?void 0:a.translate)??[0,0,0]),R=g?new Rg(new S().fromArray(g.min),new S().fromArray(g.max)):void 0;let d=o.fileType;switch(d||(d=HQ(o.fileBytes),!d&&o.pathOrUrl&&(d=bQ(o.pathOrUrl))),d){case gI.PLY:{const G=new FI({fileBytes:o.fileBytes});await G.parseHeader();let l=null;G.parseSplats((k,F,y,U,H,K,x,z,j,Z,P,V,_,q,b)=>{const J=r(new S(F,y,U));if(h(J)&&w(V)){l=A.pushSplat(),A.setCenter(l,J.x,J.y,J.z);const T=c(new S(H,K,x));A.setScale(l,T.x,T.y,T.z);const f=N(new RA(z,j,Z,P));A.setQuaternion(l,f.x,f.y,f.z,f.w),A.setOpacity(l,V),A.setColor(l,_,q,b)}else l=null},(k,F,y,U)=>{F&&l!==null&&A.setSh1(l,F),y&&l!==null&&A.setSh2(l,y),U&&l!==null&&A.setSh3(l,U)});break}case gI.SPZ:{const G=new vg({fileBytes:o.fileBytes}),l=new Int32Array(G.numSplats);l.fill(-1);const k=new Float32Array(G.numSplats*3),F=new S;G.parseSplats((y,U,H,K)=>{const x=r(new S(U,H,K));k[y*3]=x.x,k[y*3+1]=x.y,k[y*3+2]=x.z},(y,U)=>{F.fromArray(k,y*3),h(F)&&w(U)&&(l[y]=A.pushSplat(),A.setCenter(l[y],F.x,F.y,F.z),A.setOpacity(l[y],U))},(y,U,H,K)=>{l[y]>=0&&A.setColor(l[y],U,H,K)},(y,U,H,K)=>{if(l[y]>=0){const x=c(new S(U,H,K));A.setScale(l[y],x.x,x.y,x.z)}},(y,U,H,K,x)=>{if(l[y]>=0){const z=N(new RA(U,H,K,x));A.setQuaternion(l[y],z.x,z.y,z.z,z.w)}},(y,U,H,K)=>{l[y]>=0&&(A.setSh1(l[y],U),H&&A.setSh2(l[y],H),K&&A.setSh3(l[y],K))});break}case gI.SPLAT:Kg(o.fileBytes,G=>{},(G,l,k,F,y,U,H,K,x,z,j,Z,P,V,_)=>{const q=r(new S(l,k,F));if(h(q)&&w(Z)){const b=A.pushSplat();A.setCenter(b,q.x,q.y,q.z);const J=c(new S(y,U,H));A.setScale(b,J.x,J.y,J.z);const T=N(new RA(K,x,z,j));A.setQuaternion(b,T.x,T.y,T.z,T.w),A.setOpacity(b,Z),A.setColor(b,P,V,_)}});break;case gI.KSPLAT:{let G=null;mQ(o.fileBytes,l=>{},(l,k,F,y,U,H,K,x,z,j,Z,P,V,_,q)=>{const b=r(new S(k,F,y));if(h(b)&&w(P)){G=A.pushSplat(),A.setCenter(G,b.x,b.y,b.z);const J=c(new S(U,H,K));A.setScale(G,J.x,J.y,J.z);const T=N(new RA(x,z,j,Z));A.setQuaternion(G,T.x,T.y,T.z,T.w),A.setOpacity(G,P),A.setColor(G,V,_,q)}else G=null},(l,k,F,y)=>{G!==null&&(A.setSh1(G,k),F&&A.setSh2(G,F),y&&A.setSh3(G,y))});break}default:throw new Error(`transcodeSpz not implemented for ${d}`)}}const E=Math.min(B??3,A.sh3?3:A.sh2?2:A.sh1?1:0),i=new xA({numSplats:A.numSplats,shDegree:E,fractionalBits:C,flagAntiAlias:!0});for(let o=0;o<A.numSplats;++o){const r=o*3,c=o*4;i.setCenter(o,A.centers[r],A.centers[r+1],A.centers[r+2]),i.setScale(o,A.scales[r],A.scales[r+1],A.scales[r+2]),i.setQuat(o,A.quaternions[c],A.quaternions[c+1],A.quaternions[c+2],A.quaternions[c+3]),i.setAlpha(o,A.opacities[o]),i.setRgb(o,A.colors[r],A.colors[r+1],A.colors[r+2]),A.sh1&&E>=1&&i.setSh(o,A.sh1.slice(o*9,(o+1)*9),E>=2&&A.sh2?A.sh2.slice(o*15,(o+1)*15):void 0,E>=3&&A.sh3?A.sh3.slice(o*21,(o+1)*21):void 0)}return{fileBytes:await i.finalize(),clippedCount:i.clippedCount}}async function Wg(Q){const{name:A,args:I,id:g}=Q.data;let B,C;try{switch(A){case"unpackPly":{const{packedArray:t,fileBytes:E}=I,i=await WQ({packedArray:t,fileBytes:E});B={id:g,numSplats:i.numSplats,packedArray:i.packedArray,extra:i.extra};break}case"decodeSpz":{const{fileBytes:t}=I,E=jQ(t);B={id:g,numSplats:E.numSplats,packedArray:E.packedArray,extra:E.extra};break}case"decodeAntiSplat":{const{fileBytes:t}=I,E=xQ(t);B={id:g,numSplats:E.numSplats,packedArray:E.packedArray};break}case"decodeKsplat":{const{fileBytes:t}=I,E=LQ(t);B={id:g,numSplats:E.numSplats,packedArray:E.packedArray,extra:E.extra};break}case"decodePcSogs":{const{fileBytes:t,extraFiles:E}=I,i=JSON.parse(new TextDecoder().decode(t)),s=await Zg(i,E);B={id:g,numSplats:s.numSplats,packedArray:s.packedArray,extra:s.extra};break}case"decodePcSogsZip":{const{fileBytes:t}=I,E=await TQ(t);B={id:g,numSplats:E.numSplats,packedArray:E.packedArray,extra:E.extra};break}case"sortSplats":{const{totalSplats:t,readback:E,ordering:i}=I;B={id:g,readback:E,...VQ({totalSplats:t,readback:E,ordering:i})};break}case"sortDoubleSplats":{const{numSplats:t,readback:E,ordering:i}=I;B={id:g,readback:E,ordering:i,activeSplats:Pg(t,E,i)};break}case"sort32Splats":{const{numSplats:t,readback:E,ordering:i}=I;B={id:g,readback:E,ordering:i,activeSplats:$g(t,E,i)};break}case"transcodeSpz":{const t=I,E=await XQ(t);B={id:g,fileBytes:E,input:t};break}default:throw new Error(`Unknown name: ${A}`)}}catch(t){C=t,console.error(C)}self.postMessage({id:g,result:B,error:C},{transfer:fQ(B)})}async function WQ({packedArray:Q,fileBytes:A}){const I=new FI({fileBytes:A});await I.parseHeader();const g=I.numSplats,B={};return I.parseSplats((C,t,E,i,s,n,e,a,o,r,c,N,h,w,D)=>{vI(Q,C,t,E,i,s,n,e,a,o,r,c,N,h,w,D)},(C,t,E,i)=>{t&&(B.sh1||(B.sh1=new Uint32Array(g*2)),yI(B.sh1,C,t)),E&&(B.sh2||(B.sh2=new Uint32Array(g*4)),lI(B.sh2,C,E)),i&&(B.sh3||(B.sh3=new Uint32Array(g*4)),NI(B.sh3,C,i))}),{packedArray:Q,numSplats:g,extra:B}}function jQ(Q){const A=new vg({fileBytes:Q}),I=A.numSplats,g=DI(I),B=new Uint32Array(g*4),C={};return A.parseSplats((t,E,i,s)=>{Lg(B,t,E,i,s)},(t,E)=>{RQ(B,t,E)},(t,E,i,s)=>{kQ(B,t,E,i,s)},(t,E,i,s)=>{dg(B,t,E,i,s)},(t,E,i,s,n)=>{pg(B,t,E,i,s,n)},(t,E,i,s)=>{E&&(C.sh1||(C.sh1=new Uint32Array(I*2)),yI(C.sh1,t,E)),i&&(C.sh2||(C.sh2=new Uint32Array(I*4)),lI(C.sh2,t,i)),s&&(C.sh3||(C.sh3=new Uint32Array(I*4)),NI(C.sh3,t,s))}),{packedArray:B,numSplats:I,extra:C}}const XI=31744,kI=XI+1;let FA=null;function VQ({totalSplats:Q,readback:A,ordering:I}){FA||(FA=new Uint32Array(kI)),FA.fill(0);const g=A.map(i=>new Uint32Array(i.buffer)),B=g[0].length,C=Math.ceil(Q/B);let t=0;for(let i=0;i<C;++i){const s=g[i],n=Math.min(s.length,Q-t);for(let e=0;e<n;++e){const a=s[e]&32767;a<XI&&(FA[a]+=1)}t+=n}let E=0;for(let i=0;i<kI;++i){const s=E+FA[i];FA[i]=E,E=s}t=0;for(let i=0;i<C;++i){const s=g[i],n=Math.min(s.length,Q-t);for(let e=0;e<n;++e){const a=s[e]&32767;a<XI&&(I[FA[a]]=t+e,FA[a]+=1)}t+=n}if(FA[kI-1]!==E)throw new Error(`Expected ${E} active splats but got ${FA[kI-1]}`);return{activeSplats:E,ordering:I}}const WI=[];function jg(Q){WI.push(Q)}async function OQ(){self.addEventListener("message",jg),await Cg(),self.removeEventListener("message",jg),self.addEventListener("message",Wg);for(const Q of WI)Wg(Q);WI.length=0}OQ().catch(console.error)})();\n//# sourceMappingURL=worker-By511x3e.js.map\n', ag = typeof self < "u" && self.Blob && new Blob([YB], { type: "text/javascript;charset=utf-8" });
function oo(t) {
  let A;
  try {
    if (A = ag && (self.URL || self.webkitURL).createObjectURL(ag), !A) throw "";
    const e = new Worker(A, {
      name: t == null ? void 0 : t.name
    });
    return e.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(A);
    }), e;
  } catch {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(YB),
      {
        name: t == null ? void 0 : t.name
      }
    );
  } finally {
    A && (self.URL || self.webkitURL).revokeObjectURL(A);
  }
}
class ro {
  constructor() {
    this.messages = {}, this.messageIdNext = 0, this.worker = new oo(), this.worker.onmessage = (A) => this.onMessage(A);
  }
  makeMessageId() {
    return ++this.messageIdNext;
  }
  makeMessagePromiseId() {
    const A = this.makeMessageId(), e = new Promise((g, I) => {
      this.messages[A] = { resolve: g, reject: I };
    });
    return { id: A, promise: e };
  }
  onMessage(A) {
    const { id: e, result: g, error: I } = A.data, s = this.messages[e];
    s && (delete this.messages[e], I ? s.reject(I) : s.resolve(g));
  }
  // Invoke an RPC on the worker with the given name and arguments.
  // The normal usage of a worker is to run one activity at a time,
  // but this function allows for concurrent calls, tagging each request
  // with a unique message Id and awaiting a response to that same Id.
  // The method will automatically transfer any ArrayBuffers in the
  // arguments to the worker. If you'd like to transfer a copy of a
  // buffer then you must clone it before passing to this function.
  async call(A, e) {
    const { id: g, promise: I } = this.makeMessagePromiseId();
    return this.worker.postMessage(
      { name: A, args: e, id: g },
      { transfer: kI(e) }
    ), I;
  }
}
let JB = 4, ae = 0;
const vB = [], bB = [];
async function co() {
  const t = vB.shift();
  if (t)
    return t;
  if (ae < JB) {
    const A = new ro();
    return ae += 1, A;
  }
  return new Promise((A) => {
    bB.push(A);
  });
}
function ho(t) {
  if (ae > JB) {
    ae -= 1;
    return;
  }
  const A = bB.shift();
  if (A) {
    A(t);
    return;
  }
  vB.push(t);
}
async function Et(t) {
  const A = await co();
  try {
    return await t(A);
  } finally {
    ho(A);
  }
}
class lo extends Ei {
  constructor(A) {
    super(A), this.fileLoader = new ai(A);
  }
  load(A, e, g, I) {
    const s = this.manager.resolveURL(
      (this.path ?? "") + (A ?? "")
    ), Q = new Headers(this.requestHeader), B = this.withCredentials ? "include" : "same-origin", i = new Request(s, { headers: Q, credentials: B });
    let C = this.fileType;
    this.manager.itemStart(s), og(i, g).then(async (E) => {
      const n = [
        new ProgressEvent("progress", {
          lengthComputable: !0,
          loaded: E.byteLength,
          total: E.byteLength
        })
      ];
      function o() {
        if (g) {
          const h = n.every((w) => w.lengthComputable || w.loaded === 0 && w.total === 0), u = n.reduce((w, d) => w + d.loaded, 0), y = n.reduce((w, d) => w + d.total, 0);
          g(
            new ProgressEvent("progress", {
              lengthComputable: h,
              loaded: u,
              total: y
            })
          );
        }
      }
      const r = {}, l = [], c = eg(E);
      if (C === "pcsogs" && c === void 0)
        throw new Error("Invalid PC SOGS file");
      if (c !== void 0) {
        C = "pcsogs";
        for (const h of ["means", "scales", "quats", "sh0", "shN"]) {
          const u = c[h];
          if (u)
            for (const y of u.files) {
              const w = new URL(y, s).toString(), d = n.length;
              n.push(new ProgressEvent("progress")), this.manager.itemStart(w);
              const p = new Request(w, { headers: Q, credentials: B }), m = og(p, (N) => {
                n[d] = N, o();
              }).then((N) => {
                r[y] = N;
              }).catch((N) => {
                throw this.manager.itemError(w), N;
              }).finally(() => {
                this.manager.itemEnd(w);
              });
              l.push(m);
            }
        }
      }
      if (await Promise.all(l), e) {
        const h = await KB({
          input: E,
          extraFiles: r,
          fileType: C,
          pathOrUrl: s
        });
        this.packedSplats ? (this.packedSplats.initialize(h), e(this.packedSplats)) : e(new qA(h));
      }
    }).catch((E) => {
      this.manager.itemError(s), I == null || I(E);
    }).finally(() => {
      this.manager.itemEnd(s);
    });
  }
  async loadAsync(A, e) {
    return new Promise((g, I) => {
      this.load(
        A,
        (s) => {
          g(s);
        },
        e,
        I
      );
    });
  }
  parse(A) {
    return new WA({ packedSplats: A });
  }
}
async function og(t, A) {
  const e = await fetch(t);
  if (!e.ok)
    throw new Error(
      `${e.status} "${e.statusText}" fetching URL: ${t.url}`
    );
  if (!e.body)
    throw new Error(`Response body is null for URL: ${t.url}`);
  const g = e.body.getReader(), I = Number.parseInt(
    e.headers.get("Content-Length") || "0"
  ), s = Number.isNaN(I) ? 0 : I;
  let Q = 0;
  const B = [];
  for (; ; ) {
    const { done: E, value: n } = await g.read();
    if (E)
      break;
    B.push(n), Q += n.length, A && A(
      new ProgressEvent("progress", {
        lengthComputable: s !== 0,
        loaded: Q,
        total: s
      })
    );
  }
  const i = new Uint8Array(Q);
  let C = 0;
  for (const E of B)
    i.set(E, C), C += E.length;
  return i.buffer;
}
var vt = /* @__PURE__ */ ((t) => (t.PLY = "ply", t.SPZ = "spz", t.SPLAT = "splat", t.KSPLAT = "ksplat", t.PCSOGS = "pcsogs", t.PCSOGSZIP = "pcsogszip", t))(vt || {});
function HB(t) {
  const A = new DataView(t.buffer);
  if ((A.getUint32(0, !0) & 16777215) === 7957616)
    return "ply";
  if ((A.getUint32(0, !0) & 16777215) === 559903) {
    const e = TI(t, 4);
    return new DataView(e.buffer).getUint32(0, !0) === 1347635022 ? "spz" : void 0;
  }
  if (A.getUint32(0, !0) === 67324752)
    return wo(t) ? "pcsogszip" : void 0;
}
function uo(t) {
  const A = t.split(/[?#]/, 1)[0], e = Math.max(
    A.lastIndexOf("/"),
    A.lastIndexOf("\\")
  ), g = A.slice(e + 1), I = g.lastIndexOf(".");
  return I <= 0 || I === g.length - 1 ? "" : g.slice(I + 1).toLowerCase();
}
function TB(t) {
  const A = uo(t);
  if (A === "ply")
    return "ply";
  if (A === "spz")
    return "spz";
  if (A === "splat")
    return "splat";
  if (A === "ksplat")
    return "ksplat";
}
function Dr(t) {
  return eg(t) !== void 0;
}
function eg(t) {
  try {
    let A;
    if (typeof t == "string")
      A = t;
    else {
      const g = t instanceof ArrayBuffer ? new Uint8Array(t) : t;
      if (g.length > 65536)
        return;
      A = new TextDecoder().decode(g);
    }
    const e = JSON.parse(A);
    if (!e || typeof e != "object" || Array.isArray(e))
      return;
    for (const g of ["means", "scales", "quats", "sh0"])
      if (!e[g] || typeof e[g] != "object" || Array.isArray(e[g]) || !e[g].shape || !e[g].files || g !== "quats" && (!e[g].mins || !e[g].maxs))
        return;
    return e;
  } catch {
    return;
  }
}
function wo(t) {
  try {
    const A = t instanceof ArrayBuffer ? new Uint8Array(t) : t;
    let e = null;
    const g = Ri(A, {
      filter: ({ name: s }) => s.split(/[\\/]/).pop() === "meta.json" ? (e = s, !0) : !1
    });
    if (!e)
      return;
    const I = eg(g[e]);
    return I ? { name: e, json: I } : void 0;
  } catch {
    return;
  }
}
async function KB({
  input: t,
  extraFiles: A,
  fileType: e,
  pathOrUrl: g
}) {
  const I = t instanceof ArrayBuffer ? new Uint8Array(t) : t;
  let s = e;
  switch (e || (s = HB(I), !s && g && (s = TB(g))), s) {
    case "ply": {
      const Q = new Ee({ fileBytes: I });
      await Q.parseHeader();
      const B = Q.numSplats, i = fA(B).maxSplats, C = { fileBytes: I, packedArray: new Uint32Array(i * 4) };
      return await Et(async (E) => {
        const { packedArray: n, numSplats: o, extra: r } = await E.call(
          "unpackPly",
          C
        );
        return { packedArray: n, numSplats: o, extra: r };
      });
    }
    case "spz":
      return await Et(async (Q) => {
        const { packedArray: B, numSplats: i, extra: C } = await Q.call(
          "decodeSpz",
          {
            fileBytes: I
          }
        );
        return { packedArray: B, numSplats: i, extra: C };
      });
    case "splat":
      return await Et(async (Q) => {
        const { packedArray: B, numSplats: i } = await Q.call(
          "decodeAntiSplat",
          {
            fileBytes: I
          }
        );
        return { packedArray: B, numSplats: i };
      });
    case "ksplat":
      return await Et(async (Q) => {
        const { packedArray: B, numSplats: i, extra: C } = await Q.call(
          "decodeKsplat",
          { fileBytes: I }
        );
        return { packedArray: B, numSplats: i, extra: C };
      });
    case "pcsogs":
      return await Et(async (Q) => {
        const { packedArray: B, numSplats: i, extra: C } = await Q.call(
          "decodePcSogs",
          { fileBytes: I, extraFiles: A }
        );
        return { packedArray: B, numSplats: i, extra: C };
      });
    case "pcsogszip":
      return await Et(async (Q) => {
        const { packedArray: B, numSplats: i, extra: C } = await Q.call(
          "decodePcSogsZip",
          { fileBytes: I }
        );
        return { packedArray: B, numSplats: i, extra: C };
      });
    default:
      throw new Error(`Unknown splat file type: ${s}`);
  }
}
class yo {
  constructor({ maxSplats: A = 1 } = {}) {
    this.numSplats = 0, this.maxSplats = fA(A).maxSplats, this.centers = new Float32Array(this.maxSplats * 3), this.scales = new Float32Array(this.maxSplats * 3), this.quaternions = new Float32Array(this.maxSplats * 4), this.opacities = new Float32Array(this.maxSplats), this.colors = new Float32Array(this.maxSplats * 3);
  }
  pushSplat() {
    const A = this.numSplats;
    return this.ensureIndex(A), this.numSplats += 1, A;
  }
  unpushSplat(A) {
    if (A === this.numSplats - 1)
      this.numSplats -= 1;
    else
      throw new Error("Cannot unpush splat from non-last position");
  }
  ensureCapacity(A) {
    if (A > this.maxSplats) {
      const e = Math.max(A, this.maxSplats * 2), g = new Float32Array(e * 3), I = new Float32Array(e * 3), s = new Float32Array(e * 4), Q = new Float32Array(e), B = new Float32Array(e * 3);
      if (g.set(this.centers), I.set(this.scales), s.set(this.quaternions), Q.set(this.opacities), B.set(this.colors), this.centers = g, this.scales = I, this.quaternions = s, this.opacities = Q, this.colors = B, this.sh1) {
        const i = new Float32Array(e * 9);
        i.set(this.sh1), this.sh1 = i;
      }
      if (this.sh2) {
        const i = new Float32Array(e * 15);
        i.set(this.sh2), this.sh2 = i;
      }
      if (this.sh3) {
        const i = new Float32Array(e * 21);
        i.set(this.sh3), this.sh3 = i;
      }
      this.maxSplats = e;
    }
  }
  ensureIndex(A) {
    this.ensureCapacity(A + 1);
  }
  setCenter(A, e, g, I) {
    this.centers[A * 3] = e, this.centers[A * 3 + 1] = g, this.centers[A * 3 + 2] = I;
  }
  setScale(A, e, g, I) {
    this.scales[A * 3] = e, this.scales[A * 3 + 1] = g, this.scales[A * 3 + 2] = I;
  }
  setQuaternion(A, e, g, I, s) {
    this.quaternions[A * 4] = e, this.quaternions[A * 4 + 1] = g, this.quaternions[A * 4 + 2] = I, this.quaternions[A * 4 + 3] = s;
  }
  setOpacity(A, e) {
    this.opacities[A] = e;
  }
  setColor(A, e, g, I) {
    this.colors[A * 3] = e, this.colors[A * 3 + 1] = g, this.colors[A * 3 + 2] = I;
  }
  setSh1(A, e) {
    this.sh1 || (this.sh1 = new Float32Array(this.maxSplats * 9));
    for (let g = 0; g < 9; ++g)
      this.sh1[A * 9 + g] = e[g];
  }
  setSh2(A, e) {
    this.sh2 || (this.sh2 = new Float32Array(this.maxSplats * 15));
    for (let g = 0; g < 15; ++g)
      this.sh2[A * 15 + g] = e[g];
  }
  setSh3(A, e) {
    this.sh3 || (this.sh3 = new Float32Array(this.maxSplats * 21));
    for (let g = 0; g < 21; ++g)
      this.sh3[A * 21 + g] = e[g];
  }
}
var Do = `precision highp float;
precision highp int;
precision highp sampler2D;
precision highp usampler2D;
precision highp isampler2D;
precision highp sampler2DArray;
precision highp usampler2DArray;
precision highp isampler2DArray;
precision highp sampler3D;
precision highp usampler3D;
precision highp isampler3D;

#include <splatDefines>

uniform uint targetLayer;
uniform int targetBase;
uniform int targetCount;

out uvec4 target;

{{ GLOBALS }}

void produceSplat(int index) {
    {{ STATEMENTS }}
}

void main() {
    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);
    int index = targetIndex - targetBase;

    if ((index >= 0) && (index < targetCount)) {
        produceSplat(index);
    } else {
        target = uvec4(0u, 0u, 0u, 0u);
    }
}`;
const IA = class IA {
  constructor(A = {}) {
    this.maxSplats = 0, this.numSplats = 0, this.packedArray = null, this.isInitialized = !1, this.target = null, this.source = null, this.needsUpdate = !0, this.extra = {}, this.dyno = new gg({ packedSplats: this }), this.initialized = Promise.resolve(this), this.reinitialize(A);
  }
  reinitialize(A) {
    this.isInitialized = !1, A.url || A.fileBytes || A.construct ? this.initialized = this.asyncInitialize(A).then(() => (this.isInitialized = !0, this)) : (this.initialize(A), this.isInitialized = !0, this.initialized = Promise.resolve(this));
  }
  initialize(A) {
    A.packedArray ? (this.packedArray = A.packedArray, this.maxSplats = Math.floor(this.packedArray.length / 4), this.maxSplats = Math.floor(this.maxSplats / O) * O, this.numSplats = Math.min(
      this.maxSplats,
      A.numSplats ?? Number.POSITIVE_INFINITY
    )) : (this.maxSplats = A.maxSplats ?? 0, this.numSplats = 0), this.extra = A.extra ?? {};
  }
  async asyncInitialize(A) {
    const { url: e, fileBytes: g, construct: I } = A;
    if (e) {
      const s = new lo();
      s.packedSplats = this, await s.loadAsync(e);
    } else if (g) {
      const s = await KB({
        input: g,
        fileType: A.fileType,
        pathOrUrl: A.fileName ?? e
      });
      this.initialize(s);
    }
    if (I) {
      const s = I(this);
      s instanceof Promise && await s;
    }
  }
  // Call this when you are finished with the PackedSplats and want to free
  // any buffers it holds.
  dispose() {
    this.target && (this.target.dispose(), this.target = null), this.source && (this.source.dispose(), this.source = null);
  }
  // Ensures that this.packedArray can fit numSplats Gsplats. If it's too small,
  // resize exponentially and copy over the original data.
  //
  // Typically you don't need to call this, because calling this.setSplat(index, ...)
  // and this.pushSplat(...) will automatically call ensureSplats() so we have
  // enough splats.
  ensureSplats(A) {
    const e = A <= this.maxSplats ? this.maxSplats : (
      // Grow exponentially to avoid frequent reallocations
      Math.max(A, 2 * this.maxSplats)
    ), g = this.packedArray ? this.packedArray.length / 4 : 0;
    if (!this.packedArray || e > g) {
      this.maxSplats = fA(e).maxSplats;
      const I = new Uint32Array(this.maxSplats * 4);
      this.packedArray && I.set(this.packedArray), this.packedArray = I;
    }
    return this.packedArray;
  }
  // Ensure the extra array for the given level is large enough to hold numSplats
  ensureSplatsSh(A, e) {
    let g, I;
    if (A === 0)
      return this.ensureSplats(e);
    if (A === 1)
      g = 2, I = "sh1";
    else if (A === 2)
      g = 4, I = "sh2";
    else if (A === 3)
      g = 4, I = "sh3";
    else
      throw new Error(`Invalid level: ${A}`);
    let s = this.extra[I] ? this.extra[I].length / g : 0;
    const Q = e <= s ? s : Math.max(e, 2 * s);
    if (!this.extra[I] || Q > s) {
      s = fA(Q).maxSplats;
      const B = new Uint32Array(s * g);
      this.extra[I] && B.set(this.extra[I]), this.extra[I] = B;
    }
    return this.extra[I];
  }
  // Unpack the 16-byte Gsplat data at index into the Three.js components
  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,
  // opacity: number 0..1, color: THREE.Color 0..1.
  getSplat(A) {
    if (!this.packedArray || A >= this.numSplats)
      throw new Error("Invalid index");
    return Ye(this.packedArray, A);
  }
  // Set all PackedSplat components at index with the provided Gsplat attributes
  // (can be the same objects returned by getSplat). Ensures there is capacity
  // for at least index+1 Gsplats.
  setSplat(A, e, g, I, s, Q) {
    const B = this.ensureSplats(A + 1);
    Le(
      B,
      A,
      e.x,
      e.y,
      e.z,
      g.x,
      g.y,
      g.z,
      I.x,
      I.y,
      I.z,
      I.w,
      s,
      Q.r,
      Q.g,
      Q.b
    ), this.numSplats = Math.max(this.numSplats, A + 1);
  }
  // Effectively calls this.setSplat(this.numSplats++, center, ...), useful on
  // construction where you just want to iterate and create a collection of Gsplats.
  pushSplat(A, e, g, I, s) {
    const Q = this.ensureSplats(this.numSplats + 1);
    Le(
      Q,
      this.numSplats,
      A.x,
      A.y,
      A.z,
      e.x,
      e.y,
      e.z,
      g.x,
      g.y,
      g.z,
      g.w,
      I,
      s.r,
      s.g,
      s.b
    ), ++this.numSplats;
  }
  // Iterate over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat
  // and invoke the callback function with the Gsplat attributes.
  forEachSplat(A) {
    if (!(!this.packedArray || !this.numSplats))
      for (let e = 0; e < this.numSplats; ++e) {
        const g = Ye(this.packedArray, e);
        A(
          e,
          g.center,
          g.scales,
          g.quaternion,
          g.opacity,
          g.color
        );
      }
  }
  // Ensures our PackedSplats.target render target has enough space to generate
  // maxSplats total Gsplats, and reallocate if not large enough.
  ensureGenerate(A) {
    if (this.target && (A ?? 1) <= this.maxSplats)
      return !1;
    this.dispose();
    const e = fA(A ?? 1), { width: g, height: I, depth: s } = e;
    return this.maxSplats = e.maxSplats, this.target = new a.WebGLArrayRenderTarget(g, I, s, {
      depthBuffer: !1,
      stencilBuffer: !1,
      generateMipmaps: !1,
      magFilter: a.NearestFilter,
      minFilter: a.NearestFilter
    }), this.target.texture.format = a.RGBAIntegerFormat, this.target.texture.type = a.UnsignedIntType, this.target.texture.internalFormat = "RGBA32UI", this.target.scissorTest = !0, !0;
  }
  // Given an array of splatCounts (.numSplats for each
  // SplatGenerator/SplatMesh in the scene), compute a
  // "mapping layout" in the composite array of generated outputs.
  generateMapping(A) {
    let e = 0;
    const g = A.map((I) => {
      const s = e, Q = Math.ceil(I / O) * O;
      return e += Q, { base: s, count: I };
    });
    return { maxSplats: e, mapping: g };
  }
  // Returns a THREE.DataArrayTexture representing the PackedSplats content as
  // a Uint32x4 data array texture (2048 x 2048 x depth in size)
  getTexture() {
    return this.target ? this.target.texture : this.source || this.packedArray ? this.maybeUpdateSource() : IA.getEmpty();
  }
  // Check if source texture needs to be created/updated
  maybeUpdateSource() {
    if (!this.packedArray)
      throw new Error("No packed splats");
    if (this.needsUpdate || !this.source) {
      if (this.needsUpdate = !1, this.source) {
        const { width: A, height: e, depth: g } = this.source.image;
        this.maxSplats !== A * e * g && (this.source.dispose(), this.source = null);
      }
      if (this.source)
        this.packedArray.buffer !== this.source.image.data.buffer && (this.source.image.data = new Uint8Array(this.packedArray.buffer));
      else {
        const { width: A, height: e, depth: g } = fA(this.maxSplats);
        this.source = new a.DataArrayTexture(
          this.packedArray,
          A,
          e,
          g
        ), this.source.format = a.RGBAIntegerFormat, this.source.type = a.UnsignedIntType, this.source.internalFormat = "RGBA32UI", this.source.needsUpdate = !0;
      }
      this.source.needsUpdate = !0;
    }
    return this.source;
  }
  // Can be used where you need an uninitialized THREE.DataArrayTexture like
  // a uniform you will update with the result of this.getTexture() later.
  static getEmpty() {
    if (!IA.emptySource) {
      const { width: A, height: e, depth: g, maxSplats: I } = fA(1), s = new Uint32Array(I * 4);
      IA.emptySource = new a.DataArrayTexture(
        s,
        A,
        e,
        g
      ), IA.emptySource.format = a.RGBAIntegerFormat, IA.emptySource.type = a.UnsignedIntType, IA.emptySource.internalFormat = "RGBA32UI", IA.emptySource.needsUpdate = !0;
    }
    return IA.emptySource;
  }
  // Get a program and THREE.RawShaderMaterial for a given GsplatGenerator,
  // generating it if necessary and caching the result.
  prepareProgramMaterial(A) {
    let e = IA.generatorProgram.get(A);
    if (!e) {
      const I = SA(
        { index: "int" },
        { output: "uvec4" },
        ({ index: s }) => {
          A.inputs.index = s;
          const Q = A.outputs.gsplat;
          return { output: jg(Q) };
        }
      );
      IA.programTemplate || (IA.programTemplate = new Pe(
        Do
      )), e = new Oe({
        graph: I,
        inputs: { index: "index" },
        outputs: { output: "target" },
        template: IA.programTemplate
      }), Object.assign(e.uniforms, {
        targetLayer: { value: 0 },
        targetBase: { value: 0 },
        targetCount: { value: 0 }
      }), IA.generatorProgram.set(A, e);
    }
    const g = e.prepareMaterial();
    return IA.fullScreenQuad.material = g, { program: e, material: g };
  }
  saveRenderState(A) {
    return {
      xrEnabled: A.xr.enabled,
      autoClear: A.autoClear
    };
  }
  resetRenderState(A, e) {
    A.setRenderTarget(null), A.xr.enabled = e.xrEnabled, A.autoClear = e.autoClear;
  }
  // Executes a dyno program specified by generator which is any DynoBlock that
  // maps { index: "int" } to { gsplat: Gsplat }. This is called in
  // SparkRenderer.updateInternal() to re-generate Gsplats in the scene for
  // SplatGenerator instances whose version is newer than what was generated
  // for it last time.
  generate({
    generator: A,
    base: e,
    count: g,
    renderer: I
  }) {
    if (!this.target)
      throw new Error("Target must be initialized with ensureSplats");
    if (e + g > this.maxSplats)
      throw new Error("Base + count exceeds maxSplats");
    const { program: s, material: Q } = this.prepareProgramMaterial(A);
    s.update();
    const B = this.saveRenderState(I), i = Math.ceil((e + g) / O) * O, C = O * It;
    for (Q.uniforms.targetBase.value = e, Q.uniforms.targetCount.value = g; e < i; ) {
      const E = Math.floor(e / C);
      Q.uniforms.targetLayer.value = E;
      const n = E * C, o = Math.floor((e - n) / O), r = Math.min(
        It,
        Math.ceil((i - n) / O)
      );
      this.target.scissor.set(
        0,
        o,
        O,
        r - o
      ), I.setRenderTarget(this.target, E), I.xr.enabled = !1, I.autoClear = !1, IA.fullScreenQuad.render(I), e += O * (r - o);
    }
    return this.resetRenderState(I, B), { nextBase: i };
  }
};
IA.emptySource = null, IA.programTemplate = null, IA.generatorProgram = /* @__PURE__ */ new Map(), IA.fullScreenQuad = new lg(
  new a.RawShaderMaterial({ visible: !1 })
);
let qA = IA;
class gg extends k {
  constructor({ packedSplats: A } = {}) {
    super({
      key: "packedSplats",
      type: Xt,
      globals: () => [he],
      value: {
        texture: qA.getEmpty(),
        numSplats: 0
      },
      update: (e) => {
        var g, I;
        return e.texture = ((g = this.packedSplats) == null ? void 0 : g.getTexture()) ?? qA.getEmpty(), e.numSplats = ((I = this.packedSplats) == null ? void 0 : I.numSplats) ?? 0, e;
      }
    }), this.packedSplats = A;
  }
}
class Ke extends a.InstancedBufferGeometry {
  constructor(A, e) {
    super(), this.ordering = A, this.setAttribute("position", new a.BufferAttribute(po, 3)), this.setIndex(new a.BufferAttribute(fo, 1)), this._maxInstanceCount = A.length, this.instanceCount = e, this.attribute = new a.InstancedBufferAttribute(A, 1, !1, 1), this.attribute.setUsage(a.DynamicDrawUsage), this.setAttribute("splatIndex", this.attribute);
  }
  update(A, e) {
    this.ordering = A, this.attribute.array = A, this.instanceCount = e, this.attribute.addUpdateRange(0, e), this.attribute.needsUpdate = !0;
  }
}
const po = new Float32Array([
  -1,
  -1,
  0,
  1,
  -1,
  0,
  1,
  1,
  0,
  -1,
  1,
  0
]), fo = new Uint16Array([0, 1, 2, 0, 2, 3]), gt = class gt {
  constructor(A) {
    if (this.lastTime = null, this.encodeLinear = !1, this.superXY = 1, this.display = null, this.sorting = null, this.pending = null, this.sortingCheck = !1, this.readback16 = new Uint16Array(0), this.readback32 = new Uint32Array(0), this.spark = A.spark, this.camera = A.camera, this.viewToWorld = A.viewToWorld ?? new a.Matrix4(), A.target) {
      const { width: e, height: g, doubleBuffer: I } = A.target, s = Math.max(1, Math.min(4, A.target.superXY ?? 1));
      if (this.superXY = s, e * s > 8192 || g * s > 8192)
        throw new Error("Target size too large");
      this.target = new a.WebGLRenderTarget(
        e * s,
        g * s,
        {
          format: a.RGBAFormat,
          type: a.UnsignedByteType,
          colorSpace: a.SRGBColorSpace
        }
      ), I && (this.back = new a.WebGLRenderTarget(
        e * s,
        g * s,
        {
          format: a.RGBAFormat,
          type: a.UnsignedByteType,
          colorSpace: a.SRGBColorSpace
        }
      )), this.encodeLinear = !0;
    }
    this.onTextureUpdated = A.onTextureUpdated, this.sortRadial = A.sortRadial ?? !0, this.sortDistance = A.sortDistance, this.sortCoorient = A.sortCoorient, this.depthBias = A.depthBias, this.sort360 = A.sort360, this.sort32 = A.sort32, this.orderingFreelist = new RI({
      allocate: (e) => new Uint32Array(e),
      valid: (e, g) => e.length === g
    }), this.autoUpdate = !1, this.setAutoUpdate(A.autoUpdate ?? !1);
  }
  // Call this when you are done with the SparkViewpoint and want to
  // free up its resources (GPU targets, pixel buffers, etc.)
  dispose() {
    var A;
    this.setAutoUpdate(!1), this.target && (this.target.dispose(), this.target = void 0), this.back && (this.back.dispose(), this.back = void 0), this.display && (this.spark.releaseAccumulator(this.display.accumulator), this.display.geometry.dispose(), this.display = null), (A = this.pending) != null && A.accumulator && (this.spark.releaseAccumulator(this.pending.accumulator), this.pending = null);
  }
  // Use this function to change whether this viewpoint will auto-update
  // its sort order whenever the attached SparkRenderer updates the Gsplats.
  // Turn this on or off depending on whether you expect to do renders from
  // this viewpoint most frames.
  setAutoUpdate(A) {
    !this.autoUpdate && A ? this.spark.autoViewpoints.push(this) : this.autoUpdate && !A && (this.spark.autoViewpoints = this.spark.autoViewpoints.filter(
      (e) => e !== this
    )), this.autoUpdate = A;
  }
  // See below async prepareRenderPixels() for explanation of parameters.
  // Awaiting this method updates the Gsplats in the scene and performs a sort of the
  // Gsplats from this viewpoint, preparing it for a subsequent this.renderTarget()
  // call in the same tick.
  async prepare({
    scene: A,
    camera: e,
    viewToWorld: g,
    update: I,
    forceOrigin: s
  }) {
    var B;
    for (g ? this.viewToWorld = g : (this.camera = e ?? this.camera, this.camera && (this.camera.updateMatrixWorld(), this.viewToWorld = this.camera.matrixWorld.clone())); I ?? !0; ) {
      const i = s ? this.viewToWorld : void 0;
      if (this.spark.updateInternal({ scene: A, originToWorld: i }))
        break;
      await new Promise((E) => setTimeout(E, 10));
    }
    const Q = this.spark.active;
    Q !== ((B = this.display) == null ? void 0 : B.accumulator) && (this.spark.active.refCount += 1), await this.sortUpdate({ accumulator: Q, viewToWorld: this.viewToWorld });
  }
  // Render out the viewpoint to the view target RGBA buffer.
  // Swaps buffers if doubleBuffer: true was set.
  // Calls onTextureUpdated(texture) with the resulting texture.
  renderTarget({
    scene: A,
    camera: e
  }) {
    var I;
    const g = this.back ?? this.target;
    if (!g)
      throw new Error("Must initialize SparkViewpoint with target");
    if (e = e ?? this.camera, !e)
      throw new Error("Must provide camera");
    if (e instanceof a.PerspectiveCamera) {
      const s = new a.PerspectiveCamera().copy(e, !1);
      s.aspect = g.width / g.height, s.updateProjectionMatrix(), e = s;
    }
    this.viewToWorld = e.matrixWorld.clone();
    try {
      this.spark.renderer.setRenderTarget(g), this.spark.prepareViewpoint(this), this.spark.renderer.render(A, e);
    } finally {
      this.spark.prepareViewpoint(this.spark.defaultView), this.spark.renderer.setRenderTarget(null);
    }
    g !== this.target && ([this.target, this.back] = [this.back, this.target]), (I = this.onTextureUpdated) == null || I.call(this, g.texture);
  }
  // Read back the previously rendered target image as a Uint8Array of packed
  // RGBA values (in that order). If superXY was set greater than 1 then
  // downsampling is performed in the target pixel array with simple averaging
  // to derive the returned pixel values. Subsequent calls to this.readTarget()
  // will reuse the same buffers to minimize memory allocations.
  async readTarget() {
    if (!this.target)
      throw new Error("Must initialize SparkViewpoint with target");
    const { width: A, height: e } = this.target, g = A * e * 4;
    (!this.superPixels || this.superPixels.length < g) && (this.superPixels = new Uint8Array(g)), await this.spark.renderer.readRenderTargetPixelsAsync(
      this.target,
      0,
      0,
      A,
      e,
      this.superPixels
    );
    const { superXY: I } = this;
    if (I === 1)
      return this.superPixels;
    const s = A / I, Q = e / I, B = s * Q * 4;
    (!this.pixels || this.pixels.length < B) && (this.pixels = new Uint8Array(B));
    const { superPixels: i, pixels: C } = this, E = I * I;
    for (let n = 0; n < Q; n++) {
      const o = n * s;
      for (let r = 0; r < s; r++) {
        const l = r * I;
        let c = 0, h = 0, u = 0, y = 0;
        for (let d = 0; d < I; d++) {
          const p = (n * I + d) * this.target.width;
          for (let m = 0; m < I; m++) {
            const N = (p + l + m) * 4;
            c += i[N], h += i[N + 1], u += i[N + 2], y += i[N + 3];
          }
        }
        const w = (o + r) * 4;
        C[w] = c / E, C[w + 1] = h / E, C[w + 2] = u / E, C[w + 3] = y / E;
      }
    }
    return C;
  }
  // Render out a viewpoint as a Uint8Array of RGBA values for the provided scene
  // and any camera/viewToWorld viewpoint overrides. By default update is true,
  // which triggers its SparkRenderer to check and potentially update the Gsplats.
  // Setting update to false disables this and sorts the Gsplats as they are.
  // Setting forceOrigin (default: false) to true forces the view update to
  // recalculate the splats with this view origin, potentially altering any
  // view-dependent effects. If you expect view-dependent effects to play a role
  // in the rendering quality, enable this.
  //
  // Underneath, prepareRenderPixels() simply calls await this.prepare(...),
  // this.renderTarget(...), and finally returns the result this.readTarget(),
  // a Promise to a Uint8Array with RGBA values for all the pixels (potentially
  // downsampled if the superXY parameter was used). These steps can also be called
  // manually, for example if you need to alter the scene before and after
  // this.renderTarget(...) to hide UI elements from being rendered.
  async prepareRenderPixels({
    scene: A,
    camera: e,
    viewToWorld: g,
    update: I,
    forceOrigin: s
  }) {
    return await this.prepare({ scene: A, camera: e, viewToWorld: g, update: I, forceOrigin: s }), this.renderTarget({ scene: A, camera: e }), this.readTarget();
  }
  // This is called automatically by SparkRenderer, there is no need to call it!
  // The method cannot be private because then SparkRenderer would
  // not be able to call it.
  autoPoll({ accumulator: A }) {
    var s, Q, B, i;
    this.camera && (this.camera.updateMatrixWorld(), this.viewToWorld = this.camera.matrixWorld.clone());
    let e = !1, g = !1;
    if (!this.display)
      e = !0;
    else if (A) {
      e = !0;
      const { mappingVersion: C } = this.display.accumulator;
      A.mappingVersion === C && (this.spark.releaseAccumulator(this.display.accumulator), this.display.accumulator = A, g = !0);
    }
    const I = ((s = this.sorting) == null ? void 0 : s.viewToWorld) ?? ((Q = this.display) == null ? void 0 : Q.viewToWorld);
    I && !ie({
      matrix1: this.viewToWorld,
      matrix2: I,
      // By default update sort each 1 cm
      maxDistance: this.sortDistance ?? 0.01,
      // By default for radial sort, update for intermittent movement so that
      // we bring back splats culled by being behind the camera.
      // For depth sort, small rotations can change sort order a lot, so
      // update sort for even small rotations.
      minCoorient: this.sortCoorient ?? this.sortRadial ? 0.99 : 0.999
    }) && (e = !0), e && (A && (A.refCount += 1), A && ((B = this.pending) != null && B.accumulator) && this.pending.accumulator !== ((i = this.display) == null ? void 0 : i.accumulator) && this.spark.releaseAccumulator(this.pending.accumulator), this.pending = { accumulator: A, viewToWorld: this.viewToWorld, displayed: g }, this.driveSort());
  }
  async driveSort() {
    var A;
    for (; ; ) {
      if (this.sorting || !this.pending)
        return;
      const { viewToWorld: e, displayed: g } = this.pending;
      let I = this.pending.accumulator ?? ((A = this.display) == null ? void 0 : A.accumulator);
      if (I || (I = this.spark.active, I.refCount += 1), this.pending = null, !I)
        throw new Error("No accumulator to sort");
      this.sorting = { viewToWorld: e }, await this.sortUpdate({ accumulator: I, viewToWorld: e, displayed: g }), this.sorting = null;
    }
  }
  async sortUpdate({
    accumulator: A,
    viewToWorld: e,
    displayed: g = !1
  }) {
    if (this.sortingCheck)
      throw new Error("Only one sort at a time");
    this.sortingCheck = !0, A = A ?? this.spark.active;
    const { numSplats: I, maxSplats: s } = A.splats;
    let Q = 0, B = this.orderingFreelist.alloc(s);
    if (I > 0) {
      const {
        reader: i,
        doubleSortReader: C,
        sort32Reader: E,
        dynoSortRadial: n,
        dynoOrigin: o,
        dynoDirection: r,
        dynoDepthBias: l,
        dynoSort360: c,
        dynoSplats: h
      } = gt.makeSorter(), u = this.sort32 ?? !1;
      let y;
      if (u)
        this.readback32 = i.ensureBuffer(s, this.readback32), y = this.readback32;
      else {
        const f = Math.ceil(s / 2);
        this.readback16 = i.ensureBuffer(f, this.readback16), y = this.readback16;
      }
      const w = A.toWorld.clone().invert(), d = e.clone().premultiply(w);
      n.value = this.sort360 ? !0 : this.sortRadial, o.value.set(0, 0, 0).applyMatrix4(d), r.value.set(0, 0, -1).applyMatrix4(d).sub(o.value).normalize(), l.value = this.depthBias ?? 1, c.value = this.sort360 ?? !1, h.packedSplats = A.splats;
      const p = u ? E : C, m = u ? I : Math.ceil(I / 2);
      await i.renderReadback({
        renderer: this.spark.renderer,
        reader: p,
        count: m,
        readback: y
      });
      const N = await Et(async (f) => {
        const D = u ? "sort32Splats" : "sortDoubleSplats";
        return f.call(D, {
          maxSplats: s,
          numSplats: I,
          readback: y,
          ordering: B
        });
      });
      u ? this.readback32 = N.readback : this.readback16 = N.readback, B = N.ordering, Q = N.activeSplats;
    }
    this.updateDisplay({
      accumulator: A,
      viewToWorld: e,
      ordering: B,
      activeSplats: Q,
      displayed: g
    }), this.sortingCheck = !1;
  }
  updateDisplay({
    accumulator: A,
    viewToWorld: e,
    ordering: g,
    activeSplats: I,
    displayed: s = !1
  }) {
    if (!this.display)
      this.display = {
        accumulator: A,
        viewToWorld: e,
        geometry: new Ke(g, I)
      };
    else {
      !s && A !== this.display.accumulator && (this.spark.releaseAccumulator(this.display.accumulator), this.display.accumulator = A), this.display.viewToWorld = e;
      const Q = this.display.geometry.ordering;
      Q.length === g.length ? this.display.geometry.update(g, I) : (this.display.geometry.dispose(), this.display.geometry = new Ke(g, I)), this.orderingFreelist.free(Q);
    }
    this.spark.viewpoint === this && this.spark.prepareViewpoint(this);
  }
  static makeSorter() {
    if (!gt.dynos) {
      const A = new Be({ value: !0 }), e = new Ft({ value: new a.Vector3() }), g = new Ft({ value: new a.Vector3() }), I = new ot({ value: 1 }), s = new Be({ value: !1 }), Q = new gg(), B = new ne(), i = SA(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index: E }) => {
          if (!E)
            throw new Error("No index");
          const n = {
            sortRadial: A,
            sortOrigin: e,
            sortDirection: g,
            sortDepthBias: I,
            sort360: s
          }, o = EA(E, K("int", 2)), r = mt(Q, o), l = Fe({ gsplat: r, ...n }), c = mt(
            Q,
            pA(o, K("int", 1))
          ), h = Fe({ gsplat: c, ...n }), u = KA({
            vectorType: "vec2",
            x: l,
            y: h
          });
          return { rgba8: ve(Zs(u)) };
        }
      ), C = SA(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index: E }) => {
          if (!E)
            throw new Error("No index");
          const n = {
            sortRadial: A,
            sortOrigin: e,
            sortDirection: g,
            sortDepthBias: I,
            sort360: s
          }, o = mt(Q, E), r = Fe({ gsplat: o, ...n });
          return { rgba8: ve(Vs(r)) };
        }
      );
      gt.dynos = {
        dynoSortRadial: A,
        dynoOrigin: e,
        dynoDirection: g,
        dynoDepthBias: I,
        dynoSort360: s,
        dynoSplats: Q,
        reader: B,
        doubleSortReader: i,
        sort32Reader: C
      };
    }
    return gt.dynos;
  }
};
gt.EMPTY_TEXTURE = new a.Texture(), gt.dynos = null;
let oe = gt;
const No = oA(`
  float computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 sortDirection, float sortDepthBias, bool sort360) {
    if (!isGsplatActive(gsplat.flags)) {
      return INFINITY;
    }

    vec3 center = gsplat.center - sortOrigin;
    float biasedDepth = dot(center, sortDirection) + sortDepthBias;
    if (!sort360 && (biasedDepth <= 0.0)) {
      return INFINITY;
    }

    return sortRadial ? length(center) : biasedDepth;
  }
`);
function Fe({
  gsplat: t,
  sortRadial: A,
  sortOrigin: e,
  sortDirection: g,
  sortDepthBias: I,
  sort360: s
}) {
  return jt({
    inTypes: {
      gsplat: P,
      sortRadial: "bool",
      sortOrigin: "vec3",
      sortDirection: "vec3",
      sortDepthBias: "float",
      sort360: "bool"
    },
    outTypes: { metric: "float" },
    globals: () => [FA, No],
    inputs: {
      gsplat: t,
      sortRadial: A,
      sortOrigin: e,
      sortDirection: g,
      sortDepthBias: I,
      sort360: s
    },
    statements: ({ inputs: Q, outputs: B }) => {
      const {
        gsplat: i,
        sortRadial: C,
        sortOrigin: E,
        sortDirection: n,
        sortDepthBias: o,
        sort360: r
      } = Q;
      return UA(`
        ${B.metric} = computeSort(${i}, ${C}, ${E}, ${n}, ${o}, ${r});
      `);
    }
  }).outputs.metric;
}
class Ge {
  constructor() {
    this.splats = new qA(), this.toWorld = new a.Matrix4(), this.mapping = [], this.refCount = 0, this.splatsVersion = -1, this.mappingVersion = -1;
  }
  ensureGenerate(A) {
    this.splats.ensureGenerate(A) && (this.mapping = []);
  }
  // Generate all Gsplats from an array of generators
  generateSplats({
    renderer: A,
    modifier: e,
    generators: g,
    forceUpdate: I,
    originToWorld: s
  }) {
    const Q = this.mapping.reduce((C, E) => (C.set(E.node, E), C), /* @__PURE__ */ new Map());
    let B = 0, i = 0;
    for (const { node: C, generator: E, version: n, base: o, count: r } of g) {
      const l = Q.get(C);
      if ((I || E !== (l == null ? void 0 : l.generator) || n !== (l == null ? void 0 : l.version) || o !== (l == null ? void 0 : l.base) || r !== (l == null ? void 0 : l.count)) && E && r > 0) {
        const c = e.apply(E);
        try {
          this.splats.generate({
            generator: c,
            base: o,
            count: r,
            renderer: A
          });
        } catch (h) {
          C.generator = void 0, C.generatorError = h;
        }
        B += 1;
      }
      i = Math.max(i, o + r);
    }
    return this.splats.numSplats = i, this.toWorld = s, this.mapping = g, B !== 0;
  }
  // Check if this accumulator has exactly the same generator mapping as
  // the previous one. If so, we can reuse the Gsplat sort order.
  hasCorrespondence(A) {
    return this.mapping.length !== A.mapping.length ? !1 : this.mapping.every(({ node: e, base: g, count: I }, s) => {
      const {
        node: Q,
        base: B,
        count: i
      } = A.mapping[s];
      return e === Q && g === B && I === i;
    });
  }
}
var Mo = `const float LN_SCALE_MIN = -12.0;
const float LN_SCALE_MAX = 9.0;
const float LN_RESCALE = (LN_SCALE_MAX - LN_SCALE_MIN) / 254.0; 

const uint SPLAT_TEX_WIDTH_BITS = 11u;
const uint SPLAT_TEX_HEIGHT_BITS = 11u;
const uint SPLAT_TEX_DEPTH_BITS = 11u;
const uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;

const uint SPLAT_TEX_WIDTH = 1u << SPLAT_TEX_WIDTH_BITS;
const uint SPLAT_TEX_HEIGHT = 1u << SPLAT_TEX_HEIGHT_BITS;
const uint SPLAT_TEX_DEPTH = 1u << SPLAT_TEX_DEPTH_BITS;

const uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1u;
const uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;
const uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;

const uint F16_INF = 0x7c00u;
const float PI = 3.1415926535897932384626433832795;

const float INFINITY = 1.0 / 0.0;
const float NEG_INFINITY = -INFINITY;

const float MAX_PIXEL_RADIUS = 512.0;
const float MIN_ALPHA = 0.5 * (1.0 / 255.0); 
const float MAX_STDDEV = sqrt(8.0);

float sqr(float x) {
    return x * x;
}

float pow4(float x) {
    float x2 = x * x;
    return x2 * x2;
}

float pow8(float x) {
    float x4 = pow4(x);
    return x4 * x4;
}

vec3 srgbToLinear(vec3 rgb) {
    return pow(rgb, vec3(2.2));
}

vec3 linearToSrgb(vec3 rgb) {
    return pow(rgb, vec3(1.0 / 2.2));
}

uint encodeQuatOctXy88R8(vec4 q) {
    
    if (q.w < 0.0) {
        q = -q;
    }
    
    float theta = 2.0 * acos(q.w);
    float halfTheta = theta * 0.5;
    float s = sin(halfTheta);
    
    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, 0.0) : q.xyz / s;
    
    
    
    float sum = abs(axis.x) + abs(axis.y) + abs(axis.z);
    vec2 p = vec2(axis.x, axis.y) / sum;
    
    if (axis.z < 0.0) {
        float oldPx = p.x;
        p.x = (1.0 - abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);
        p.y = (1.0 - abs(oldPx)) * (p.y >= 0.0 ? 1.0 : -1.0);
    }
    
    float u_f = p.x * 0.5 + 0.5;
    float v_f = p.y * 0.5 + 0.5;
    
    uint quantU = uint(clamp(round(u_f * 255.0), 0.0, 255.0));
    uint quantV = uint(clamp(round(v_f * 255.0), 0.0, 255.0));
    
    
    
    uint angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, 255.0));
    
    
    return (angleInt << 16u) | (quantV << 8u) | quantU;
}

vec4 decodeQuatOctXy88R8(uint encoded) {
    
    uint quantU = encoded & uint(0xFFu);               
    uint quantV = (encoded >> 8u) & uint(0xFFu);         
    uint angleInt = encoded >> 16u;                      

    
    float u_f = float(quantU) / 255.0;
    float v_f = float(quantV) / 255.0;
    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - 1.0);

    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));
    float t = max(-axis.z, 0.0);
    axis.x += (axis.x >= 0.0) ? -t : t;
    axis.y += (axis.y >= 0.0) ? -t : t;
    axis = normalize(axis);
    
    
    float theta = (float(angleInt) / 255.0) * 3.14159265359;
    float halfTheta = theta * 0.5;
    float s = sin(halfTheta);
    float w = cos(halfTheta);
    
    return vec4(axis * s, w);
}

    

    

    

    

    

    

    

    

    

    

uvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, vec4 rgba) {
    uvec4 uRgba = uvec4(round(clamp(rgba * 255.0, 0.0, 255.0)));

    uint uQuat = encodeQuatOctXy88R8(quaternion);
    
    
    uvec3 uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & 0xffu);

    
    uvec3 uScales = uvec3(
        (scales.x == 0.0) ? 0u : uint(round(clamp((log(scales.x) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,
        (scales.y == 0.0) ? 0u : uint(round(clamp((log(scales.y) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,
        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u
    );

    
    uint word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);
    uint word1 = packHalf2x16(center.xy);
    uint word2 = packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);
    uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | (uQuat3.z << 24u);
    return uvec4(word0, word1, word2, word3);
}

void unpackSplat(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) {
    uint word0 = packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;

    uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & 0xffu, (word0 >> 24u) & 0xffu);
    rgba = vec4(uRgba) / 255.0;

    center = vec4(
        unpackHalf2x16(word1),
        unpackHalf2x16(word2 & 0xffffu)
    ).xyz;

    uvec3 uScales = uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);
    scales = vec3(
        (uScales.x == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.x - 1u) * LN_RESCALE),
        (uScales.y == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.y - 1u) * LN_RESCALE),
        (uScales.z == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.z - 1u) * LN_RESCALE)
    );

    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | ((word3 >> 8u) & 0xFF0000u);
    quaternion = decodeQuatOctXy88R8(uQuat);
    
    
}

vec3 quatVec(vec4 q, vec3 v) {
    
    vec3 t = 2.0 * cross(q.xyz, v);
    return v + q.w * t + cross(q.xyz, t);
}

vec4 quatQuat(vec4 q1, vec4 q2) {
    return vec4(
        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,
        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z
    );
}

mat3 scaleQuaternionToMatrix(vec3 s, vec4 q) {
    
    return mat3(
        s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),
        s.x * (2.0 * (q.x * q.y + q.w * q.z)),
        s.x * (2.0 * (q.x * q.z - q.w * q.y)),
        s.y * (2.0 * (q.x * q.y - q.w * q.z)),
        s.y * (1.0 - 2.0 * (q.x * q.x + q.z * q.z)),
        s.y * (2.0 * (q.y * q.z + q.w * q.x)),
        s.z * (2.0 * (q.x * q.z + q.w * q.y)),
        s.z * (2.0 * (q.y * q.z - q.w * q.x)),
        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))
    );
}

vec4 slerp(vec4 q1, vec4 q2, float t) {
    
    float cosHalfTheta = dot(q1, q2);

    
    if (abs(cosHalfTheta) >= 0.999) {
        return q1;
    }
    
    
    
    if (cosHalfTheta < 0.0) {
        q2 = -q2;
        cosHalfTheta = -cosHalfTheta;
    }

    
    float halfTheta = acos(cosHalfTheta);
    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);

    
    float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;
    float ratioB = sin(t * halfTheta) / sinHalfTheta;

    
    return q1 * ratioA + q2 * ratioB;
}

ivec3 splatTexCoord(int index) {
    uint x = uint(index) & SPLAT_TEX_WIDTH_MASK;
    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK;
    uint z = uint(index) >> SPLAT_TEX_LAYER_BITS;
    return ivec3(x, y, z);
}`, mo = `precision highp float;
precision highp int;

#include <splatDefines>

uniform float near;
uniform float far;
uniform bool encodeLinear;
uniform float maxStdDev;
uniform bool disableFalloff;
uniform float falloff;

uniform bool splatTexEnable;
uniform sampler3D splatTexture;
uniform mat2 splatTexMul;
uniform vec2 splatTexAdd;
uniform float splatTexNear;
uniform float splatTexFar;
uniform float splatTexMid;

out vec4 fragColor;

in vec4 vRgba;
in vec2 vSplatUv;
in vec3 vNdc;

void main() {
    vec4 rgba = vRgba;

    float z = dot(vSplatUv, vSplatUv);
    if (!splatTexEnable) {
        if (z > (maxStdDev * maxStdDev)) {
            discard;
        }
    } else {
        vec2 uv = splatTexMul * vSplatUv + splatTexAdd;
        float ndcZ = vNdc.z;
        float depth = (2.0 * near * far) / (far + near - ndcZ * (far - near));
        float clampedFar = max(splatTexFar, splatTexNear);
        float clampedDepth = clamp(depth, splatTexNear, clampedFar);
        float logDepth = log2(clampedDepth + 1.0);
        float logNear = log2(splatTexNear + 1.0);
        float logFar = log2(clampedFar + 1.0);

        float texZ;
        if (splatTexMid > 0.0) {
            float clampedMid = clamp(splatTexMid, splatTexNear, clampedFar);
            float logMid = log2(clampedMid + 1.0);
            texZ = (clampedDepth <= clampedMid) ?
                (0.5 * ((logDepth - logNear) / (logMid - logNear))) :
                (0.5 * ((logDepth - logMid) / (logFar - logMid)) + 0.5);
        } else {
            texZ = (logDepth - logNear) / (logFar - logNear);
        }

        vec4 modulate = texture(splatTexture, vec3(uv, 1.0 - texZ));
        rgba *= modulate;
    }

    rgba.a *= mix(1.0, exp(-0.5 * z), falloff);

    if (rgba.a < MIN_ALPHA) {
        discard;
    }
    if (encodeLinear) {
        rgba.rgb = srgbToLinear(rgba.rgb);
    }
    fragColor = rgba;
}`, So = `precision highp float;
precision highp int;
precision highp usampler2DArray;

#include <splatDefines>

attribute uint splatIndex;

out vec4 vRgba;
out vec2 vSplatUv;
out vec3 vNdc;

uniform vec2 renderSize;
uniform uint numSplats;
uniform vec4 renderToViewQuat;
uniform vec3 renderToViewPos;
uniform float maxStdDev;
uniform float time;
uniform float deltaTime;
uniform bool debugFlag;
uniform bool enable2DGS;
uniform float blurAmount;
uniform float preBlurAmount;
uniform float focalDistance;
uniform float apertureAngle;
uniform float clipXY;
uniform float focalAdjustment;

uniform usampler2DArray packedSplats;

void main() {
    
    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);

    if (uint(gl_InstanceID) >= numSplats) {
        return;
    }
    if (splatIndex == 0xffffffffu) {
        
        return;
    }

    ivec3 texCoord = ivec3(
        splatIndex & SPLAT_TEX_WIDTH_MASK,
        (splatIndex >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,
        splatIndex >> SPLAT_TEX_LAYER_BITS
    );
    uvec4 packed = texelFetch(packedSplats, texCoord, 0);

    vec3 center, scales;
    vec4 quaternion, rgba;
    unpackSplat(packed, center, scales, quaternion, rgba);

    if (rgba.a < MIN_ALPHA) {
        return;
    }
    bvec3 zeroScales = equal(scales, vec3(0.0));
    if (all(zeroScales)) {
        return;
    }

    
    vec3 viewCenter = quatVec(renderToViewQuat, center) + renderToViewPos;

    
    if (viewCenter.z >= 0.0) {
        return;
    }

    
    vec4 clipCenter = projectionMatrix * vec4(viewCenter, 1.0);

    
    if (abs(clipCenter.z) >= clipCenter.w) {
        return;
    }

    
    float clip = clipXY * clipCenter.w;
    if (abs(clipCenter.x) > clip || abs(clipCenter.y) > clip) {
        return;
    }

    
    vec4 viewQuaternion = quatQuat(renderToViewQuat, quaternion);

    if (enable2DGS && any(zeroScales)) {
        vRgba = rgba;
        vSplatUv = position.xy * maxStdDev;

        vec3 offset;
        if (zeroScales.z) {
            offset = vec3(vSplatUv.xy * scales.xy, 0.0);
        } else if (zeroScales.y) {
            offset = vec3(vSplatUv.x * scales.x, 0.0, vSplatUv.y * scales.z);
        } else {
            offset = vec3(0.0, vSplatUv.xy * scales.yz);
        }

        vec3 viewPos = viewCenter + quatVec(viewQuaternion, offset);
        gl_Position = projectionMatrix * vec4(viewPos, 1.0);
        vNdc = gl_Position.xyz / gl_Position.w;
        return;
    }

    
    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;

    
    mat3 RS = scaleQuaternionToMatrix(scales, viewQuaternion);
    mat3 cov3D = RS * transpose(RS);

    
    vec2 scaledRenderSize = renderSize * focalAdjustment;
    vec2 focal = 0.5 * scaledRenderSize * vec2(projectionMatrix[0][0], projectionMatrix[1][1]);
    float invZ = 1.0 / viewCenter.z;
    vec2 J1 = focal * invZ;
    vec2 J2 = -(J1 * viewCenter.xy) * invZ;
    mat3 J = mat3(
        J1.x, 0.0, J2.x,
        0.0, J1.y, J2.y,
        0.0, 0.0, 0.0
    );

    
    
    
    
    
    
    
    mat3 cov2D = transpose(J) * cov3D * J;
    float a = cov2D[0][0];
    float d = cov2D[1][1];
    float b = cov2D[0][1];

    
    a += preBlurAmount;
    d += preBlurAmount;

    float fullBlurAmount = blurAmount;
    if ((focalDistance > 0.0) && (apertureAngle > 0.0)) {
        float focusRadius = MAX_PIXEL_RADIUS;
        if (viewCenter.z < 0.0) {
            float focusBlur = abs((-viewCenter.z - focalDistance) / viewCenter.z);
            float apertureRadius = focal.x * tan(0.5 * apertureAngle);
            focusRadius = focusBlur * apertureRadius;
        }
        fullBlurAmount = clamp(sqr(focusRadius), blurAmount, sqr(MAX_PIXEL_RADIUS));
    }

    
    float detOrig = a * d - b * b;
    a += fullBlurAmount;
    d += fullBlurAmount;
    float det = a * d - b * b;

    
    float blurAdjust = sqrt(max(0.0, detOrig / det));
    rgba.a *= blurAdjust;
    if (rgba.a < MIN_ALPHA) {
        return;
    }

    
    float eigenAvg = 0.5 * (a + d);
    float eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));
    float eigen1 = eigenAvg + eigenDelta;
    float eigen2 = eigenAvg - eigenDelta;

    vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));
    vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);

    float scale1 = position.x * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen1));
    float scale2 = position.y * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen2));

    
    vec2 pixelOffset = eigenVec1 * scale1 + eigenVec2 * scale2;
    vec2 ndcOffset = (2.0 / scaledRenderSize) * pixelOffset;
    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, ndcCenter.z);

    vRgba = rgba;
    vSplatUv = position.xy * maxStdDev;
    vNdc = ndc;
    gl_Position = vec4(ndc.xy * clipCenter.w, clipCenter.zw);
}`;
let xe = null;
function Fo() {
  return xe || (a.ShaderChunk.splatDefines = Mo, xe = {
    splatVertex: So,
    splatFragment: mo
  }), xe;
}
const rg = 5;
let qe = !1, ze = !1, qB;
function Go(t) {
  let A = !1;
  return t instanceof WA ? !0 : (t.traverse((e) => {
    A = A || e instanceof WA;
  }), A);
}
const zB = a.Scene.prototype.add;
a.Scene.prototype.add = function(t) {
  return qe = qe || Go(t), ze = ze || t instanceof re, zB.call(this, t), this;
};
const xo = a.Scene.prototype.onBeforeRender;
a.Scene.prototype.onBeforeRender = function(t) {
  if (qe) {
    if (!ze) {
      const A = qB || new re({ renderer: t });
      this.add(A);
    }
    a.Scene.prototype.onBeforeRender = xo, a.Scene.prototype.add = zB;
  }
};
const BA = class BA extends a.Mesh {
  constructor(A) {
    const e = BA.makeUniforms(), g = Fo(), I = new a.ShaderMaterial({
      glslVersion: a.GLSL3,
      vertexShader: g.splatVertex,
      fragmentShader: g.splatFragment,
      uniforms: e,
      transparent: !0,
      blending: a.NormalBlending,
      depthTest: !0,
      depthWrite: !1,
      side: a.DoubleSide
    });
    super(cg, I), this.splatTexture = null, this.autoViewpoints = [], this.rotateToAccumulator = new Wt({ value: new a.Quaternion() }), this.translateToAccumulator = new Ft({ value: new a.Vector3() }), this.lastFrame = -1, this.lastUpdateTime = null, this.defaultCameras = [], this.pendingUpdate = null, this.envViewpoint = null, this.frustumCulled = !1, this.renderer = A.renderer, this.material = I, this.uniforms = e;
    const s = SA(
      { gsplat: P },
      { gsplat: P },
      ({ gsplat: Q }) => {
        if (!Q)
          throw new Error("gsplat not defined");
        return Q = Xe(Q, {
          rotate: this.rotateToAccumulator,
          translate: this.translateToAccumulator
        }), { gsplat: Q };
      }
    );
    this.modifier = new Io(s), this.autoUpdate = A.autoUpdate ?? !0, this.preUpdate = A.preUpdate ?? !1, this.originDistance = A.originDistance ?? 1, this.maxStdDev = A.maxStdDev ?? Math.sqrt(8), this.enable2DGS = A.enable2DGS ?? !1, this.preBlurAmount = A.preBlurAmount ?? 0, this.blurAmount = A.blurAmount ?? 0.3, this.focalDistance = A.focalDistance ?? 0, this.apertureAngle = A.apertureAngle ?? 0, this.falloff = A.falloff ?? 1, this.clipXY = A.clipXY ?? 1.4, this.focalAdjustment = A.focalAdjustment ?? 1, this.active = new Ge(), this.accumulatorCount = 1, this.freeAccumulators = [];
    for (let Q = 0; Q < 1; ++Q)
      this.freeAccumulators.push(new Ge()), this.accumulatorCount += 1;
    this.defaultView = new oe({
      ...A.view,
      autoUpdate: !0,
      spark: this
    }), this.viewpoint = this.defaultView, this.prepareViewpoint(this.viewpoint), this.clock = A.clock ? UI(A.clock) : new a.Clock(), qB = this;
  }
  static makeUniforms() {
    return {
      // Size of render viewport in pixels
      renderSize: { value: new a.Vector2() },
      // Near and far plane distances
      near: { value: 0.1 },
      far: { value: 1e3 },
      // Total number of Gsplats in packedSplats to render
      numSplats: { value: 0 },
      // SplatAccumulator to view transformation quaternion
      renderToViewQuat: { value: new a.Quaternion() },
      // SplatAccumulator to view transformation translation
      renderToViewPos: { value: new a.Vector3() },
      // Maximum distance (in stddevs) from Gsplat center to render
      maxStdDev: { value: 1 },
      // Enable interpreting 0-thickness Gsplats as 2DGS
      enable2DGS: { value: !1 },
      // Add to projected 2D splat covariance diagonal (thickens and brightens)
      preBlurAmount: { value: 0 },
      // Add to 2D splat covariance diagonal and adjust opacity (anti-aliasing)
      blurAmount: { value: 0.3 },
      // Depth-of-field distance to focal plane
      focalDistance: { value: 0 },
      // Full-width angle of aperture opening (in radians)
      apertureAngle: { value: 0 },
      // Modulate Gaussian kernal falloff. 0 means "no falloff, flat shading",
      // 1 is normal e^-x^2 falloff.
      falloff: { value: 1 },
      // Clip Gsplats that are clipXY times beyond the +-1 frustum bounds
      clipXY: { value: 1.4 },
      // Debug renderSize scale factor
      focalAdjustment: { value: 1 },
      // Enable splat texture rendering
      splatTexEnable: { value: !1 },
      // Splat texture to render
      splatTexture: { type: "t", value: BA.EMPTY_SPLAT_TEXTURE },
      // Splat texture UV transform (multiply)
      splatTexMul: { value: new a.Matrix2() },
      // Splat texture UV transform (add)
      splatTexAdd: { value: new a.Vector2() },
      // Splat texture near plane distance
      splatTexNear: { value: 0.1 },
      // Splat texture far plane distance
      splatTexFar: { value: 1e3 },
      // Splat texture mid plane distance, or 0.0 to disable
      splatTexMid: { value: 0 },
      // Gsplat collection to render
      packedSplats: { type: "t", value: qA.getEmpty() },
      // Time in seconds for time-based effects
      time: { value: 0 },
      // Delta time in seconds since last frame
      deltaTime: { value: 0 },
      // Whether to encode Gsplat with linear RGB (for environment mapping)
      encodeLinear: { value: !1 },
      // Debug flag that alternates each frame
      debugFlag: { value: !1 }
    };
  }
  canAllocAccumulator() {
    return this.freeAccumulators.length > 0 || this.accumulatorCount < rg;
  }
  maybeAllocAccumulator() {
    let A = this.freeAccumulators.pop();
    if (A === void 0) {
      if (this.accumulatorCount >= rg)
        return null;
      A = new Ge(), this.accumulatorCount += 1;
    }
    return A.refCount = 1, A;
  }
  releaseAccumulator(A) {
    A.refCount -= 1, A.refCount === 0 && this.freeAccumulators.push(A);
  }
  newViewpoint(A) {
    return new oe({ ...A, spark: this });
  }
  onBeforeRender(A, e, g) {
    var r, l;
    const I = this.time ?? this.clock.getElapsedTime(), s = I - (this.viewpoint.lastTime ?? I);
    this.viewpoint.lastTime = I;
    const Q = A.info.render.frame, B = Q !== this.lastFrame;
    this.lastFrame = Q;
    const i = this.viewpoint;
    if (i === this.defaultView) {
      if (B)
        if (!A.xr.isPresenting)
          this.defaultView.viewToWorld = g.matrixWorld.clone(), this.defaultCameras = [this.defaultView.viewToWorld];
        else {
          const c = A.xr.getCamera().cameras;
          this.defaultCameras = c.map((h) => h.matrixWorld), this.defaultView.viewToWorld = ko(this.defaultCameras) ?? new a.Matrix4();
        }
      this.autoUpdate && this.update({ scene: e, viewToWorld: this.defaultView.viewToWorld });
    }
    if (B && (this.uniforms.time.value = I, this.uniforms.deltaTime.value = s, this.uniforms.debugFlag.value = performance.now() / 1e3 % 2 < 1), i.target)
      this.uniforms.renderSize.value.set(
        i.target.width,
        i.target.height
      );
    else {
      const c = A.getDrawingBufferSize(
        this.uniforms.renderSize.value
      );
      if (c.x === 1 && c.y === 1) {
        const h = (r = A.xr.getSession()) == null ? void 0 : r.renderState.baseLayer;
        h && (c.x = h.framebufferWidth, c.y = h.framebufferHeight);
      }
    }
    const C = g;
    if (this.uniforms.near.value = C.near, this.uniforms.far.value = C.far, this.uniforms.encodeLinear.value = i.encodeLinear, this.uniforms.maxStdDev.value = this.maxStdDev, this.uniforms.enable2DGS.value = this.enable2DGS, this.uniforms.preBlurAmount.value = this.preBlurAmount, this.uniforms.blurAmount.value = this.blurAmount, this.uniforms.focalDistance.value = this.focalDistance, this.uniforms.apertureAngle.value = this.apertureAngle, this.uniforms.falloff.value = this.falloff, this.uniforms.clipXY.value = this.clipXY, this.uniforms.focalAdjustment.value = this.focalAdjustment, this.splatTexture) {
      const { enable: c, texture: h, multiply: u, add: y, near: w, far: d, mid: p } = this.splatTexture;
      c && h ? (this.uniforms.splatTexEnable.value = !0, this.uniforms.splatTexture.value = h, u ? this.uniforms.splatTexMul.value.fromArray(u.elements) : this.uniforms.splatTexMul.value.set(
        0.5 / this.maxStdDev,
        0,
        0,
        0.5 / this.maxStdDev
      ), this.uniforms.splatTexAdd.value.set((y == null ? void 0 : y.x) ?? 0.5, (y == null ? void 0 : y.y) ?? 0.5), this.uniforms.splatTexNear.value = w ?? this.uniforms.near.value, this.uniforms.splatTexFar.value = d ?? this.uniforms.far.value, this.uniforms.splatTexMid.value = p ?? 0) : (this.uniforms.splatTexEnable.value = !1, this.uniforms.splatTexture.value = BA.EMPTY_SPLAT_TEXTURE);
    } else
      this.uniforms.splatTexEnable.value = !1, this.uniforms.splatTexture.value = BA.EMPTY_SPLAT_TEXTURE;
    const E = ((l = i.display) == null ? void 0 : l.accumulator.toWorld) ?? new a.Matrix4(), n = g.matrixWorld.clone().invert();
    E.clone().premultiply(n).decompose(
      this.uniforms.renderToViewPos.value,
      this.uniforms.renderToViewQuat.value,
      new a.Vector3()
    );
  }
  // Update the uniforms for the given viewpoint.
  // Note that the client expects to be able to call render() at any point
  // to update the canvas, so we must switch the viewpoint back to
  // defaultView when we're finished.
  prepareViewpoint(A) {
    if (this.viewpoint = A ?? this.viewpoint, this.viewpoint.display) {
      const { accumulator: e, geometry: g } = this.viewpoint.display;
      this.uniforms.numSplats.value = e.splats.numSplats, this.uniforms.packedSplats.value = e.splats.getTexture(), this.geometry = g;
    } else
      this.uniforms.numSplats.value = 0, this.uniforms.packedSplats.value = qA.getEmpty(), this.geometry = cg;
  }
  // If spark.autoUpdate is false then you must manually call
  // spark.update({ scene }) to have the scene Gsplats be re-generated.
  update({
    scene: A,
    viewToWorld: e
  }) {
    const g = this.matrixWorld.clone();
    this.preUpdate ? this.updateInternal({ scene: A, originToWorld: g, viewToWorld: e }) : (this.pendingUpdate = {
      scene: A,
      originToWorld: g
    }, setTimeout(() => {
      if (this.pendingUpdate) {
        const { scene: I, originToWorld: s } = this.pendingUpdate;
        this.pendingUpdate = null, this.updateInternal({ scene: I, originToWorld: s, viewToWorld: e });
      }
    }, 1));
  }
  updateInternal({
    scene: A,
    originToWorld: e,
    viewToWorld: g
  }) {
    var l;
    if (!this.canAllocAccumulator())
      return !1;
    e || (e = this.active.toWorld), g = g ?? e.clone();
    const I = this.time ?? this.clock.getElapsedTime(), s = I - (this.lastUpdateTime ?? I);
    this.lastUpdateTime = I;
    const Q = this.active.mapping.reduce((c, h) => (c.set(h.node, h), c), /* @__PURE__ */ new Map()), { generators: B, visibleGenerators: i, globalEdits: C } = this.compileScene(A);
    for (const c of B)
      (l = c.frameUpdate) == null || l.call(c, {
        object: c,
        time: I,
        deltaTime: s,
        viewToWorld: g,
        globalEdits: C
      });
    const E = new Set(i.map((c) => c.uuid));
    for (const c of B) {
      const h = Q.get(c), y = c.generator && E.has(c.uuid) ? c.numSplats : 0;
      (c.generator !== (h == null ? void 0 : h.generator) || y !== (h == null ? void 0 : h.count)) && c.updateVersion();
    }
    const o = !ie({
      matrix1: e,
      matrix2: this.active.toWorld,
      maxDistance: this.originDistance
    }) || B.length !== Q.size || B.some((c) => {
      var h;
      return c.version !== ((h = Q.get(c)) == null ? void 0 : h.version);
    });
    let r = null;
    if (o) {
      if (r = this.maybeAllocAccumulator(), !r)
        throw new Error("Unreachable");
      const c = !ie({
        matrix1: e,
        matrix2: this.active.toWorld,
        maxDistance: 1e-5,
        minCoorient: 0.99999
      }), u = i.map((N, f) => {
        const D = Q.get(N);
        return D ? (
          // Sort by version deltas then by previous ordering in the mapping,
          // attempting to keep unchanging generators near the front
          // to improve our chances of avoiding a re-generation.
          [N.version - D.version, D.base, N]
        ) : [Number.POSITIVE_INFINITY, N.version, N];
      }).sort((N, f) => N[0] !== f[0] ? N[0] - f[0] : N[1] - f[1]).map(([N, f, D]) => D), y = u.map((N) => N.numSplats), { maxSplats: w, mapping: d } = r.splats.generateMapping(y), p = u.map((N, f) => {
        const { base: D, count: R } = d[f];
        return {
          node: N,
          generator: N.generator,
          version: N.version,
          base: D,
          count: R
        };
      });
      e.clone().invert().decompose(
        this.translateToAccumulator.value,
        this.rotateToAccumulator.value,
        new a.Vector3()
      ), r.ensureGenerate(w), r.generateSplats({
        renderer: this.renderer,
        modifier: this.modifier,
        generators: p,
        forceUpdate: c,
        originToWorld: e
      }), r.splatsVersion = this.active.splatsVersion + 1;
      const m = r.hasCorrespondence(this.active);
      r.mappingVersion = this.active.mappingVersion + (m ? 0 : 1), this.releaseAccumulator(this.active), this.active = r, this.prepareViewpoint();
    }
    return setTimeout(() => {
      for (const c of this.autoViewpoints)
        c.autoPoll({ accumulator: r ?? void 0 });
    }, 1), !0;
  }
  compileScene(A) {
    const e = [];
    A.traverse((s) => {
      s instanceof qt && e.push(s);
    });
    const g = [];
    A.traverseVisible((s) => {
      s instanceof qt && g.push(s);
    });
    const I = /* @__PURE__ */ new Set();
    return A.traverseVisible((s) => {
      if (s instanceof Ce) {
        let Q = s.parent;
        for (; Q != null && !(Q instanceof WA); )
          Q = Q.parent;
        Q == null && I.add(s);
      }
    }), {
      generators: e,
      visibleGenerators: g,
      globalEdits: Array.from(I)
    };
  }
  // Renders out the scene to an environment map that can be used for
  // Image-based lighting or similar applications. First optionally updates Gsplats,
  // sorts them with respect to the provided worldCenter, renders 6 cube faces,
  // then pre-filters them using THREE.PMREMGenerator and returns a THREE.Texture
  // that can assigned directly to a THREE.MeshStandardMaterial.envMap property.
  async renderEnvMap({
    renderer: A,
    scene: e,
    worldCenter: g,
    size: I = 256,
    near: s = 0.1,
    far: Q = 1e3,
    hideObjects: B = [],
    update: i = !1
  }) {
    var r, l;
    if (this.envViewpoint || (this.envViewpoint = this.newViewpoint({ sort360: !0 })), !BA.cubeRender || BA.cubeRender.target.width !== I || BA.cubeRender.near !== s || BA.cubeRender.far !== Q) {
      BA.cubeRender && BA.cubeRender.target.dispose();
      const c = new a.WebGLCubeRenderTarget(I, {
        format: a.RGBAFormat,
        generateMipmaps: !0,
        minFilter: a.LinearMipMapLinearFilter
      }), h = new a.CubeCamera(s, Q, c);
      BA.cubeRender = { target: c, camera: h, near: s, far: Q };
    }
    BA.pmrem || (BA.pmrem = new a.PMREMGenerator(A ?? this.renderer));
    const C = new a.Matrix4().setPosition(g);
    await ((r = this.envViewpoint) == null ? void 0 : r.prepare({ scene: e, viewToWorld: C, update: i }));
    const { target: E, camera: n } = BA.cubeRender;
    n.position.copy(g);
    const o = /* @__PURE__ */ new Map();
    for (const c of B)
      o.set(c, c.visible), c.visible = !1;
    this.prepareViewpoint(this.envViewpoint), n.update(A ?? this.renderer, e), this.prepareViewpoint(this.defaultView);
    for (const [c, h] of o.entries())
      c.visible = h;
    return (l = BA.pmrem) == null ? void 0 : l.fromCubemap(E.texture).texture;
  }
  // Utility function to recursively set the envMap property for any
  // THREE.MeshStandardMaterial within the subtree of root.
  recurseSetEnvMap(A, e) {
    A.traverse((g) => {
      if (g instanceof a.Mesh)
        if (Array.isArray(g.material))
          for (const I of g.material)
            I instanceof a.MeshStandardMaterial && (I.envMap = e);
        else
          g.material instanceof a.MeshStandardMaterial && (g.material.envMap = e);
    });
  }
  // Utility function that helps extract the Gsplat RGBA values from a
  // SplatGenerator, including the result of any real-time RGBA SDF edits applied
  // to a SplatMesh. This effectively "bakes" any computed RGBA values, which can
  // now be used as a pipeline input via SplatMesh.splatRgba to inject these
  // baked values into the Gsplat data.
  getRgba({
    generator: A,
    rgba: e
  }) {
    const g = this.active.mapping.find(({ node: I }) => I === A);
    if (!g)
      throw new Error("Generator not found");
    return e = e ?? new Te(), e.fromPackedSplats({
      packedSplats: this.active.splats,
      base: g.base,
      count: g.count,
      renderer: this.renderer
    }), e;
  }
  // Utility function that builds on getRgba({ generator }) and additionally
  // reads back the RGBA values to the CPU in a Uint8Array with packed RGBA
  // in that byte order.
  async readRgba({
    generator: A,
    rgba: e
  }) {
    return e = this.getRgba({ generator: A, rgba: e }), e.read();
  }
};
BA.cubeRender = null, BA.pmrem = null, BA.EMPTY_SPLAT_TEXTURE = new a.Data3DTexture();
let re = BA;
const cg = new Ke(new Uint32Array(1), 0);
SA(
  { packedSplats: Xt, index: "int" },
  { gsplat: P },
  ({ packedSplats: t, index: A }) => {
    if (!t || !A)
      throw new Error("Invalid input");
    return { gsplat: mt(t, A) };
  }
);
function ko(t) {
  if (t.length === 0)
    return null;
  const A = new a.Vector3(), e = new a.Quaternion(), g = new a.Vector3(), I = [], s = [];
  for (const Q of t)
    Q.decompose(A, e, g), I.push(A), s.push(e);
  return new a.Matrix4().compose(
    YI(I),
    JI(s),
    new a.Vector3(1, 1, 1)
  );
}
function Ro(t, A, e) {
  const g = Math.floor(t.length / 32);
  if (g * 32 !== t.length)
    throw new Error("Invalid .splat file size");
  const I = new Float32Array(t.buffer);
  for (let s = 0; s < g; ++s) {
    const Q = s * 32, B = s * 8, i = I[B + 0], C = I[B + 1], E = I[B + 2], n = I[B + 3], o = I[B + 4], r = I[B + 5], l = t[Q + 24] / 255, c = t[Q + 25] / 255, h = t[Q + 26] / 255, u = t[Q + 27] / 255, y = (t[Q + 28] - 128) / 128, w = (t[Q + 29] - 128) / 128, d = (t[Q + 30] - 128) / 128, p = (t[Q + 31] - 128) / 128;
    e(
      s,
      i,
      C,
      E,
      n,
      o,
      r,
      w,
      d,
      p,
      y,
      u,
      l,
      c,
      h
    );
  }
}
const hg = {
  0: {
    bytesPerCenter: 12,
    bytesPerScale: 12,
    bytesPerRotation: 16,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 4,
    scaleOffsetBytes: 12,
    rotationOffsetBytes: 24,
    colorOffsetBytes: 40,
    sphericalHarmonicsOffsetBytes: 44,
    scaleRange: 1
  },
  1: {
    bytesPerCenter: 6,
    bytesPerScale: 6,
    bytesPerRotation: 8,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 2,
    scaleOffsetBytes: 6,
    rotationOffsetBytes: 12,
    colorOffsetBytes: 20,
    sphericalHarmonicsOffsetBytes: 24,
    scaleRange: 32767
  },
  2: {
    bytesPerCenter: 6,
    bytesPerScale: 6,
    bytesPerRotation: 8,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 1,
    scaleOffsetBytes: 6,
    rotationOffsetBytes: 12,
    colorOffsetBytes: 20,
    sphericalHarmonicsOffsetBytes: 24,
    scaleRange: 32767
  }
}, Uo = {
  0: 0,
  1: 9,
  2: 24,
  3: 45
};
function Lo(t, A, e, g) {
  var c;
  let Q = 0;
  const B = new DataView(t.buffer, Q, 4096);
  Q += 4096;
  const i = B.getUint8(0), C = B.getUint8(1);
  if (i !== 0 || C < 1)
    throw new Error(
      `Unsupported .ksplat version: ${i}.${C}`
    );
  const E = B.getUint32(4, !0);
  B.getUint32(16, !0);
  const n = B.getUint16(20, !0);
  if (n < 0 || n > 2)
    throw new Error(`Invalid .ksplat compression level: ${n}`);
  const o = B.getFloat32(36, !0) || -1.5, r = B.getFloat32(40, !0) || 1.5;
  let l = 4096 + E * 1024;
  for (let h = 0; h < E; ++h) {
    let u = function(mA, H) {
      if (n === 0)
        return v.getFloat32(
          mA + j + H * 4,
          !0
        );
      if (n === 1)
        return dA(
          v.getUint16(
            mA + j + H * 2,
            !0
          )
        );
      const ZA = v.getUint8(mA + j + H) / 255;
      return o + ZA * (r - o);
    };
    const y = new DataView(t.buffer, Q, 1024);
    Q += 1024;
    const w = y.getUint32(0, !0), d = y.getUint32(4, !0), p = y.getUint32(8, !0), m = y.getUint32(12, !0), N = y.getFloat32(16, !0), f = y.getUint16(20, !0), D = (y.getUint32(24, !0) || ((c = hg[n]) == null ? void 0 : c.scaleRange)) ?? 1, R = y.getUint32(32, !0), S = R * p, M = y.getUint32(36, !0), L = M * 4, G = f * m + L, x = y.getUint16(40, !0), U = Uo[x], {
      bytesPerCenter: J,
      bytesPerScale: AA,
      bytesPerRotation: z,
      bytesPerColor: eA,
      bytesPerSphericalHarmonicsComponent: tA,
      scaleOffsetBytes: X,
      rotationOffsetBytes: b,
      colorOffsetBytes: W,
      sphericalHarmonicsOffsetBytes: j
    } = hg[n], _ = J + AA + z + eA + U * tA, Y = _ * d, uA = Y + G, nA = [0, 3, 6, 1, 4, 7, 2, 5, 8], wA = [
      9,
      14,
      19,
      10,
      15,
      20,
      11,
      16,
      21,
      12,
      17,
      22,
      13,
      18,
      23
    ], yA = [
      24,
      31,
      38,
      25,
      32,
      39,
      26,
      33,
      40,
      27,
      34,
      41,
      28,
      35,
      42,
      29,
      36,
      43,
      30,
      37,
      44
    ], NA = x >= 1 ? new Float32Array(3 * 3) : void 0, rA = x >= 2 ? new Float32Array(5 * 3) : void 0, LA = x >= 3 ? new Float32Array(7 * 3) : void 0, MA = N / 2 / D, _A = l + L, OA = l + G, v = new DataView(
      t.buffer,
      OA,
      Y
    ), lA = new Float32Array(
      t.buffer,
      _A,
      m * 3
    ), VA = new Uint32Array(
      t.buffer,
      l,
      M
    );
    let Ut = R, Ot = S;
    for (let mA = 0; mA < w; ++mA) {
      const H = mA * _;
      let ZA;
      if (mA < S)
        ZA = Math.floor(mA / p);
      else {
        const PA = VA[Ut - R];
        mA >= Ot + PA && (Ut += 1, Ot += PA), ZA = Ut;
      }
      const we = n === 0 ? v.getFloat32(H + 0, !0) : (v.getUint16(H + 0, !0) - D) * MA + lA[3 * ZA + 0], ye = n === 0 ? v.getFloat32(H + 4, !0) : (v.getUint16(H + 2, !0) - D) * MA + lA[3 * ZA + 1], De = n === 0 ? v.getFloat32(H + 8, !0) : (v.getUint16(H + 4, !0) - D) * MA + lA[3 * ZA + 2], de = n === 0 ? v.getFloat32(H + X + 0, !0) : dA(v.getUint16(H + X + 0, !0)), pe = n === 0 ? v.getFloat32(H + X + 4, !0) : dA(v.getUint16(H + X + 2, !0)), $B = n === 0 ? v.getFloat32(H + X + 8, !0) : dA(v.getUint16(H + X + 4, !0)), Ai = n === 0 ? v.getFloat32(H + b + 0, !0) : dA(
        v.getUint16(H + b + 0, !0)
      ), ti = n === 0 ? v.getFloat32(H + b + 4, !0) : dA(
        v.getUint16(H + b + 2, !0)
      ), ei = n === 0 ? v.getFloat32(H + b + 8, !0) : dA(
        v.getUint16(H + b + 4, !0)
      ), gi = n === 0 ? v.getFloat32(H + b + 12, !0) : dA(
        v.getUint16(H + b + 6, !0)
      ), Ii = v.getUint8(H + W + 0) / 255, si = v.getUint8(H + W + 1) / 255, Qi = v.getUint8(H + W + 2) / 255, Bi = v.getUint8(H + W + 3) / 255;
      if (e(
        mA,
        we,
        ye,
        De,
        de,
        pe,
        $B,
        ti,
        ei,
        gi,
        Ai,
        Bi,
        Ii,
        si,
        Qi
      ), x >= 1 && NA) {
        for (const [PA, Lt] of nA.entries())
          NA[PA] = u(H, Lt);
        if (rA)
          for (const [PA, Lt] of wA.entries())
            rA[PA] = u(H, Lt);
        if (LA)
          for (const [PA, Lt] of yA.entries())
            LA[PA] = u(H, Lt);
        g == null || g(mA, NA, rA, LA);
      }
    }
    l += uA;
  }
}
class Yo {
  constructor({ fileBytes: A }) {
    this.fileBytes = A instanceof ArrayBuffer ? new Uint8Array(A) : A, this.reader = new KI({ fileBytes: this.fileBytes });
    const e = new DataView(this.reader.read(16).buffer);
    if (e.getUint32(0, !0) !== 1347635022)
      throw new Error("Invalid SPZ file");
    if (this.version = e.getUint32(4, !0), this.version < 1 || this.version > 2)
      throw new Error(`Unsupported SPZ version: ${this.version}`);
    this.numSplats = e.getUint32(8, !0), this.shDegree = e.getUint8(12), this.fractionalBits = e.getUint8(13), this.flags = e.getUint8(14), this.flagAntiAlias = (this.flags & 1) !== 0, this.reserved = e.getUint8(15), this.parsed = !1;
  }
  parseSplats(A, e, g, I, s, Q) {
    if (this.parsed)
      throw new Error("SPZ file already parsed");
    if (this.parsed = !0, this.version === 1) {
      const B = this.reader.read(this.numSplats * 3 * 2), i = new Uint16Array(B.buffer);
      for (let C = 0; C < this.numSplats; C++) {
        const E = C * 3, n = dA(i[E]), o = dA(i[E + 1]), r = dA(i[E + 2]);
        A == null || A(C, n, o, r);
      }
    } else if (this.version === 2) {
      const B = 1 << this.fractionalBits, i = this.reader.read(this.numSplats * 3 * 3);
      for (let C = 0; C < this.numSplats; C++) {
        const E = C * 9, n = ((i[E + 2] << 24 | i[E + 1] << 16 | i[E] << 8) >> 8) / B, o = ((i[E + 5] << 24 | i[E + 4] << 16 | i[E + 3] << 8) >> 8) / B, r = ((i[E + 8] << 24 | i[E + 7] << 16 | i[E + 6] << 8) >> 8) / B;
        A == null || A(C, n, o, r);
      }
    } else
      throw new Error("Unreachable");
    {
      const B = this.reader.read(this.numSplats);
      for (let i = 0; i < this.numSplats; i++)
        e == null || e(i, B[i] / 255);
    }
    {
      const B = this.reader.read(this.numSplats * 3), i = ZB / 0.15;
      for (let C = 0; C < this.numSplats; C++) {
        const E = C * 3, n = (B[E] / 255 - 0.5) * i + 0.5, o = (B[E + 1] / 255 - 0.5) * i + 0.5, r = (B[E + 2] / 255 - 0.5) * i + 0.5;
        g == null || g(C, n, o, r);
      }
    }
    {
      const B = this.reader.read(this.numSplats * 3);
      for (let i = 0; i < this.numSplats; i++) {
        const C = i * 3, E = Math.exp(B[C] / 16 - 10), n = Math.exp(B[C + 1] / 16 - 10), o = Math.exp(B[C + 2] / 16 - 10);
        I == null || I(i, E, n, o);
      }
    }
    {
      const B = this.reader.read(this.numSplats * 3);
      for (let i = 0; i < this.numSplats; i++) {
        const C = i * 3, E = B[C] / 127.5 - 1, n = B[C + 1] / 127.5 - 1, o = B[C + 2] / 127.5 - 1, r = Math.sqrt(
          Math.max(0, 1 - E * E - n * n - o * o)
        );
        s == null || s(i, E, n, o, r);
      }
    }
    if (Q && this.shDegree >= 1) {
      const B = new Float32Array(9), i = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0, C = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0, E = this.reader.read(
        this.numSplats * VB[this.shDegree] * 3
      );
      let n = 0;
      for (let o = 0; o < this.numSplats; o++) {
        for (let r = 0; r < 9; ++r)
          B[r] = (E[n + r] - 128) / 128;
        if (n += 9, i) {
          for (let r = 0; r < 15; ++r)
            i[r] = (E[n + r] - 128) / 128;
          n += 15;
        }
        if (C) {
          for (let r = 0; r < 21; ++r)
            C[r] = (E[n + r] - 128) / 128;
          n += 21;
        }
        Q == null || Q(o, B, i, C);
      }
    }
  }
}
const VB = { 1: 3, 2: 8, 3: 15 }, ZB = 0.28209479177387814, Jo = 1347635022, vo = 2, bo = 1;
class tt {
  constructor({
    numSplats: A,
    shDegree: e,
    fractionalBits: g = 12,
    flagAntiAlias: I = !0
  }) {
    this.clippedCount = 0;
    const s = 19 + (e >= 1 ? 9 : 0) + (e >= 2 ? 15 : 0) + (e >= 3 ? 21 : 0), Q = 16 + A * s;
    this.buffer = new ArrayBuffer(Q), this.view = new DataView(this.buffer), this.view.setUint32(0, Jo, !0), this.view.setUint32(4, vo, !0), this.view.setUint32(8, A, !0), this.view.setUint8(12, e), this.view.setUint8(13, g), this.view.setUint8(14, I ? bo : 0), this.view.setUint8(15, 0), this.numSplats = A, this.shDegree = e, this.fractionalBits = g, this.fraction = 1 << g, this.flagAntiAlias = I;
  }
  setCenter(A, e, g, I) {
    const s = Math.round(e * this.fraction), Q = Math.max(-8388607, Math.min(8388607, s)), B = Math.round(g * this.fraction), i = Math.max(-8388607, Math.min(8388607, B)), C = Math.round(I * this.fraction), E = Math.max(-8388607, Math.min(8388607, C));
    (s !== Q || B !== i || C !== E) && (this.clippedCount += 1);
    const r = 16 + A * 9;
    this.view.setUint8(r, Q & 255), this.view.setUint8(r + 1, Q >> 8 & 255), this.view.setUint8(r + 2, Q >> 16 & 255), this.view.setUint8(r + 3, i & 255), this.view.setUint8(r + 4, i >> 8 & 255), this.view.setUint8(r + 5, i >> 16 & 255), this.view.setUint8(r + 6, E & 255), this.view.setUint8(r + 7, E >> 8 & 255), this.view.setUint8(r + 8, E >> 16 & 255);
  }
  setAlpha(A, e) {
    const g = 16 + this.numSplats * 9 + A;
    this.view.setUint8(
      g,
      Math.max(0, Math.min(255, Math.round(e * 255)))
    );
  }
  static scaleRgb(A) {
    const e = ((A - 0.5) / (ZB / 0.15) + 0.5) * 255;
    return Math.max(0, Math.min(255, Math.round(e)));
  }
  setRgb(A, e, g, I) {
    const s = 16 + this.numSplats * 10 + A * 3;
    this.view.setUint8(s, tt.scaleRgb(e)), this.view.setUint8(s + 1, tt.scaleRgb(g)), this.view.setUint8(s + 2, tt.scaleRgb(I));
  }
  setScale(A, e, g, I) {
    const s = 16 + this.numSplats * 13 + A * 3;
    this.view.setUint8(
      s,
      Math.max(0, Math.min(255, Math.round((Math.log(e) + 10) * 16)))
    ), this.view.setUint8(
      s + 1,
      Math.max(0, Math.min(255, Math.round((Math.log(g) + 10) * 16)))
    ), this.view.setUint8(
      s + 2,
      Math.max(0, Math.min(255, Math.round((Math.log(I) + 10) * 16)))
    );
  }
  setQuat(A, e, g, I, s) {
    const Q = 16 + this.numSplats * 16 + A * 3, B = s < 0;
    this.view.setUint8(
      Q,
      Math.max(
        0,
        Math.min(255, Math.round(((B ? -e : e) + 1) * 127.5))
      )
    ), this.view.setUint8(
      Q + 1,
      Math.max(
        0,
        Math.min(255, Math.round(((B ? -g : g) + 1) * 127.5))
      )
    ), this.view.setUint8(
      Q + 2,
      Math.max(
        0,
        Math.min(255, Math.round(((B ? -I : I) + 1) * 127.5))
      )
    );
  }
  static quantizeSh(A, e) {
    const g = Math.round(A * 128) + 128, I = 1 << 8 - e, s = Math.floor((g + I / 2) / I) * I;
    return Math.max(0, Math.min(255, s));
  }
  setSh(A, e, g, I) {
    const s = VB[this.shDegree] || 0, Q = 16 + this.numSplats * 19 + A * s * 3;
    for (let B = 0; B < 9; ++B)
      this.view.setUint8(Q + B, tt.quantizeSh(e[B], 5));
    if (g) {
      const B = Q + 9;
      for (let i = 0; i < 15; ++i)
        this.view.setUint8(B + i, tt.quantizeSh(g[i], 4));
      if (I) {
        const i = B + 15;
        for (let C = 0; C < 21; ++C)
          this.view.setUint8(i + C, tt.quantizeSh(I[C], 4));
      }
    }
  }
  async finalize() {
    const A = new Uint8Array(this.buffer), g = new ReadableStream({
      async start(Q) {
        Q.enqueue(A), Q.close();
      }
    }).pipeThrough(new CompressionStream("gzip")), s = await new Response(g).arrayBuffer();
    return console.log(
      "Compressed",
      A.length,
      "bytes to",
      s.byteLength,
      "bytes"
    ), new Uint8Array(s);
  }
}
async function dr(t) {
  var E, n, o;
  const A = new yo(), {
    inputs: e,
    clipXyz: g,
    maxSh: I,
    fractionalBits: s = 12,
    opacityThreshold: Q
  } = t;
  for (const r of e) {
    let l = function(f) {
      return f.multiplyScalar(w), f.applyQuaternion(d), f.add(p), f;
    }, c = function(f) {
      return f.multiplyScalar(w), f;
    }, h = function(f) {
      return f.premultiply(d), f;
    }, u = function(f) {
      return !m || m.containsPoint(f);
    }, y = function(f) {
      return Q !== void 0 ? f >= Q : !0;
    };
    const w = ((E = r.transform) == null ? void 0 : E.scale) ?? 1, d = new a.Quaternion().fromArray(
      ((n = r.transform) == null ? void 0 : n.quaternion) ?? [0, 0, 0, 1]
    ), p = new a.Vector3().fromArray(
      ((o = r.transform) == null ? void 0 : o.translate) ?? [0, 0, 0]
    ), m = g ? new a.Box3(
      new a.Vector3().fromArray(g.min),
      new a.Vector3().fromArray(g.max)
    ) : void 0;
    let N = r.fileType;
    switch (N || (N = HB(r.fileBytes), !N && r.pathOrUrl && (N = TB(r.pathOrUrl))), N) {
      case vt.PLY: {
        const f = new Ee({ fileBytes: r.fileBytes });
        await f.parseHeader();
        let D = null;
        f.parseSplats(
          (R, S, M, L, G, x, U, J, AA, z, eA, tA, X, b, W) => {
            const j = l(new a.Vector3(S, M, L));
            if (u(j) && y(tA)) {
              D = A.pushSplat(), A.setCenter(D, j.x, j.y, j.z);
              const _ = c(
                new a.Vector3(G, x, U)
              );
              A.setScale(D, _.x, _.y, _.z);
              const Y = h(
                new a.Quaternion(J, AA, z, eA)
              );
              A.setQuaternion(
                D,
                Y.x,
                Y.y,
                Y.z,
                Y.w
              ), A.setOpacity(D, tA), A.setColor(D, X, b, W);
            } else
              D = null;
          },
          (R, S, M, L) => {
            S && D !== null && A.setSh1(D, S), M && D !== null && A.setSh2(D, M), L && D !== null && A.setSh3(D, L);
          }
        );
        break;
      }
      case vt.SPZ: {
        const f = new Yo({ fileBytes: r.fileBytes }), D = new Int32Array(f.numSplats);
        D.fill(-1);
        const R = new Float32Array(f.numSplats * 3), S = new a.Vector3();
        f.parseSplats(
          (M, L, G, x) => {
            const U = l(new a.Vector3(L, G, x));
            R[M * 3] = U.x, R[M * 3 + 1] = U.y, R[M * 3 + 2] = U.z;
          },
          (M, L) => {
            S.fromArray(R, M * 3), u(S) && y(L) && (D[M] = A.pushSplat(), A.setCenter(D[M], S.x, S.y, S.z), A.setOpacity(D[M], L));
          },
          (M, L, G, x) => {
            D[M] >= 0 && A.setColor(D[M], L, G, x);
          },
          (M, L, G, x) => {
            if (D[M] >= 0) {
              const U = c(
                new a.Vector3(L, G, x)
              );
              A.setScale(D[M], U.x, U.y, U.z);
            }
          },
          (M, L, G, x, U) => {
            if (D[M] >= 0) {
              const J = h(
                new a.Quaternion(L, G, x, U)
              );
              A.setQuaternion(
                D[M],
                J.x,
                J.y,
                J.z,
                J.w
              );
            }
          },
          (M, L, G, x) => {
            D[M] >= 0 && (A.setSh1(D[M], L), G && A.setSh2(D[M], G), x && A.setSh3(D[M], x));
          }
        );
        break;
      }
      case vt.SPLAT:
        Ro(
          r.fileBytes,
          (f) => {
          },
          (f, D, R, S, M, L, G, x, U, J, AA, z, eA, tA, X) => {
            const b = l(new a.Vector3(D, R, S));
            if (u(b) && y(z)) {
              const W = A.pushSplat();
              A.setCenter(W, b.x, b.y, b.z);
              const j = c(
                new a.Vector3(M, L, G)
              );
              A.setScale(W, j.x, j.y, j.z);
              const _ = h(
                new a.Quaternion(x, U, J, AA)
              );
              A.setQuaternion(
                W,
                _.x,
                _.y,
                _.z,
                _.w
              ), A.setOpacity(W, z), A.setColor(W, eA, tA, X);
            }
          }
        );
        break;
      case vt.KSPLAT: {
        let f = null;
        Lo(
          r.fileBytes,
          (D) => {
          },
          (D, R, S, M, L, G, x, U, J, AA, z, eA, tA, X, b) => {
            const W = l(new a.Vector3(R, S, M));
            if (u(W) && y(eA)) {
              f = A.pushSplat(), A.setCenter(f, W.x, W.y, W.z);
              const j = c(
                new a.Vector3(L, G, x)
              );
              A.setScale(f, j.x, j.y, j.z);
              const _ = h(
                new a.Quaternion(U, J, AA, z)
              );
              A.setQuaternion(
                f,
                _.x,
                _.y,
                _.z,
                _.w
              ), A.setOpacity(f, eA), A.setColor(f, tA, X, b);
            } else
              f = null;
          },
          (D, R, S, M) => {
            f !== null && (A.setSh1(f, R), S && A.setSh2(f, S), M && A.setSh3(f, M));
          }
        );
        break;
      }
      default:
        throw new Error(`transcodeSpz not implemented for ${N}`);
    }
  }
  const B = Math.min(
    I ?? 3,
    A.sh3 ? 3 : A.sh2 ? 2 : A.sh1 ? 1 : 0
  ), i = new tt({
    numSplats: A.numSplats,
    shDegree: B,
    fractionalBits: s,
    flagAntiAlias: !0
  });
  for (let r = 0; r < A.numSplats; ++r) {
    const l = r * 3, c = r * 4;
    i.setCenter(
      r,
      A.centers[l],
      A.centers[l + 1],
      A.centers[l + 2]
    ), i.setScale(
      r,
      A.scales[l],
      A.scales[l + 1],
      A.scales[l + 2]
    ), i.setQuat(
      r,
      A.quaternions[c],
      A.quaternions[c + 1],
      A.quaternions[c + 2],
      A.quaternions[c + 3]
    ), i.setAlpha(r, A.opacities[r]), i.setRgb(
      r,
      A.colors[l],
      A.colors[l + 1],
      A.colors[l + 2]
    ), A.sh1 && B >= 1 && i.setSh(
      r,
      A.sh1.slice(r * 9, (r + 1) * 9),
      B >= 2 && A.sh2 ? A.sh2.slice(r * 15, (r + 1) * 15) : void 0,
      B >= 3 && A.sh3 ? A.sh3.slice(r * 21, (r + 1) * 21) : void 0
    );
  }
  return { fileBytes: await i.finalize(), clippedCount: i.clippedCount };
}
class pr {
  constructor(A) {
    this.mesh = A.mesh, this.numSplats = A.numSplats ?? this.mesh.numSplats;
    const { width: e, height: g, depth: I, maxSplats: s } = fA(this.numSplats);
    this.skinData = new Uint16Array(s * 4), this.skinTexture = new a.DataArrayTexture(
      this.skinData,
      e,
      g,
      I
    ), this.skinTexture.format = a.RGBAIntegerFormat, this.skinTexture.type = a.UnsignedShortType, this.skinTexture.internalFormat = "RGBA16UI", this.skinTexture.needsUpdate = !0, this.numBones = A.numBones ?? 256, this.boneData = new Float32Array(this.numBones * 16), this.boneTexture = new a.DataTexture(
      this.boneData,
      4,
      this.numBones,
      a.RGBAFormat,
      a.FloatType
    ), this.boneTexture.internalFormat = "RGBA32F", this.boneTexture.needsUpdate = !0, this.uniform = new k({
      key: "skinning",
      type: jB,
      globals: () => [XB],
      value: {
        numSplats: this.numSplats,
        numBones: this.numBones,
        skinTexture: this.skinTexture,
        boneTexture: this.boneTexture
      }
    });
  }
  // Apply the skeletal animation to a Gsplat in a dyno program.
  modify(A) {
    return To(A, this.uniform);
  }
  // Set the "rest" pose for a bone with position and quaternion orientation.
  setRestQuatPos(A, e, g) {
    const I = A * 16;
    this.boneData[I + 0] = e.x, this.boneData[I + 1] = e.y, this.boneData[I + 2] = e.z, this.boneData[I + 3] = e.w, this.boneData[I + 4] = g.x, this.boneData[I + 5] = g.y, this.boneData[I + 6] = g.z, this.boneData[I + 7] = 0, this.boneData[I + 8] = 0, this.boneData[I + 9] = 0, this.boneData[I + 10] = 0, this.boneData[I + 11] = 1, this.boneData[I + 12] = 0, this.boneData[I + 13] = 0, this.boneData[I + 14] = 0, this.boneData[I + 15] = 0;
  }
  // Set the "current" position and orientation of a bone.
  setBoneQuatPos(A, e, g) {
    const I = A * 16, s = new a.Quaternion(
      this.boneData[I + 0],
      this.boneData[I + 1],
      this.boneData[I + 2],
      this.boneData[I + 3]
    ), Q = new a.Vector3(
      this.boneData[I + 4],
      this.boneData[I + 5],
      this.boneData[I + 6]
    ), B = s.clone().invert(), i = g.clone().sub(Q);
    i.applyQuaternion(B), B.multiply(e);
    const C = new a.Quaternion(
      i.x,
      i.y,
      i.z,
      0
    ).multiply(s);
    this.boneData[I + 8] = B.x, this.boneData[I + 9] = B.y, this.boneData[I + 10] = B.z, this.boneData[I + 11] = B.w, this.boneData[I + 12] = 0.5 * C.x, this.boneData[I + 13] = 0.5 * C.y, this.boneData[I + 14] = 0.5 * C.z, this.boneData[I + 15] = 0.5 * C.w;
  }
  // Set up to 4 bone indices and weights for a Gsplat. For fewer than 4 bones,
  // you can set the remaining weights to 0 (and index=0).
  setSplatBones(A, e, g) {
    const I = A * 4;
    this.skinData[I + 0] = Math.min(255, Math.max(0, Math.round(g.x * 255))) + (e.x << 8), this.skinData[I + 1] = Math.min(255, Math.max(0, Math.round(g.y * 255))) + (e.y << 8), this.skinData[I + 2] = Math.min(255, Math.max(0, Math.round(g.z * 255))) + (e.z << 8), this.skinData[I + 3] = Math.min(255, Math.max(0, Math.round(g.w * 255))) + (e.w << 8);
  }
  // Call this to indicate that the bones have changed and the Gsplats need to be
  // re-generated with updated skinning.
  updateBones() {
    this.boneTexture.needsUpdate = !0, this.mesh.needsUpdate = !0;
  }
}
const jB = { type: "GsplatSkinning" }, XB = oA(`
  struct GsplatSkinning {
    int numSplats;
    int numBones;
    usampler2DArray skinTexture;
    sampler2D boneTexture;
  };
`), Ho = oA(`
  void applyGsplatSkinning(
    int numSplats, int numBones,
    usampler2DArray skinTexture, sampler2D boneTexture,
    int splatIndex, inout vec3 center, inout vec4 quaternion
  ) {
    if ((splatIndex < 0) || (splatIndex >= numSplats)) {
      return;
    }

    uvec4 skinData = texelFetch(skinTexture, splatTexCoord(splatIndex), 0);

    float weights[4];
    weights[0] = float(skinData.x & 0xffu) / 255.0;
    weights[1] = float(skinData.y & 0xffu) / 255.0;
    weights[2] = float(skinData.z & 0xffu) / 255.0;
    weights[3] = float(skinData.w & 0xffu) / 255.0;

    uint boneIndices[4];
    boneIndices[0] = (skinData.x >> 8u) & 0xffu;
    boneIndices[1] = (skinData.y >> 8u) & 0xffu;
    boneIndices[2] = (skinData.z >> 8u) & 0xffu;
    boneIndices[3] = (skinData.w >> 8u) & 0xffu;

    vec4 quat = vec4(0.0);
    vec4 dual = vec4(0.0);
    for (int i = 0; i < 4; i++) {
      if (weights[i] > 0.0) {
        int boneIndex = int(boneIndices[i]);
        vec4 boneQuat = vec4(0.0, 0.0, 0.0, 1.0);
        vec4 boneDual = vec4(0.0);
        if (boneIndex < numBones) {
          boneQuat = texelFetch(boneTexture, ivec2(2, boneIndex), 0);
          boneDual = texelFetch(boneTexture, ivec2(3, boneIndex), 0);
        }

        if ((i > 0) && (dot(quat, boneQuat) < 0.0)) {
          // Flip sign if next blend is pointing in the opposite direction
          boneQuat = -boneQuat;
          boneDual = -boneDual;
        }
        quat += weights[i] * boneQuat;
        dual += weights[i] * boneDual;
      }
    }

    // Normalize dual quaternion
    float norm = length(quat);
    quat /= norm;
    dual /= norm;
    vec3 translate = vec3(
      2.0 * (-dual.w * quat.x + dual.x * quat.w - dual.y * quat.z + dual.z * quat.y),
      2.0 * (-dual.w * quat.y + dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),
      2.0 * (-dual.w * quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)
    );

    center = quatVec(quat, center) + translate;
    quaternion = quatQuat(quat, quaternion);
  }
`);
function To(t, A) {
  return new Z({
    inTypes: { gsplat: P, skinning: jB },
    outTypes: { gsplat: P },
    globals: () => [XB, Ho],
    inputs: { gsplat: t, skinning: A },
    statements: ({ inputs: g, outputs: I }) => {
      const { skinning: s } = g, { gsplat: Q } = I;
      return UA(`
        ${Q} = ${g.gsplat};
        if (isGsplatActive(${Q}.flags)) {
          applyGsplatSkinning(
            ${s}.numSplats, ${s}.numBones,
            ${s}.skinTexture, ${s}.boneTexture,
            ${Q}.index, ${Q}.center, ${Q}.quaternion
          );
        }
      `);
    }
  }).outputs.gsplat;
}
function fr({
  // PackedSplats object to add splats to
  splats: t,
  // min and max box extents of the grid
  extents: A,
  // step size along each grid axis
  stepSize: e = 1,
  // spherical radius of each Gsplat
  pointRadius: g = 0.01,
  // relative size of the "shadow copy" of each Gsplat placed behind it
  pointShadowScale: I = 2,
  // Gsplat opacity
  opacity: s = 1,
  // Gsplat color (THREE.Color) or function to set color for position:
  // ((THREE.Color, THREE.Vector3) => void) (default: RGB-modulated grid)
  color: Q
}) {
  const i = new a.Vector3(), C = new a.Vector3(), E = new a.Quaternion(0, 0, 0, 1);
  Q == null && (Q = (o, r) => o.set(
    0.55 + 0.45 * Math.cos(r.x * 1),
    0.55 + 0.45 * Math.cos(r.y * 1),
    0.55 + 0.45 * Math.cos(r.z * 1)
  ));
  const n = new a.Color();
  for (let o = A.min.z; o < A.max.z + 1e-6; o += e)
    for (let r = A.min.y; r < A.max.y + 1e-6; r += e)
      for (let l = A.min.x; l < A.max.x + 1e-6; l += e) {
        i.set(l, r, o);
        for (let c = 0; c < 2; ++c)
          C.setScalar(g * (c ? 1 : I)), c ? typeof Q == "function" ? Q(n, i) : n.copy(Q) : n.setScalar(0), t.pushSplat(i, C, E, s, n);
      }
}
function Nr({
  // PackedSplats object to add splats to
  splats: t,
  // scale (Gsplat scale along axis)
  scale: A = 0.25,
  // radius of the axes (Gsplat scale orthogonal to axis)
  axisRadius: e = 75e-4,
  // relative size of the "shadow copy" of each Gsplat placed behind it
  axisShadowScale: g = 2,
  // origins of the axes (default single axis at origin)
  origins: I = [new a.Vector3()]
}) {
  const s = new a.Vector3(), Q = new a.Vector3(), B = new a.Quaternion(0, 0, 0, 1), i = new a.Color(), C = 1;
  for (const E of I)
    for (let n = 0; n < 3; ++n) {
      s.set(
        E.x + (n === 0 ? A : 0),
        E.y + (n === 1 ? A : 0),
        E.z + (n === 2 ? A : 0)
      );
      for (let o = 0; o < 2; ++o)
        Q.set(
          (n === 0 ? A : e) * (o ? 1 : g),
          (n === 1 ? A : e) * (o ? 1 : g),
          (n === 2 ? A : e) * (o ? 1 : g)
        ), i.setRGB(
          o === 0 ? 0 : n === 0 ? 1 : 0,
          o === 0 ? 0 : n === 1 ? 1 : 0,
          o === 0 ? 0 : n === 2 ? 1 : 0
        ), t.pushSplat(s, Q, B, C, i);
    }
}
function Mr({
  // PackedSplats object to add splats to
  splats: t,
  // center of the sphere (default: origin)
  origin: A = new a.Vector3(),
  // radius of the sphere
  radius: e = 1,
  // maximum depth of recursion for subdividing the sphere
  // Warning: Gsplat count grows exponentially with depth
  maxDepth: g = 3,
  // filter function to apply to each point, for example to select
  // points in a certain direction or other function ((THREE.Vector3) => boolean)
  // (default: null)
  filter: I = null,
  // radius of each oriented Gsplat
  pointRadius: s = 0.02,
  // flatness of each oriented Gsplat
  pointThickness: Q = 1e-3,
  // color of each Gsplat (THREE.Color) or function to set color for point:
  // ((THREE.Color, THREE.Vector3) => void) (default: white)
  color: B = new a.Color(1, 1, 1)
}) {
  const i = {};
  function C(c) {
    if (I && !I(c))
      return;
    const h = `${c.x},${c.y},${c.z}`;
    i[h] || (i[h] = c);
  }
  function E(c, h, u, y) {
    if (C(h), C(u), C(y), c >= g)
      return;
    const w = new a.Vector3().addVectors(h, u).normalize(), d = new a.Vector3().addVectors(u, y).normalize(), p = new a.Vector3().addVectors(y, h).normalize();
    E(c + 1, h, w, p), E(c + 1, w, u, d), E(c + 1, p, d, y), E(c + 1, w, d, p);
  }
  for (const c of [-1, 1])
    for (const h of [-1, 1])
      for (const u of [-1, 1]) {
        const y = new a.Vector3(c, 0, 0), w = new a.Vector3(0, h, 0), d = new a.Vector3(0, 0, u);
        E(0, y, w, d);
      }
  const n = Object.values(i), o = new a.Vector3(s, s, Q), r = new a.Quaternion(), l = typeof B == "function" ? new a.Color() : B;
  for (const c of n)
    r.setFromUnitVectors(new a.Vector3(0, 0, -1), c), typeof B == "function" && B(l, c), c.multiplyScalar(e), c.add(A), t.pushSplat(c, o, r, 1, l);
}
function mr({
  // text string to display
  text: t,
  // browser font to render text with (default: "Arial")
  font: A,
  // font size in pixels/Gsplats (default: 32)
  fontSize: e,
  // SplatMesh.recolor tint assuming white Gsplats (default: white)
  color: g,
  // Individual Gsplat color (default: white)
  rgb: I,
  // Gsplat radius (default: 0.8 covers 1-unit spacing well)
  dotRadius: s,
  // text alignment: "left", "center", "right", "start", "end" (default: "start")
  textAlign: Q,
  // line spacing multiplier, lines delimited by "\n" (default: 1.0)
  lineHeight: B,
  // Coordinate scale in object-space (default: 1.0)
  objectScale: i
}) {
  A = A ?? "Arial", e = e ?? 32, g = g ?? new a.Color(1, 1, 1), s = s ?? 0.8, Q = Q ?? "start", B = B ?? 1, i = i ?? 1;
  const C = t.split(`
`), E = document.createElement("canvas"), n = E.getContext("2d");
  if (!n)
    throw new Error("Failed to create canvas context");
  n.font = `${e}px ${A}`, n.textAlign = Q;
  const o = n.measureText(""), r = o.fontBoundingBoxAscent + o.fontBoundingBoxDescent;
  let l = Number.POSITIVE_INFINITY, c = Number.NEGATIVE_INFINITY, h = Number.POSITIVE_INFINITY, u = Number.NEGATIVE_INFINITY;
  for (let G = 0; G < C.length; ++G) {
    const x = n.measureText(C[G]), U = r * B * G;
    l = Math.min(l, -x.actualBoundingBoxLeft), c = Math.max(c, x.actualBoundingBoxRight), h = Math.min(h, U - x.actualBoundingBoxAscent), u = Math.max(u, U + x.actualBoundingBoxDescent);
  }
  const y = Math.floor(l), w = Math.floor(h), d = Math.ceil(c) - y, p = Math.ceil(u) - w;
  E.width = d, E.height = p, n.font = `${e}px ${A}`, n.textAlign = Q, n.textBaseline = "alphabetic", n.fillStyle = "#FFFFFF";
  for (let G = 0; G < C.length; ++G) {
    const x = r * B * G - w;
    n.fillText(C[G], -y, x);
  }
  const m = n.getImageData(0, 0, d, p), N = new Uint8Array(m.data.buffer), f = new qA(), D = new a.Vector3(), R = new a.Vector3().setScalar(s * i), S = new a.Quaternion(0, 0, 0, 1);
  I = I ?? new a.Color(1, 1, 1);
  let M = 0;
  for (let G = 0; G < p; ++G)
    for (let x = 0; x < d; ++x) {
      const U = N[M + 3];
      if (U > 0) {
        const J = U / 255;
        D.set(x - 0.5 * (d - 1), 0.5 * (p - 1) - G, 0), D.multiplyScalar(i), f.pushSplat(D, R, S, J, I);
      }
      M += 4;
    }
  const L = new WA({ packedSplats: f });
  return L.recolor = g, L;
}
function Sr({
  // URL of the image to convert to splats (example: `url: "./image.png"`)
  url: t,
  // Radius of each Gsplat, default covers 1-unit spacing well (default: 0.8)
  dotRadius: A,
  // Subsampling factor for the image. Higher values reduce resolution,
  // for example 2 will halve the width and height by averaging (default: 1)
  subXY: e,
  // Optional callback function to modify each Gsplat before it's added.
  // Return null to skip adding the Gsplat, or a number to set the opacity
  // and add the Gsplat with parameter values in the objects center, rgba etc. were
  // passed into the forEachSplat callback. Ending the callback in `return opacity;`
  // will retain the original opacity.
  // ((width: number, height: number, index: number, center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion, opacity: number, color: THREE.Color) => number | null)
  forEachSplat: g
}) {
  return A = A ?? 0.8, e = Math.max(1, Math.floor(e ?? 1)), new WA({
    constructSplats: async (I) => new Promise((s, Q) => {
      const B = new Image();
      B.crossOrigin = "anonymous", B.onerror = Q, B.onload = () => {
        const { width: i, height: C } = B, E = document.createElement("canvas");
        E.width = i, E.height = C;
        const n = E.getContext("2d");
        if (!n) {
          Q(new Error("Failed to create canvas context"));
          return;
        }
        n.imageSmoothingEnabled = !0, n.imageSmoothingQuality = "high";
        const o = Math.round(i / e), r = Math.round(C / e);
        n.drawImage(B, 0, 0, o, r);
        try {
          const l = n.getImageData(0, 0, o, r), c = new Uint8Array(l.data.buffer), h = new a.Vector3(), u = new a.Vector3().setScalar(A), y = new a.Quaternion(0, 0, 0, 1), w = new a.Color();
          let d = 0;
          for (let p = 0; p < r; ++p)
            for (let m = 0; m < o; ++m) {
              const N = d * 4, f = c[N + 3];
              if (f > 0) {
                let D = f / 255;
                w.set(
                  c[N + 0] / 255,
                  c[N + 1] / 255,
                  c[N + 2] / 255
                ), h.set(
                  m - 0.5 * (o - 1),
                  0.5 * (r - 1) - p,
                  0
                ), u.setScalar(A), y.set(0, 0, 0, 1);
                let R = !0;
                if (g) {
                  const S = g(
                    o,
                    r,
                    d,
                    h,
                    u,
                    y,
                    D,
                    w
                  );
                  D = S ?? D, R = S !== null;
                }
                R && I.pushSplat(h, u, y, D, w);
              }
              d += 1;
            }
          s();
        } catch (l) {
          Q(l);
        }
      }, B.src = t;
    })
  });
}
function Ko({
  box: t,
  cells: A,
  dotScale: e,
  color: g,
  opacity: I
}) {
  A.x = Math.max(1, Math.round(A.x)), A.y = Math.max(1, Math.round(A.y)), A.z = Math.max(1, Math.round(A.z)), I = I ?? 1;
  const s = A.x * A.y * A.z, Q = K("int", A.x), B = K("int", A.y);
  K("int", A.z);
  const i = bA(0), C = new qt({
    numSplats: s,
    generator: SA(
      { index: "int" },
      { gsplat: P },
      ({ index: n }) => {
        if (!n)
          throw new Error("index is undefined");
        const o = Je(n, Q), r = Ie(n, Q), l = Je(r, B), c = Ie(r, B), h = KA({
          vectorType: "ivec3",
          x: o,
          y: l,
          z: c
        }), u = zs(i), y = KA({ vectorType: "ivec2", x: n, y: u }), w = XQ(y), d = K("vec3", t.min), p = K("vec3", t.max), m = Gt(p, d), N = Ie(pA(ct(h), w), K("vec3", A));
        let f, D, R;
        g ? (f = K("float", g.r), D = K("float", g.g), R = K("float", g.b)) : { r: f, g: D, b: R } = St(N).outputs;
        const S = KA({
          vectorType: "vec4",
          r: f,
          g: D,
          b: R,
          a: K("float", I)
        }), M = pA(d, EA(m, N)), L = ct(K("float", e)), G = K("vec4", new a.Quaternion(0, 0, 0, 1));
        let x = Qt({
          flags: Qe("uint", "GSPLAT_FLAG_ACTIVE"),
          index: n,
          center: M,
          scales: L,
          quaternion: G,
          rgba: S
        });
        return x = E.applyGsplat(x), { gsplat: x };
      },
      {
        globals: () => [FA]
      }
    ),
    update: ({ time: n }) => {
      i.value = n, E.update(C), C.updateVersion();
    }
  }), E = new dt();
  return C;
}
const qo = {
  box: new a.Box3(
    new a.Vector3(-1, -1, -1),
    new a.Vector3(1, 1, 1)
  ),
  density: 100,
  fallDirection: new a.Vector3(-1, -3, 1).normalize(),
  fallVelocity: 0.02,
  wanderScale: 0.04,
  wanderVariance: 2,
  color1: new a.Color(1, 1, 1),
  color2: new a.Color(0.5, 0.5, 1),
  minScale: 1e-3,
  maxScale: 5e-3,
  anisoScale: new a.Vector3(1, 1, 1)
}, zo = {
  box: new a.Box3(
    new a.Vector3(-2, -1, -2),
    new a.Vector3(2, 5, 2)
  ),
  density: 10,
  fallDirection: new a.Vector3(0, -1, 0),
  fallVelocity: 2,
  wanderScale: 0.1,
  wanderVariance: 1,
  color1: new a.Color(1, 1, 1),
  color2: new a.Color(0.25, 0.25, 0.5),
  minScale: 5e-3,
  maxScale: 0.01,
  anisoScale: new a.Vector3(0.1, 1, 0.1)
};
function Vo({
  // min and max box extents of the snowBox
  box: t,
  // minimum y-coordinate to clamp particle position, which can be used to
  // fake hitting a ground plane and lingering there for a bit
  minY: A,
  // number of Gsplats to generate (default: calculated from box and density)
  numSplats: e,
  // density of Gsplats per unit volume (default: 100)
  density: g,
  // The xyz anisotropic scale of the Gsplat, which can be used for example
  // to elongate rain particles (default: (1, 1, 1))
  anisoScale: I,
  // Minimum Gsplat particle scale (default: 0.001)
  minScale: s,
  // Maximum Gsplat particle scale (default: 0.005)
  maxScale: Q,
  // The average direction of fall (default: (0, -1, 0))
  fallDirection: B,
  // The average speed of the fall (multiplied with fallDirection) (default: 0.02)
  fallVelocity: i,
  // The world scale of wandering overlay motion (default: 0.01)
  wanderScale: C,
  // Controls how uniformly the particles wander in sync, more variance mean
  // more randomness in the motion (default: 2)
  wanderVariance: E,
  // Color 1 of the two colors interpolated between (default: (1, 1, 1))
  color1: n,
  // Color 2 of the two colors interpolated between (default: (0.5, 0.5, 1))
  color2: o,
  // The base opacity of the Gsplats (default: 1)
  opacity: r,
  // Optional callback function to call each frame.
  onFrame: l
}) {
  t = t ?? new a.Box3(new a.Vector3(-1, -1, -1), new a.Vector3(1, 1, 1));
  const c = (t.max.x - t.min.x) * (t.max.y - t.min.y) * (t.max.z - t.min.z);
  g = g ?? 100, e = e ?? Math.max(1, Math.min(1e6, Math.round(c * g)));
  const h = bA(s ?? 1e-3), u = bA(Q ?? 5e-3), y = At(
    ((I == null ? void 0 : I.clone()) ?? new a.Vector3(1, 1, 1)).normalize()
  ), w = At(
    (B ?? new a.Vector3(0, -1, 0)).normalize()
  ), d = bA(i ?? 0.02), p = bA(C ?? 0.01), m = bA(E ?? 2), N = At(n ?? new a.Color(1, 1, 1)), f = At(o ?? new a.Color(0.5, 0.5, 1)), D = bA(r ?? 1), R = bA(0), S = At(new a.Vector3(0, 0, 0)), M = At(t.min), L = At(t.max), G = bA(A ?? Number.NEGATIVE_INFINITY), x = Gt(L, M), U = new qt({
    numSplats: e,
    generator: SA(
      { index: "int" },
      { gsplat: P },
      ({ index: AA }) => {
        if (!AA)
          throw new Error("index not defined");
        const z = be(AA), eA = St(z).outputs.w;
        let tA = ct(z), X = se(EA(eA, K("float", 100)));
        X = He(EA(Qe("float", "PI"), X)), X = pA(h, EA(X, Gt(u, h)));
        const b = EA(X, y), W = se(EA(eA, K("float", 10))), j = se(eA), _ = jI(N, f, j), Y = EA(_, W), uA = be(
          KA({
            vectorType: "ivec2",
            x: AA,
            y: K("int", 6837)
          })
        );
        let nA = ct(uA), wA = EA(St(uA).outputs.w, m);
        wA = pA(R, wA), tA = pA(tA, S);
        const yA = VI(
          tA,
          K("vec3", new a.Vector3(1, 1, 1))
        );
        tA = pA(M, EA(x, yA));
        const NA = K("vec4", new a.Quaternion(0, 0, 0, 1));
        nA = He(pA(ct(wA), nA)), nA = EA(nA, p);
        let rA = pA(tA, nA), LA = St(rA).outputs.y;
        LA = ZI(G, LA), rA = KA({ vector: rA, y: LA });
        let MA = Qt({
          flags: Qe("uint", "GSPLAT_FLAG_ACTIVE"),
          index: AA,
          center: rA,
          scales: b,
          quaternion: NA,
          rgb: Y,
          opacity: D
        });
        return MA = J.applyGsplat(MA), { gsplat: MA };
      },
      {
        globals: () => [FA]
      }
    ),
    update: ({ object: AA, time: z, deltaTime: eA }) => {
      R.value = z, J.update(U);
      const tA = w.value.clone().multiplyScalar(d.value * eA);
      S.value.add(tA), AA.visible = D.value > 0, l == null || l({ object: AA, time: z, deltaTime: eA }), U.updateVersion();
    }
  }), J = new dt();
  return {
    snow: U,
    min: M,
    max: L,
    minY: G,
    color1: N,
    color2: f,
    opacity: D,
    fallVelocity: d,
    wanderVariance: m,
    wanderScale: p,
    fallDirection: w,
    minScale: h,
    maxScale: u,
    anisoScale: y
  };
}
const Fr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DEFAULT_RAIN: zo,
  DEFAULT_SNOW: qo,
  snowBox: Vo,
  staticBox: Ko
}, Symbol.toStringTag, { value: "Module" }));
function WB(t) {
  return SA({ gsplat: P }, { gsplat: P }, ({ gsplat: A }) => {
    if (!A)
      throw new Error("No gsplat input");
    let e = Ue(A);
    const g = t.applyGsplat(A), I = at(g).outputs.center, s = Ue(g), Q = pQ(I, s), B = Ns(Q, K("float", 0));
    e = tg(B, Ag(e), e);
    const i = pA(
      EA(e, K("float", 0.5)),
      K("float", 0.5)
    );
    return A = Qt({ gsplat: A, rgb: i }), { gsplat: A };
  });
}
function Zo(t) {
  t.enableWorldToView = !0, t.worldModifier = WB(t.context.worldToView), t.updateGenerator();
}
function _B(t, A, e, g) {
  return SA({ gsplat: P }, { gsplat: P }, ({ gsplat: I }) => {
    if (!I)
      throw new Error("No gsplat input");
    let { center: s } = at(I).outputs;
    s = t.apply(s);
    const { z: Q } = St(s).outputs;
    let B = WQ(Ag(Q), A, e);
    return B = tg(g, Gt(K("float", 1), B), B), I = Qt({ gsplat: I, r: B, g: B, b: B }), { gsplat: I };
  });
}
function jo(t, A, e, g) {
  t.enableWorldToView = !0;
  const I = K("float", A), s = K("float", e), Q = K("bool", g ?? !1);
  return t.worldModifier = _B(
    t.context.worldToView,
    I,
    s,
    Q
  ), t.updateGenerator(), {
    minDepth: I,
    maxDepth: s,
    reverse: Q
  };
}
const Gr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  makeDepthColorModifier: _B,
  makeNormalColorModifier: WB,
  setDepthColor: jo,
  setWorldNormalColor: Zo
}, Symbol.toStringTag, { value: "Module" })), Tt = class Tt {
  static createButton(A, e = {}) {
    const g = navigator.xr;
    if (!g)
      return null;
    const I = g, s = document.createElement("button");
    A.xr.enabled = !0, A.xr.setReferenceSpaceType("local");
    function Q() {
      let n = null;
      async function o(c) {
        console.log("onSessionStarted"), c.addEventListener("end", r), await A.xr.setSession(c), s.textContent = "EXIT VR", n = c;
      }
      function r() {
        console.log("onSessionEnded"), n == null || n.removeEventListener("end", r), s.textContent = "ENTER VR", n = null;
      }
      s.style.display = "", s.style.cursor = "pointer", s.style.left = "calc(50% - 100px)", s.style.width = "200px", s.style.height = "100px", s.textContent = "ENTER VR";
      const l = {
        ...e,
        optionalFeatures: [
          // "local-floor",
          // "bounded-floor",
          // "layers",
          ...e.optionalFeatures || []
        ]
      };
      s.onmouseenter = () => {
        s.style.opacity = "1.0";
      }, s.onmouseleave = () => {
        s.style.opacity = "0.5";
      }, s.onclick = () => {
        n === null ? (console.log("requesting session"), I.requestSession("immersive-vr", l).then(
          o
        )) : (console.log("ending session"), n.end());
      };
    }
    function B() {
      s.style.display = "none", s.style.cursor = "auto", s.style.left = "calc(50% - 75px)", s.style.width = "150px", s.onmouseenter = null, s.onmouseleave = null, s.onclick = null;
    }
    function i() {
      B(), s.textContent = "VR NOT SUPPORTED";
    }
    function C(n) {
      B(), console.warn(
        "Exception when trying to call xr.isSessionSupported",
        n
      ), s.textContent = "VR NOT ALLOWED";
    }
    function E(n) {
      n.style.position = "absolute", n.style.bottom = "20px", n.style.padding = "12px 6px", n.style.border = "1px solid #fff", n.style.borderRadius = "4px", n.style.background = "rgba(0,0,0,0.1)", n.style.color = "#fff", n.style.font = "normal 13px sans-serif", n.style.textAlign = "center", n.style.opacity = "0.5", n.style.outline = "none", n.style.zIndex = "999";
    }
    return s.id = "VRButton", s.style.display = "none", E(s), I.isSessionSupported("immersive-vr").then((n) => {
      n ? Q() : i(), n && Tt.xrSessionIsGranted && s.click();
    }).catch(C), s;
  }
  static registerSessionGrantedListener() {
    const A = navigator.xr;
    if (!A)
      return null;
    const e = A;
    /WebXRViewer\//i.test(navigator.userAgent) || e.addEventListener("sessiongranted", () => {
      Tt.xrSessionIsGranted = !0;
    });
  }
};
Tt.xrSessionIsGranted = !1;
let Ve = Tt;
Ve.registerSessionGrantedListener();
const Xo = 0.5, Wo = 0.5, _o = 0;
var Ig = /* @__PURE__ */ ((t) => (t.w = "wrist", t.t0 = "thumb-metacarpal", t.t1 = "thumb-phalanx-proximal", t.t2 = "thumb-phalanx-distal", t.t3 = "thumb-tip", t.i0 = "index-finger-metacarpal", t.i1 = "index-finger-phalanx-proximal", t.i2 = "index-finger-phalanx-intermediate", t.i3 = "index-finger-phalanx-distal", t.i4 = "index-finger-tip", t.m0 = "middle-finger-metacarpal", t.m1 = "middle-finger-phalanx-proximal", t.m2 = "middle-finger-phalanx-intermediate", t.m3 = "middle-finger-phalanx-distal", t.m4 = "middle-finger-tip", t.r0 = "ring-finger-metacarpal", t.r1 = "ring-finger-phalanx-proximal", t.r2 = "ring-finger-phalanx-intermediate", t.r3 = "ring-finger-phalanx-distal", t.r4 = "ring-finger-tip", t.p0 = "pinky-finger-metacarpal", t.p1 = "pinky-finger-phalanx-proximal", t.p2 = "pinky-finger-phalanx-intermediate", t.p3 = "pinky-finger-phalanx-distal", t.p4 = "pinky-finger-tip", t))(Ig || {});
const OB = Object.keys(Ig), xr = OB.length, kr = {
  w: 0,
  t0: 1,
  t1: 2,
  t2: 3,
  t3: 4,
  i0: 5,
  i1: 6,
  i2: 7,
  i3: 8,
  i4: 9,
  m0: 10,
  m1: 11,
  m2: 12,
  m3: 13,
  m4: 14,
  r0: 15,
  r1: 16,
  r2: 17,
  r3: 18,
  r4: 19,
  p0: 20,
  p1: 21,
  p2: 22,
  p3: 23,
  p4: 24
}, ee = {
  w: 0.02,
  t0: 0.02,
  t1: 0.014,
  t2: 0.0115,
  t3: 85e-4,
  i0: 0.022,
  i1: 0.012,
  i2: 85e-4,
  i3: 75e-4,
  i4: 65e-4,
  m0: 0.021,
  m1: 0.012,
  m2: 8e-3,
  m3: 75e-4,
  m4: 65e-4,
  r0: 0.019,
  r1: 0.011,
  r2: 75e-4,
  r3: 7e-3,
  r4: 6e-3,
  p0: 0.012,
  p1: 0.01,
  p2: 7e-3,
  p3: 65e-4,
  p4: 55e-4
}, Oo = [
  ["w", "t0", "t1", "t2", "t3"],
  ["w", "i0", "i1", "i2", "i3", "i4"],
  ["w", "m0", "m1", "m2", "m3", "m4"],
  ["w", "r0", "r1", "r2", "r3", "r4"],
  ["w", "p0", "p1", "p2", "p3", "p4"]
], Po = [
  [8, 10, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6]
], Rr = ["t3", "i4", "m4", "r4", "p4"], Ur = ["i4", "m4", "r4", "p4"];
var PB = /* @__PURE__ */ ((t) => (t.left = "left", t.right = "right", t))(PB || {});
const Ze = Object.keys(PB);
class Lr {
  constructor() {
    this.hands = {}, this.last = {}, this.values = {}, this.tests = {}, this.lastTests = {}, this.updated = !1;
  }
  update({ xr: A, xrFrame: e }) {
    const g = A.getSession();
    if (!g)
      return;
    const I = A.getReferenceSpace();
    if (I && e.getJointPose) {
      this.last = this.hands, this.lastTests = this.tests, this.hands = {}, this.values = {}, this.tests = {};
      for (const s of g.inputSources) {
        if (!s.hand)
          continue;
        const Q = s.handedness;
        this.hands[Q] = {};
        for (const B of OB) {
          const i = s.hand.get(Ig[B]);
          if (i) {
            const C = e.getJointPose(i, I);
            if (C) {
              const { position: E, orientation: n } = C.transform;
              this.hands[Q][B] = {
                position: new JA(E.x, E.y, E.z),
                quaternion: new Qg(
                  n.x,
                  n.y,
                  n.z,
                  n.w
                ),
                radius: C.radius || 1e-3
              };
            }
          }
        }
      }
      for (const s of Ze)
        for (const { key: Q, value: B } of [
          { key: `${s}AllTips`, value: this.allTipsTouching(s) },
          {
            key: `${s}IndexThumb`,
            value: this.touching(s, "i4", s, "t3")
          },
          {
            key: `${s}MiddleThumb`,
            value: this.touching(s, "m4", s, "t3")
          },
          {
            key: `${s}RingThumb`,
            value: this.touching(s, "r4", s, "t3")
          },
          {
            key: `${s}PinkyThumb`,
            value: this.touching(s, "p4", s, "t3")
          },
          { key: `${s}TriTips`, value: this.triTipsTouching(s) }
        ])
          this.values[Q] = B, this.tests[Q] = B === 1 ? !0 : B === 0 ? !1 : this.lastTests[Q] ?? !1;
    }
  }
  makeGhostMesh() {
    const A = new JA(), e = new JA(0.01, 0.01, 0.01), g = new Qg(0, 0, 0, 1), I = new Bg(1, 1, 1), s = Math.PI * 3;
    new Bg(1, 1, 1);
    let Q = 1;
    const B = new WA({
      onFrame: () => {
        let i = 0;
        for (const C of Ze) {
          const E = this.hands[C];
          for (const [n, o] of Oo.entries())
            for (let r = 1; r < o.length; ++r) {
              const l = Po[n][r - 1] * 2, c = r + 1 === o.length, h = E == null ? void 0 : E[o[r - 1]], u = E == null ? void 0 : E[o[r]];
              for (let y = 0; y < l; ++y) {
                const w = (y + 0.5) / l;
                if (Q = 0, h && u) {
                  A.copy(h.position).lerp(u.position, w), g.copy(h.quaternion).slerp(u.quaternion, w);
                  const d = ee[o[r - 1]], p = ee[o[r]];
                  let m = (1 - w) * d + w * p;
                  c && w > 0.8 && (m *= Math.sqrt(1 - ((w - 0.8) / 0.2) ** 2)), e.set(0.65 * m, 0.5 * m, 3e-3), I.set(
                    0.55 + 0.45 * Math.sin(A.x * s),
                    0.55 + 0.45 * Math.sin(A.y * s),
                    0.55 + 0.45 * Math.sin(A.z * s)
                  ), C === "right" && I.set(1 - I.r, 1 - I.g, 1 - I.b), Q = 0.75;
                }
                B.packedSplats.setSplat(
                  i,
                  A,
                  e,
                  g,
                  Q,
                  I
                ), i += 1;
              }
            }
        }
        B.packedSplats.numSplats = i, B.packedSplats.needsUpdate = !0, B.numSplats = i, B.updateVersion();
      }
    });
    return B;
  }
  distance(A, e, g, I, s = !1) {
    const Q = s ? this.last[A] : this.hands[A], B = s ? this.last[g] : this.hands[g], i = Q == null ? void 0 : Q[e], C = B == null ? void 0 : B[I];
    return !i || !C ? Number.POSITIVE_INFINITY : i.position.distanceTo(C.position);
  }
  separation(A, e, g, I, s = !1) {
    const Q = this.distance(A, e, g, I, s);
    return Q === Number.POSITIVE_INFINITY ? Number.POSITIVE_INFINITY : Q - ee[e] - ee[I];
  }
  touching(A, e, g, I, s = !1) {
    const Q = this.separation(A, e, g, I, s);
    return Q === Number.POSITIVE_INFINITY ? Number.POSITIVE_INFINITY : 1 - Math.max(0, Math.min(1, Q / 0.01 - _o));
  }
  allTipsTouching(A, e = !1) {
    return Math.min(
      this.touching(A, "t3", A, "i4", e),
      this.touching(A, "i4", A, "m4", e),
      this.touching(A, "m4", A, "r4", e),
      this.touching(A, "r4", A, "p4", e)
      // this.touching(hand, "p4", hand, "t3", last),
    );
  }
  triTipsTouching(A, e = !1) {
    return Math.min(
      this.touching(A, "t3", A, "i4", e),
      this.touching(A, "i4", A, "m4", e),
      this.touching(A, "m4", A, "t3", e)
    );
  }
}
class Yr {
  constructor({
    xrHands: A,
    control: e,
    moveInertia: g,
    rotateInertia: I
  }) {
    this.lastGrip = {}, this.lastPivot = new JA(), this.rotateVelocity = 0, this.velocity = new JA(), this.xrHands = A, this.control = e, this.moveInertia = g ?? Xo, this.rotateInertia = I ?? Wo;
  }
  update(A) {
    var s, Q, B, i, C;
    const e = {};
    for (const E of Ze) {
      const n = this.xrHands.hands[E];
      n && this.xrHands.tests[`${E}MiddleThumb`] && (e[E] = new JA().add(((s = n.t3) == null ? void 0 : s.position) ?? new JA()).add(((Q = n.i4) == null ? void 0 : Q.position) ?? new JA()).add(((B = n.m4) == null ? void 0 : B.position) ?? new JA()).add(((i = n.r4) == null ? void 0 : i.position) ?? new JA()).add(((C = n.p4) == null ? void 0 : C.position) ?? new JA()).multiplyScalar(1 / 5));
    }
    if (e.left && e.right && this.lastGrip.left && this.lastGrip.right) {
      const E = e.left.clone().add(e.right).multiplyScalar(0.5), n = this.lastGrip.left.clone().add(this.lastGrip.right).multiplyScalar(0.5);
      this.lastPivot = E;
      const o = E.clone().applyMatrix4(this.control.matrix);
      o.sub(n.clone().applyMatrix4(this.control.matrix)), o.multiplyScalar(1 / A), this.velocity.lerp(o, 1 - Math.exp(-20 * A));
      const r = Math.atan2(e.left.z - E.z, e.left.x - E.x), l = Math.atan2(
        this.lastGrip.left.z - n.z,
        this.lastGrip.left.x - n.x
      );
      let c = r - l;
      c > Math.PI ? c -= Math.PI * 2 : c < -Math.PI && (c += Math.PI * 2);
      const h = c / A, u = Math.exp(-20 * A);
      this.rotateVelocity = this.rotateVelocity * u + h * (1 - u);
    } else if (this.rotateVelocity *= Math.exp(-A / this.rotateInertia), e.left && this.lastGrip.left) {
      const E = e.left.clone().applyMatrix4(this.control.matrix);
      E.sub(this.lastGrip.left.clone().applyMatrix4(this.control.matrix)), E.multiplyScalar(1 / A), this.velocity.lerp(E, 1 - Math.exp(-20 * A));
    } else if (e.right && this.lastGrip.right) {
      const E = e.right.clone().applyMatrix4(this.control.matrix);
      E.sub(
        this.lastGrip.right.clone().applyMatrix4(this.control.matrix)
      ), E.multiplyScalar(1 / A), this.velocity.lerp(E, 1 - Math.exp(-20 * A));
    } else
      this.velocity.multiplyScalar(Math.exp(-A / this.moveInertia));
    const g = this.lastPivot.clone().negate(), I = new fe().makeTranslation(g).premultiply(new fe().makeRotationY(this.rotateVelocity * A)).premultiply(new fe().makeTranslation(this.lastPivot));
    this.control.matrix.multiply(I), this.control.matrix.decompose(
      this.control.position,
      this.control.quaternion,
      this.control.scale
    ), this.control.updateMatrixWorld(!0), this.control.position.sub(this.velocity.clone().multiplyScalar(A)), this.lastGrip = e;
  }
}
const $o = 1, Ar = 2, tr = 2e-3, er = 6e-3, gr = 15e-4, Ir = 0.15, sr = 0.15, Qr = 0.1, Br = 2, ir = 1, nr = 200, Cr = 400, Er = 50, ar = {
  KeyW: new a.Vector3(0, 0, -1),
  KeyS: new a.Vector3(0, 0, 1),
  KeyA: new a.Vector3(-1, 0, 0),
  KeyD: new a.Vector3(1, 0, 0),
  KeyR: new a.Vector3(0, 1, 0),
  KeyF: new a.Vector3(0, -1, 0)
}, or = {
  ArrowUp: new a.Vector3(0, 0, -1),
  ArrowDown: new a.Vector3(0, 0, 1),
  ArrowLeft: new a.Vector3(-1, 0, 0),
  ArrowRight: new a.Vector3(1, 0, 0),
  PageUp: new a.Vector3(0, 1, 0),
  PageDown: new a.Vector3(0, -1, 0)
}, rr = {
  KeyQ: new a.Vector3(0, 0, 1),
  KeyE: new a.Vector3(0, 0, -1)
}, cr = {
  Home: new a.Vector3(0, -1, 0),
  End: new a.Vector3(0, 1, 0),
  Insert: new a.Vector3(-1, 0, 0),
  Delete: new a.Vector3(1, 0, 0)
};
class Jr {
  constructor({ canvas: A }) {
    this.lastTime = 0, this.fpsMovement = new hr({}), this.pointerControls = new lr({ canvas: A });
  }
  update(A) {
    const e = performance.now(), g = (e - (this.lastTime || e)) / 1e3;
    this.lastTime = e, this.fpsMovement.update(g, A), this.pointerControls.update(g, A);
  }
}
class hr {
  constructor({
    moveSpeed: A,
    rollSpeed: e,
    stickThreshold: g,
    rotateSpeed: I,
    keycodeMoveMapping: s,
    keycodeRotateMapping: Q,
    gamepadMapping: B,
    capsMultiplier: i,
    shiftMultiplier: C,
    ctrlMultiplier: E,
    xr: n
  } = {}) {
    this.enable = !0, this.moveSpeed = A ?? $o, this.rollSpeed = e ?? Ar, this.stickThreshold = g ?? Qr, this.rotateSpeed = I ?? Br, this.keycodeMoveMapping = s ?? {
      ...ar,
      ...or
    }, this.keycodeRotateMapping = Q ?? {
      ...rr,
      ...cr
    }, this.gamepadMapping = B ?? {
      4: "rollLeft",
      5: "rollRight",
      6: "ctrl",
      7: "shift"
    }, this.capsMultiplier = i ?? 10, this.shiftMultiplier = C ?? 5, this.ctrlMultiplier = E ?? 1 / 5, this.xr = n, this.keydown = {}, this.keycode = {}, document.addEventListener("keydown", (o) => {
      this.keydown[o.key] = !0, this.keycode[o.code] = !0;
    }), document.addEventListener("keyup", (o) => {
      this.keydown[o.key] = !1, this.keycode[o.code] = !1;
    }), window.addEventListener("blur", () => {
      this.keydown = {}, this.keycode = {};
    });
  }
  // Call this method in your render loop with `control` set to the object to control
  // (`THREE.Camera` or a `THREE.Object3D` that contains it), with `deltaTime`
  // in seconds since the last update.
  update(A, e) {
    var E, n;
    if (!this.enable)
      return;
    const g = [new a.Vector2(), new a.Vector2()], I = navigator.getGamepads()[0];
    I && (g[0].set(I.axes[0], I.axes[1]), g[1].set(I.axes[2], I.axes[3]));
    const s = (I == null ? void 0 : I.buttons.map((o) => o.pressed)) || [], Q = Array.from(((n = (E = this.xr) == null ? void 0 : E.getSession()) == null ? void 0 : n.inputSources) ?? []);
    for (const o of Q) {
      const r = o.gamepad;
      if (r)
        switch (o.handedness) {
          case "none": {
            g[0].x += r.axes[0], g[0].y += r.axes[1], g[1].x += r.axes[2], g[1].y += r.axes[3];
            break;
          }
          case "left": {
            g[0].x += r.axes[2], g[0].y += r.axes[3];
            break;
          }
          case "right": {
            g[1].x += r.axes[2], g[1].y += r.axes[3];
            break;
          }
        }
    }
    for (const o of g)
      o.x = Math.abs(o.x) >= this.stickThreshold ? o.x : 0, o.y = Math.abs(o.y) >= this.stickThreshold ? o.y : 0;
    const B = new a.Vector3(
      g[1].x,
      g[1].y,
      0
    ).multiplyScalar(this.rotateSpeed);
    for (const [o, r] of Object.entries(this.keycodeRotateMapping))
      this.keycode[o] && B.add(r);
    for (const o in this.gamepadMapping)
      if (s[Number.parseInt(o)])
        switch (this.gamepadMapping[o]) {
          case "rollLeft":
            B.z += 1;
            break;
          case "rollRight":
            B.z -= 1;
            break;
        }
    if (B.multiply(
      new a.Vector3(this.rotateSpeed, this.rotateSpeed, this.rollSpeed)
    ), B.manhattanLength() > 0) {
      B.multiplyScalar(A);
      const o = new a.Euler().setFromQuaternion(
        e.quaternion,
        "YXZ"
      );
      o.y -= B.x, o.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, o.x - B.y)
      ), o.z = Math.max(-Math.PI, Math.min(Math.PI, o.z + B.z)), e.quaternion.setFromEuler(o);
    }
    const i = new a.Vector3(g[0].x, 0, g[0].y);
    for (const [o, r] of Object.entries(this.keycodeMoveMapping))
      this.keycode[o] && i.add(r);
    let C = 1;
    this.keydown.CapsLock && (C *= this.capsMultiplier), (this.keycode.ShiftLeft || this.keycode.ShiftRight) && (C *= this.shiftMultiplier), (this.keycode.ControlLeft || this.keycode.ControlRight) && (C *= this.ctrlMultiplier);
    for (const o in this.gamepadMapping)
      if (s[Number.parseInt(o)])
        switch (this.gamepadMapping[o]) {
          case "shift":
            C *= this.shiftMultiplier;
            break;
          case "ctrl":
            C *= this.ctrlMultiplier;
            break;
        }
    i.applyQuaternion(e.quaternion), e.position.add(
      i.multiplyScalar(this.moveSpeed * C * A)
    );
  }
}
class lr {
  constructor({
    // The HTML canvas element to attach pointer events to
    canvas: A,
    // Speed of rotation (default DEFAULT_ROTATE_SPEED)
    rotateSpeed: e,
    // Speed of sliding when dragging with right/middle mouse button or two fingers
    // (default DEFAULT_SLIDE_SPEED)
    slideSpeed: g,
    // Speed of movement when using mouse scroll wheel (default DEFAULT_SCROLL_SPEED)
    scrollSpeed: I,
    // Swap the direction of rotation and sliding (default: false)
    swapRotateSlide: s,
    // Reverse the direction of rotation (default: false)
    reverseRotate: Q,
    // Reverse the direction of sliding (default: false)
    reverseSlide: B,
    // Reverse the direction of swipe gestures (default: false)
    reverseSwipe: i,
    // Reverse the direction of scroll wheel movement (default: false)
    reverseScroll: C,
    // Inertia factor for movement (default: DEFAULT_MOVE_INERTIA)
    moveInertia: E,
    // Inertia factor for rotation (default: DEFAULT_ROTATE_INERTIA)
    rotateInertia: n,
    // Pointer rolling scale factor (default: DEFAULT_POINTER_ROLL_SCALE)
    pointerRollScale: o,
    // Callback for double press events (default: () => {})
    doublePress: r
  }) {
    this.enable = !0, this.canvas = A, this.rotateSpeed = e ?? tr, this.slideSpeed = g ?? er, this.scrollSpeed = I ?? gr, this.swapRotateSlide = s ?? !1, this.reverseRotate = Q ?? !1, this.reverseSlide = B ?? !1, this.reverseSwipe = i ?? !1, this.reverseScroll = C ?? !1, this.moveInertia = E ?? sr, this.rotateInertia = n ?? Ir, this.pointerRollScale = o ?? ir, this.doublePress = r ?? (() => {
    }), this.doublePressLimitMs = Cr, this.doublePressDistance = Er, this.lastUp = null, this.rotating = null, this.sliding = null, this.dualPress = !1, this.scroll = new a.Vector3(), this.rotateVelocity = new a.Vector3(), this.moveVelocity = new a.Vector3(), A.addEventListener("pointerdown", (c) => {
      const h = this.getPointerPosition(c), u = h.clone(), y = h.clone(), w = !this.swapRotateSlide && !this.rotating && (c.pointerType !== "mouse" || c.button === 0) || this.swapRotateSlide && this.sliding && !this.rotating && (c.pointerType !== "mouse" || c.button === 1), { pointerId: d, timeStamp: p } = c;
      if (w)
        this.rotating = { initial: u, last: y, position: h, pointerId: d, timeStamp: p }, A.setPointerCapture(c.pointerId), this.dualPress = !1;
      else if (!this.sliding) {
        const m = c.pointerType === "mouse" ? c.button : void 0;
        this.sliding = {
          initial: u,
          last: y,
          position: h,
          pointerId: d,
          button: m,
          timeStamp: p
        }, A.setPointerCapture(c.pointerId), this.dualPress = this.rotating != null && p - this.rotating.timeStamp < nr;
      }
    });
    const l = (c) => {
      var y, w;
      ((y = this.rotating) == null ? void 0 : y.pointerId) === c.pointerId ? (this.rotating = null, A.releasePointerCapture(c.pointerId), this.dualPress && this.sliding && (A.releasePointerCapture(this.sliding.pointerId), this.sliding = null)) : ((w = this.sliding) == null ? void 0 : w.pointerId) === c.pointerId && (this.sliding = null, A.releasePointerCapture(c.pointerId), this.dualPress && this.rotating && (A.releasePointerCapture(this.rotating.pointerId), this.rotating = null));
      const h = this.getPointerPosition(c), u = this.lastUp;
      if (this.lastUp = { position: h, time: c.timeStamp }, u && u.position.distanceTo(h) < this.doublePressDistance) {
        const p = c.timeStamp - u.time;
        p < this.doublePressLimitMs && (this.lastUp = null, this.doublePress({ position: h, intervalMs: p }));
      }
    };
    document.addEventListener("pointerup", l), document.addEventListener("pointercancel", l), document.addEventListener("pointermove", (c) => {
      var h, u;
      ((h = this.rotating) == null ? void 0 : h.pointerId) === c.pointerId ? this.rotating.position = this.getPointerPosition(c) : ((u = this.sliding) == null ? void 0 : u.pointerId) === c.pointerId && (this.sliding.position = this.getPointerPosition(c));
    }), A.addEventListener("contextmenu", (c) => {
      c.preventDefault();
    }), A.addEventListener("wheel", (c) => {
      this.scroll.add(
        new a.Vector3(c.deltaX, c.deltaY, c.deltaZ)
      ), c.preventDefault();
    });
  }
  getPointerPosition(A) {
    const e = this.canvas.getBoundingClientRect();
    return new a.Vector2(
      A.clientX - e.left,
      A.clientY - e.top
    );
  }
  update(A, e) {
    if (!this.enable)
      return;
    if (this.dualPress && this.rotating && this.sliding) {
      const I = [
        this.rotating.position.clone().sub(this.rotating.last),
        this.sliding.position.clone().sub(this.sliding.last)
      ], s = I[0].dot(I[1]);
      if (s >= 0.2) {
        const Q = I[0].clone().add(I[1]), B = new a.Vector3(Q.x, -Q.y, 0);
        B.multiplyScalar(this.slideSpeed * (this.reverseSwipe ? 1 : -1)), B.applyQuaternion(e.quaternion), e.position.add(B), this.moveVelocity = B.clone().multiplyScalar(1 / A);
      } else if (s <= -0.2) {
        const Q = this.sliding.last.clone().sub(this.rotating.last), B = Q.length();
        Q.multiplyScalar(1 / B).normalize();
        const i = new a.Vector2(-Q.y, Q.x), C = [I[0].dot(Q), I[1].dot(Q)], E = [I[0].dot(i), I[1].dot(i)], n = this.rotating.last.clone().add(this.sliding.last).multiplyScalar(0.5);
        let o = new a.Vector3();
        if (e instanceof a.Camera) {
          const y = new a.Vector2(
            n.x / this.canvas.clientWidth * 2 - 1,
            -(n.y / this.canvas.clientHeight) * 2 + 1
          ), w = new a.Raycaster();
          w.setFromCamera(y, e), o = w.ray.direction;
        }
        const r = C[1] - C[0], l = o.multiplyScalar(r * this.slideSpeed);
        e.position.add(l), this.moveVelocity = l.clone().multiplyScalar(1 / A);
        const c = [
          Math.atan(E[0] / (-0.5 * B)),
          Math.atan(E[1] / (0.5 * B))
        ], h = 0.5 * (c[0] + c[1]) * this.pointerRollScale, u = new a.Euler().setFromQuaternion(
          e.quaternion,
          "YXZ"
        );
        u.z = Math.max(
          -Math.PI,
          Math.min(Math.PI, u.z + 0.5 * h)
        ), e.quaternion.setFromEuler(u);
      }
      this.rotating.last.copy(this.rotating.position), this.sliding.last.copy(this.sliding.position);
    } else {
      const I = new a.Vector3();
      if (this.rotating && !this.dualPress) {
        const Q = this.rotating.position.clone().sub(this.rotating.last);
        this.rotating.last.copy(this.rotating.position), I.set(Q.x, Q.y, 0), I.multiplyScalar(this.rotateSpeed * (this.reverseRotate ? -1 : 1)), this.rotateVelocity = I.clone().multiplyScalar(1 / A);
      } else
        this.rotateVelocity.multiplyScalar(
          Math.exp(-A / this.rotateInertia)
        ), I.addScaledVector(this.rotateVelocity, A);
      const s = new a.Euler().setFromQuaternion(
        e.quaternion,
        "YXZ"
      );
      if (s.y -= I.x, s.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, s.x - I.y)
      ), s.z *= Math.exp(-0 * A), e.quaternion.setFromEuler(s), this.sliding && !this.dualPress) {
        const Q = this.sliding.position.clone().sub(this.sliding.last);
        this.sliding.last.copy(this.sliding.position);
        const B = this.sliding.button !== 2 ? new a.Vector3(Q.x, 0, Q.y) : new a.Vector3(Q.x, -Q.y, 0);
        B.multiplyScalar(this.slideSpeed * (this.reverseSlide ? -1 : 1)), B.applyQuaternion(e.quaternion), e.position.add(B), this.moveVelocity = B.clone().multiplyScalar(1 / A);
      } else
        this.moveVelocity.multiplyScalar(
          Math.exp(-A / this.moveInertia)
        ), e.position.addScaledVector(this.moveVelocity, A);
    }
    const g = this.scroll.multiplyScalar(this.scrollSpeed);
    g.set(g.x, g.z, g.y), this.reverseScroll && g.multiplyScalar(-1), g.applyQuaternion(e.quaternion), e.position.add(g), this.scroll.set(0, 0, 0);
  }
}
export {
  Ur as FINGER_TIPS,
  hr as FpsMovement,
  Ze as HANDS,
  PB as Hand,
  Yr as HandMovement,
  OB as JOINT_IDS,
  kr as JOINT_INDEX,
  ee as JOINT_RADIUS,
  Oo as JOINT_SEGMENTS,
  Po as JOINT_SEGMENT_STEPS,
  Rr as JOINT_TIPS,
  Ig as JointEnum,
  xr as NUM_JOINTS,
  qA as PackedSplats,
  Ee as PlyReader,
  lr as PointerControls,
  ne as Readback,
  qn as Sint8ToFloat,
  Jr as SparkControls,
  re as SparkRenderer,
  oe as SparkViewpoint,
  Ge as SplatAccumulator,
  Ce as SplatEdit,
  $a as SplatEditRgbaBlendMode,
  to as SplatEditSdf,
  Oa as SplatEditSdfType,
  eo as SplatEdits,
  vt as SplatFileType,
  qt as SplatGenerator,
  lo as SplatLoader,
  WA as SplatMesh,
  Io as SplatModifier,
  pr as SplatSkinning,
  dt as SplatTransformer,
  Yo as SpzReader,
  tt as SpzWriter,
  Kn as Uint8ToFloat,
  Ve as VRButton,
  Lr as XrHands,
  Nr as constructAxes,
  fr as constructGrid,
  Mr as constructSpherePoints,
  yr as dyno,
  nC as flipPixels,
  ge as floatToSint8,
  GA as floatToUint8,
  dA as fromHalf,
  Fr as generators,
  HB as getSplatFileType,
  Sr as imageSplats,
  BC as isAndroid,
  QC as isMobile,
  iC as isOculus,
  Dr as isPcSogs,
  Gr as modifiers,
  CC as pixelsToPngUrl,
  Le as setPackedSplat,
  mr as textSplats,
  rt as toHalf,
  dr as transcodeSpz,
  Ye as unpackSplat,
  KB as unpackSplats,
  wr as utils
};
//# sourceMappingURL=spark.module.min.js.map
